+++
categories = ['笔记']
tags = ['操作系统']
title = '重生之我学操作系统——第四、五章 进程'
slug = 'note-os-4&5-process'
date = 2024-08-22T16:55:27+08:00
lastmod = 2024-08-22T16:55:27+08:00
draft = false
+++

# 第四、五章 进程

CPU虚拟化的产物：进程（process）

OS重要思想：资源共享思想
- 时分共享：每次由一个实体使用一小段时间（one at a time），典型应用是**进程共享CPU**。
- 空分共享 :  每个实体同时使用一小部分资源（all a little）

## 一、进程的概念

#### 进程是操作系统对运行程序的抽象。

- 当用户运行程序时，操作系统创建一个进程
- 操作系统每次选择一个进程在CPU上运行一段时间
- 操作系统将CPU时分共享给多个进程

#### 特点：

- 时分共享，虚拟化
- 提供假象
- 一个进程等待时另一个进程做事（Overlap）

#### （多）进程的引入：优点

- 提升系统资源利用率，减小延迟
- 提升系统可靠性
- 简化编程模型

## 二、进程的创建

- 将程序的代码和静态数据加载到进程的内存地址空间。

	- **惰性**执行：仅当代码片段或数据需要使用时才进行加载

- 为程序的运行时栈分配内存
- 为程序的堆分配内存
- OS执行一些其他初始化任务
- 运行程序
	- 进程以进程号**PID**唯一标识

查看进程信息：

- $ ps -a 	//查看运行的进程
- $ ps -aux|grep PID 	//查看进程号为PID的进程详细信息
- $ kill PID //杀死PID进程

## 三、进程的状态

- 初始态
- 运行态
- 就绪态
- 阻塞态
- 终止态

#### 进程控制块

进程控制块（PCB）：OS控制进程运行的数据结构

- 进程标识信息：PID等
- 执行现场信息：CPU现场
- 进程映像信息：进程的地址空间
- 进程资源信息：文件、信号、共享内存、消息队列、通讯端口等
- 其他信息

## 四、进程的API

### fork()

UNIX系统中，用fork()创建进程

- 在一个运行的进程（父进程）中创建新的进程
- 子进程得到父进程的资源拷贝，指令相同（子进程从 fork() 处继续执行）
- 父子进程PID不同
- fork() 后父子进程由独立的地址空间
- 父子进程的 fork() 返回值不同（以此进行区分），父进程返回值是子进程的PID，子进程中返回值是0

仅用 fork() 创建进程有什么问题：父子进程的运行顺序/时间有差异，导致不确定性。

### wait()

wait用于等待任一子进程结束。

返回值：

- 如果成功，返回结束的子进程PID
- 如果有错误， 返回-1

`int wc = wait(NULL)`

### exec()

- 将当前进程印象替换成新的程序文件并执行
- 从可执行文件中加载代码和静态数据，覆盖自己的代码和静态数据，堆、栈也会被重新初始化
- exec()成功调用不会返回
- 在子进程中调用exec()，从而执行与父进程不同的程序

### 为什么要这样设计

- fork()大大简化了新进程初始化的工作
- fork()可以更好帮助子进程使用父进程的数据
- fork() ，wait()，exec()的完美结合，千变万化

