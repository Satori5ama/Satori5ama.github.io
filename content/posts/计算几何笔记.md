+++
categories = ['笔记']
tags = ['ACM', '计算几何']
title = '计算几何入门笔记（更新中）'
slug = 'Computational-Geometry'
date = 2024-03-18T08:52:25+08:00
lastmod = 2024-03-18T19:52:25+08:00
draft = false
+++

## 参考文献
[二维计算几何基础 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/geometry/2d/)

[计算几何初步 - 洛谷专栏 (luogu.com)](https://www.luogu.com/article/1pv0nw0s)

[判断两个线段是否相交 - balabala已被注册 - 博客园 (cnblogs.com)](https://www.cnblogs.com/kane1990/p/5742830.html)

[计算几何三维入门 - 洛谷专栏 (luogu.com)](https://www.luogu.com/article/h5e6oinh)

[【笔记】二维凸包 - 洛谷专栏 (luogu.com)](https://www.luogu.com/article/n1isiff4)

## 平面计算几何

### 线段平行
设线段端点分别为$p1,p2$和$p3,p4$

$(p1,p2) × (p3,p4) = 0$

### 线段共线
$(p1,p2)  ×  (p2,p3) = 0$ && $(p1,p2)  ×  (p2,p4) = 0$

### 判断一个点在线段的哪边
假设有向线段为$\overrightarrow{AB}$ ，点为$C$，首先计算外积`$\overrightarrow{AC} × \overrightarrow{AB}=( \overrightarrow{AC}_{x} ⋅\overrightarrow{AB}_{y}-\overrightarrow{AC}_{y} ⋅\overrightarrow{AB}_{x})\overrightarrow{k}$`（因为有`$\overrightarrow{AB}_{z}=0$，$\overrightarrow{AB}_{z}=0$`）。根据右手螺旋定则，如果$\overrightarrow{k}$的系数为正数，说明点$C$在线段$AB$的右侧；如果为负数，说明点$C$在线段$AB$的左侧；如果为0，说明点$C$在线段$AB$所在的直线上。

``` cpp
//*************************************************************************  
// \brief: 计算两个向量的外积（叉乘）。可以根据结果的符号判断三个点的位置关系。  
// \Param: Point A 两个向量的公共起点。  
// \Param: Point B 第一个向量的终点。  
// \Param: Point C 第二个向量的终点。  
// \Returns: double 向量AC与向量AB的外积。如果结果为正数，表明点C在直线AB（直线方向为从A到B）的右侧；  
// 如果结果为负数，表明点C在直线AB（直线方向为从A到B）的左侧；如果结果为0，表明点C在直线AB上。  
//*************************************************************************
double cross(Point A, Point B, Point C) { 
	double cross1 = (C.x - A.x) * (B.y - A.y);
    double cross2 = (C.y - A.y) * (B.x - A.x);
    return (cross1 - cross2);
}
```

### 线段相交

#### 跨立实验
``` cpp
T1 = cross(A1, A2, B1);
T2 = cross(A1, A2, B2);
T3 = cross(B1, B2, A1);
T4 = cross(B1, B2, A2);
```
(1). 如果$(T1 * T2) > 0$ || $(T3 * T4) > 0$，说明一条线段的两个端点在另一条线段的同侧，这两条线段肯定不相交。

(2). 如果$T1 == 0$ && $T2 == 0$，说明两条线段共线，是否相交还需要进一步判断。这时可以通过判断两条线段张成的矩形是否相交来判断，而两个矩形是否相交可以通过快速排斥实验来判断。
``` cpp
//*************************************************************************
// \brief: 	快速排斥实验，判断两个线段张成的矩形区域是否相交。
// \Param: 	Point S1 第一条线段的起点。
// \Param: 	Point E1 第一条线段的终点。
// \Param: 	Point S2 第二条线段的起点。
// \Param: 	Point E2 第二条线段的终点。
// \Returns: 	bool 两个线段张成的矩形区域是否相交。具有对称性，即交换两条线段（参数S1与S2交换、E1与E2交换），结果不变。
//*************************************************************************  
bool rectsIntersect(Point S1, Point E1, Point S2, Point E2) {  
　　if ( Gmin(S1.y, E1.y) <= Gmax(S2.y, E2.y) && Gmax(S1.y, E1.y) >= Gmin(S2.y, E2.y) && Gmin(S1.x, E1.x) <= Gmax(S2.x, E2.x) && Gmax(S1.x, E1.x) >= Gmin(S2.x, E2.x)) {
            return true; } return false;
}
```
(3). 其他情况，两个线段一定相交。

代码实现：

``` cpp
bool segmentsIntersect(Point A1, Point A2, Point B1, Point B2) { double T1 = cross(A1, A2, B1);
    double T2 = cross(A1, A2, B2); 
    double T3 = cross(B1, B2, A1);
    double T4 = cross(B1, B2, A2);　　
    if (((T1 * T2) > 0) || ((T3 * T4) > 0)) {    // 一条线段的两个端点在另一条线段的同侧，不相交。（可能需要额外处理以防止乘法溢出，视具体情况而定。）
        return false;
    } else if(T1 == 0 && T2 == 0) {             // 两条线段共线，利用快速排斥实验进一步判断。此时必有 T3 == 0 && T4 == 0。
        return rectsIntersect(A1, A2, B1, B2);
    } else {                                    // 其它情况，两条线段相交。
        return true;  
 }
}
```

可以看到，这种方法不需要对线段的起终点重合（线段退化为一个点）做特殊判断，也不需要对线段平行（除了共线的情况）做特殊判断。纯几何方法，逻辑更简洁。





