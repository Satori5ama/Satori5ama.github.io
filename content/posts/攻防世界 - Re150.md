+++
categories = ['题解']
tags = ['Reverse']
title = '攻防世界 - Re150'
slug = 'adworld-Re150'
date = 2024-11-21T08:55:27+08:00
lastmod = 2024-11-21T08:55:27+08:00
draft = false

+++

查壳略。

IDA打开，发现没有main函数，只有一个start函数。

![1732158117180](D:\Program Files\Wechat\document\WeChat Files\wxid_9yg1oy10kjp612\FileStorage\Temp\1732158117180.png)

start函数的汇编代码：

``` asm
.eh_frame:080488D4 start           proc near               ; DATA XREF: LOAD:08048018↑o
.eh_frame:080488D4                                         ; start+22↓o
.eh_frame:080488D4                 jmp     short loc_80488EB
.eh_frame:080488D4 ; ---------------------------------------------------------------------------
.eh_frame:080488D6                 db 20h                  ; address 0x08048320
.eh_frame:080488D7                 db  83h
.eh_frame:080488D8                 db    4
.eh_frame:080488D9                 db    8
.eh_frame:080488DA                 db  20h
.eh_frame:080488DB                 db  83h
.eh_frame:080488DC                 db 4
.eh_frame:080488DD                 db    8
.eh_frame:080488DE                 db 32h
.eh_frame:080488DF                 db    4
.eh_frame:080488E0                 db    0
.eh_frame:080488E1                 db 0
.eh_frame:080488E2                 db  73h ; s
.eh_frame:080488E3                 db  79h ; y
.eh_frame:080488E4                 db 63h
.eh_frame:080488E5                 db  6Ch ; l
.eh_frame:080488E6                 db  6Fh ; o
.eh_frame:080488E7                 db  76h ; v
.eh_frame:080488E8                 db 65h
.eh_frame:080488E9                 db  72h ; r
.eh_frame:080488EA                 db  0Ah
.eh_frame:080488EB ; ---------------------------------------------------------------------------
.eh_frame:080488EB
.eh_frame:080488EB loc_80488EB:                            ; CODE XREF: start↑j
.eh_frame:080488EB                 push    ecx
.eh_frame:080488EC                 push    ebx
.eh_frame:080488ED                 push    edx
.eh_frame:080488EE                 push    edi
.eh_frame:080488EF                 push    esi
.eh_frame:080488F0                 call    $+5
.eh_frame:080488F5
.eh_frame:080488F5 loc_80488F5:                            ; DATA XREF: start+22↓o
.eh_frame:080488F5                 pop     ebp             ; ebp = 0x080488F5
.eh_frame:080488F6                 sub     ebp, (offset loc_80488F5 - offset start) ; ebp = start
.eh_frame:080488FC                 mov     eax, 4
.eh_frame:08048901                 mov     ebx, 1          ; fd
.eh_frame:08048906                 mov     ecx, 14
.eh_frame:0804890B                 add     ecx, ebp        ; addr
.eh_frame:0804890D                 mov     edx, 9          ; len
.eh_frame:08048912                 int     80h             ; LINUX - sys_write
.eh_frame:08048914                 mov     ecx, 0Ah
.eh_frame:08048919                 add     ecx, ebp
.eh_frame:0804891B                 mov     ecx, [ecx]
.eh_frame:0804891D                 mov     edi, 6
.eh_frame:08048922                 add     edi, ebp
.eh_frame:08048924                 mov     edi, [edi]
.eh_frame:08048926                 mov     esi, 0
.eh_frame:0804892B
.eh_frame:0804892B loc_804892B:                            ; CODE XREF: start+71↓j
.eh_frame:0804892B                 mov     bl, 0
.eh_frame:0804892D                 mov     al, [edi+esi]
.eh_frame:08048930                 xor     al, 42h
.eh_frame:08048932                 shl     al, 5
.eh_frame:08048935                 or      bl, al
.eh_frame:08048937                 mov     al, [edi+esi]
.eh_frame:0804893A                 xor     al, 42h
.eh_frame:0804893C                 shr     al, 3
.eh_frame:0804893F                 or      bl, al
.eh_frame:08048941                 mov     [edi+esi], bl
.eh_frame:08048944                 inc     esi
.eh_frame:08048945                 loop    loc_804892B
.eh_frame:08048947                 pop     esi
.eh_frame:08048948                 pop     edi
.eh_frame:08048949                 pop     edx
.eh_frame:0804894A                 pop     ebx
.eh_frame:0804894B                 pop     ecx
.eh_frame:0804894C                 mov     eax, 2
.eh_frame:08048951                 add     eax, ebp
.eh_frame:08048953                 mov     eax, [eax]      ; mov eax,[ebp+2]
.eh_frame:08048953                                         ; 此时ebp = start,即地址0x08048320
.eh_frame:08048955                 push    eax
.eh_frame:08048956                 retn
.eh_frame:08048956 start           endp ; sp-analysis failed
```

伪代码：

``` cpp
void start()
{
  int v0; // eax
  int v1; // ecx
  int v2; // edi
  int v3; // esi

  v0 = sys_write(1, (char *)start + 14, 9u);
  v1 = *(_DWORD *)((char *)start + 10);
  v2 = *(_DWORD *)((char *)start + 6);
  v3 = 0;
  do
  {
    *(_BYTE *)(v2 + v3) = ((unsigned __int8)(*(_BYTE *)(v2 + v3) ^ 0x42) >> 3) | (32 * (*(_BYTE *)(v2 + v3) ^ 0x42));
    ++v3;
    --v1;
  }
  while ( v1 );
  __asm { retn }
}
```

下面进行逐行分析：

`loc_80488EB`代码段将5个寄存器压栈，跳转到`loc_80488F5`

代码`0x080488F5`处先将压栈的`esi`的值（`0x080488F5`）弹出到`ebp`，再减去`offset loc_80488F5 - offset start`，将`ebp`的值赋值为`start`地址（0x080488D4）

接着压入`sys_write`的各个参数。

`sys_write` 是linux下的函数，向标准输出写入从 `start + 14` 开始的 9 个字节的数据

`start`的地址是`0x080488D4`，`start + 14` 即从地址`0x080488E2`连续输出9个字节的数据，终端显示“syclover”

接着将`ecx`的值赋为`start + 10`存储的值（0x432），`edi`的值赋成`start + 6`存储的值（`0x08048320`），`esi`作为偏移量从0开始进入`loc_804892B`循环。

参考伪代码，这里`v1`对应`ecx`，`v2`对应`edi`，`v3`对应`esi`，那么循环的作用是对从0x08048320到0x08048752这一段地址，每个地址存储的字节异或0x42后循环右移3位。

继续读`0x08048947`开始的代码，先将5个寄存器弹栈，然后`0x0804894C`到`0x08048953`的代码等效于`mov eax,[ebp + 2]`，联系上文`ebp`等于`start`地址（`0x080488D4`），这里就是将`start + 2`存储的值（`0x08048320`）压入栈中，最后执行`retn`时，`0x08048320`被当作返回地址跳转了。这里`0x08048320`开始的代码，其实就是上面被循环部分处理的地址存储的代码。



