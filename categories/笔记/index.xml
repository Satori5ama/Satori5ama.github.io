<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>笔记 on 终端出口</title><link>https://username.github.io/categories/%E7%AC%94%E8%AE%B0/</link><description>Recent content from 终端出口</description><generator>Hugo</generator><language>en</language><managingEditor>satori5ama@foxmail.com (Satori5ama)</managingEditor><webMaster>satori5ama@foxmail.com (Satori5ama)</webMaster><copyright>All articles on this blog are licensed under the BY-NC-SA license agreement unless otherwise stated. Please indicate the source when reprinting!</copyright><lastBuildDate>Tue, 14 Jan 2025 19:52:25 +0800</lastBuildDate><atom:link href="https://username.github.io/categories/%E7%AC%94%E8%AE%B0/index.xml" rel="self" type="application/rss+xml"/><item><title>人工智能简答题小结</title><link>https://username.github.io/post/summary-of-short-answer-questions-on-artificial-intelligence/</link><pubDate>Tue, 14 Jan 2025 08:52:25 +0800</pubDate><author>satori5ama@foxmail.com (Satori5ama)</author><guid>https://username.github.io/post/summary-of-short-answer-questions-on-artificial-intelligence/</guid><description>
<![CDATA[<h1>人工智能简答题小结</h1><p>Author: Satori5ama(satori5ama@foxmail.com)</p>
        
          <h3 id="1-能够列举并解释四类人工智能定义及其局限性">
<a class="header-anchor" href="#1-%e8%83%bd%e5%a4%9f%e5%88%97%e4%b8%be%e5%b9%b6%e8%a7%a3%e9%87%8a%e5%9b%9b%e7%b1%bb%e4%ba%ba%e5%b7%a5%e6%99%ba%e8%83%bd%e5%ae%9a%e4%b9%89%e5%8f%8a%e5%85%b6%e5%b1%80%e9%99%90%e6%80%a7"></a>
1. 能够列举并解释四类人工智能定义及其局限性
</h3><p><img src="https://jsd.hidict.cn/gh/Satori5ama/Figurebed@main/img/%E7%AE%80%E7%AD%94.assets/1736824305871.png" alt="1736824305871"></p>
<ul>
<li>
<p><strong>像人一样行为</strong></p>
<ul>
<li><strong>图灵测试</strong>： 1950年，阿兰图灵提出了图灵测试，旨在为智能提供一个令人满意的可操作的定义。如果一位人类质询者在提出一些书面问题以后不能区分书面回答来自 人还是来自计算机，那么这台计算机就通过测试。</li>
</ul>
</li>
<li>
<p><strong>像人一样思考</strong></p>
        
        <hr><p>Published on 2025-01-14 at <a href='https://username.github.io/'>终端出口</a>, last modified on 2025-01-14</p>]]></description><category>笔记</category></item><item><title>源代码阅读项目——CheckKernelEATHook</title><link>https://username.github.io/post/source-code-reading-project-checkkerneleathook/</link><pubDate>Wed, 08 Jan 2025 08:52:25 +0800</pubDate><author>satori5ama@foxmail.com (Satori5ama)</author><guid>https://username.github.io/post/source-code-reading-project-checkkerneleathook/</guid><description>
<![CDATA[<h1>源代码阅读项目——CheckKernelEATHook</h1><p>Author: Satori5ama(satori5ama@foxmail.com)</p>
        
          <p><a href="https://github.com/ciyze0101/Windows-Rootkits/tree/master">ciyze0101/Windows-Rootkits</a></p>
<h1 id="项目概况">
<a class="header-anchor" href="#%e9%a1%b9%e7%9b%ae%e6%a6%82%e5%86%b5"></a>
项目概况
</h1><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-markdown" data-lang="markdown"><span class="line"><span class="cl">+---CheckKernelHook
</span></span><span class="line"><span class="cl">|   |   CheckKernelHook.sln
</span></span><span class="line"><span class="cl">|   |
</span></span><span class="line"><span class="cl">|   \---CheckKernelHook
</span></span><span class="line"><span class="cl">|       |   AddService.cpp
</span></span><span class="line"><span class="cl">|       |   AddService.h
</span></span><span class="line"><span class="cl">|       |   CheckKernelHook.aps
</span></span><span class="line"><span class="cl">|       |   CheckKernelHook.cpp
</span></span><span class="line"><span class="cl">|       |   CheckKernelHook.h
</span></span><span class="line"><span class="cl">|       |   CheckKernelHook.rc
</span></span><span class="line"><span class="cl">|       |   CheckKernelHook.vcxproj
</span></span><span class="line"><span class="cl">|       |   CheckKernelHook.vcxproj.filters
</span></span><span class="line"><span class="cl">|       |   CheckKernelHookDlg.cpp
</span></span><span class="line"><span class="cl">|       |   CheckKernelHookDlg.h
</span></span><span class="line"><span class="cl">|       |   resource.h
</span></span><span class="line"><span class="cl">|       |   stdafx.cpp
</span></span><span class="line"><span class="cl">|       |   stdafx.h
</span></span><span class="line"><span class="cl">|       |   targetver.h
</span></span><span class="line"><span class="cl">|       |   tempCodeRunnerFile.cpp
</span></span><span class="line"><span class="cl">|       |
</span></span><span class="line"><span class="cl">|       \---res
</span></span><span class="line"><span class="cl">|               CheckKernelHook.ico
</span></span><span class="line"><span class="cl">|               CheckKernelHook.rc2
</span></span><span class="line"><span class="cl">|               ReadMe.txt
</span></span><span class="line"><span class="cl">|
</span></span><span class="line"><span class="cl">\---CheckKernelHookDrv
</span></span><span class="line"><span class="cl">    |   CheckKernelHook.sln
</span></span><span class="line"><span class="cl">    |
</span></span><span class="line"><span class="cl">    \---CheckKernelHook
</span></span><span class="line"><span class="cl">            CheckKernelHook.vcxproj
</span></span><span class="line"><span class="cl">            CheckKernelHook.vcxproj.filters
</span></span><span class="line"><span class="cl">            Common.c
</span></span><span class="line"><span class="cl">            Common.h
</span></span><span class="line"><span class="cl">            DriverEntry.c
</span></span><span class="line"><span class="cl">            DriverEntry.h
</span></span><span class="line"><span class="cl">            FileSystem.c
</span></span><span class="line"><span class="cl">            FileSystem.h
</span></span><span class="line"><span class="cl">            FixRelocation.c
</span></span><span class="line"><span class="cl">            FixRelocation.h
</span></span><span class="line"><span class="cl">            KernelHookCheck.c
</span></span><span class="line"><span class="cl">            KernelHookCheck.h
</span></span><span class="line"><span class="cl">            KernelReload.c
</span></span><span class="line"><span class="cl">            KernelReload.h
</span></span><span class="line"><span class="cl">            libdasm.c
</span></span><span class="line"><span class="cl">            libdasm.h
</span></span><span class="line"><span class="cl">            ReadMe.txt
</span></span><span class="line"><span class="cl">            Reload.c
</span></span><span class="line"><span class="cl">            Reload.h
</span></span><span class="line"><span class="cl">            sources
</span></span><span class="line"><span class="cl">            tables.h
</span></span></code></pre></div><p>该项目是一个用于检测和管理Windows内核钩子（Kernel Hooks）的应用程序，主要包括用户界面部分和内核驱动部分。</p>
        
        <hr><p>Published on 2025-01-08 at <a href='https://username.github.io/'>终端出口</a>, last modified on 2025-01-08</p>]]></description><category>笔记</category></item><item><title>[Crypto]环域理论及密码应用</title><link>https://username.github.io/post/ring-theory-and-its-applications-in-cryptography/</link><pubDate>Mon, 18 Nov 2024 07:55:27 +0800</pubDate><author>satori5ama@foxmail.com (Satori5ama)</author><guid>https://username.github.io/post/ring-theory-and-its-applications-in-cryptography/</guid><description>
<![CDATA[<h1>[Crypto]环域理论及密码应用</h1><p>Author: Satori5ama(satori5ama@foxmail.com)</p>
        
          <h2 id="1-环的定义">
<a class="header-anchor" href="#1-%e7%8e%af%e7%9a%84%e5%ae%9a%e4%b9%89"></a>
1. 环的定义
</h2><h3 id="定义1511">
<a class="header-anchor" href="#%e5%ae%9a%e4%b9%891511"></a>
定义15.1.1
</h3><p>设$G$是一个非空集合，$\cdot$是$G$上的一个代数运算，如果该运算满足结合律: $\forall a, b, c \in G$, $(a \cdot b) \cdot c = a \cdot (b \cdot c)$，则称 $(G, \cdot)$ 为一个半群 (Semigroup)</p>
        
        <hr><p>Published on 2024-11-18 at <a href='https://username.github.io/'>终端出口</a>, last modified on 2024-11-18</p>]]></description><category>笔记</category></item><item><title>板子合集（自用）</title><link>https://username.github.io/post/template-collection/</link><pubDate>Fri, 25 Oct 2024 08:52:25 +0800</pubDate><author>satori5ama@foxmail.com (Satori5ama)</author><guid>https://username.github.io/post/template-collection/</guid><description>
<![CDATA[<h1>板子合集（自用）</h1><p>Author: Satori5ama(satori5ama@foxmail.com)</p>
        
          <h2 id="计算几何">
<a class="header-anchor" href="#%e8%ae%a1%e7%ae%97%e5%87%a0%e4%bd%95"></a>
计算几何
</h2><h3 id="线段平行">
<a class="header-anchor" href="#%e7%ba%bf%e6%ae%b5%e5%b9%b3%e8%a1%8c"></a>
线段平行
</h3><p>设线段端点分别为$P_1,P_2$和$P_3,P_4$</p>
<p>则</p>
$$\overrightarrow{P_1 P_2} \times \overrightarrow{P_3 P_4} = 0$$<h3 id="线段共线">
<a class="header-anchor" href="#%e7%ba%bf%e6%ae%b5%e5%85%b1%e7%ba%bf"></a>
线段共线
</h3><p>设线段端点分别为$P_1,P_2$和$P_3,P_4$</p>
        
        <hr><p>Published on 2024-10-25 at <a href='https://username.github.io/'>终端出口</a>, last modified on 2024-10-25</p>]]></description><category>笔记</category></item><item><title>重生之我学操作系统——第31章 信号量</title><link>https://username.github.io/post/note-os-31-semaphore/</link><pubDate>Tue, 22 Oct 2024 14:55:27 +0800</pubDate><author>satori5ama@foxmail.com (Satori5ama)</author><guid>https://username.github.io/post/note-os-31-semaphore/</guid><description>
<![CDATA[<h1>重生之我学操作系统——第31章 信号量</h1><p>Author: Satori5ama(satori5ama@foxmail.com)</p>
        
          <h2 id="回顾">
<a class="header-anchor" href="#%e5%9b%9e%e9%a1%be"></a>
回顾：
</h2><p>临界段问题</p>
<ul>
<li>在并发程序中，资源是共享的</li>
<li>临界段资源：部分资源需要互斥使用</li>
<li>利用“锁”的思想保护临界段资源</li>
</ul>
<p>并发的需求</p>
<ul>
<li>互斥执行、同步执行</li>
</ul>
<h2 id="一信号量的定义">
<a class="header-anchor" href="#%e4%b8%80%e4%bf%a1%e5%8f%b7%e9%87%8f%e7%9a%84%e5%ae%9a%e4%b9%89"></a>
一、信号量的定义
</h2><p>控制并发的信号灯-信号量(semaphore)</p>
        
        <hr><p>Published on 2024-10-22 at <a href='https://username.github.io/'>终端出口</a>, last modified on 2024-10-22</p>]]></description><category>笔记</category></item><item><title>[Crypto]整数的阶和原根</title><link>https://username.github.io/post/order-of-an-integer-and-primitive-root/</link><pubDate>Mon, 21 Oct 2024 07:55:27 +0800</pubDate><author>satori5ama@foxmail.com (Satori5ama)</author><guid>https://username.github.io/post/order-of-an-integer-and-primitive-root/</guid><description>
<![CDATA[<h1>[Crypto]整数的阶和原根</h1><p>Author: Satori5ama(satori5ama@foxmail.com)</p>
        
          <blockquote>
<p>你说的对，但是感觉不如原根。原根，是一个数学符号。设m是正整数，a是整数，若a模m的阶等于φ(m)，则称a为模m的一个原根。假设一个数g是P的原根，那么g^imodP的结果两两不同，且有1&lt;g&lt;P，0&lt;i&lt;P，归根到底就是g^(P-1)=1(modP)当且仅当指数为P-1的时候成立。(这里P是素数)。你的数学很差，我现在每天用原根都能做1e5次数据规模1e6的NTT，每个月差不多3e6次卷积，也就是现实生活中3e18次乘法运算，换算过来最少也要算1000年。虽然我只有14岁，但是已经超越了中国绝大多数人(包括你)的水平，这便是原根给我的资本</p>
        
        <hr><p>Published on 2024-10-21 at <a href='https://username.github.io/'>终端出口</a>, last modified on 2024-10-21</p>]]></description><category>笔记</category></item><item><title>[Crypto]群理论</title><link>https://username.github.io/post/group-theory/</link><pubDate>Mon, 14 Oct 2024 07:55:27 +0800</pubDate><author>satori5ama@foxmail.com (Satori5ama)</author><guid>https://username.github.io/post/group-theory/</guid><description>
<![CDATA[<h1>[Crypto]群理论</h1><p>Author: Satori5ama(satori5ama@foxmail.com)</p>
        
          <h2 id="一-代数运算">
<a class="header-anchor" href="#%e4%b8%80-%e4%bb%a3%e6%95%b0%e8%bf%90%e7%ae%97"></a>
一、 代数运算
</h2><h3 id="定义121">
<a class="header-anchor" href="#%e5%ae%9a%e4%b9%89121"></a>
定义12.1
</h3><p>设 $M$ 是一个非空集合，如果存在一个对应规则 $f$，使得对 $M$ 中任意两个元素 $a$ 和 $b$ ，在 $M$ 中都有唯一确定的元素 $c$ 与它们对应，则称 $f$ 为 $M$ 上的一个<strong>代数运算</strong>(二元运算)，记作 $c=f(a,b)$ 或简记为$c=a·b$ .（<strong>封闭性</strong>）</p>
        
        <hr><p>Published on 2024-10-14 at <a href='https://username.github.io/'>终端出口</a>, last modified on 2024-10-14</p>]]></description><category>笔记</category></item><item><title>重生之我学操作系统——第28章 锁</title><link>https://username.github.io/post/note-os-28-lock/</link><pubDate>Mon, 07 Oct 2024 16:55:27 +0800</pubDate><author>satori5ama@foxmail.com (Satori5ama)</author><guid>https://username.github.io/post/note-os-28-lock/</guid><description>
<![CDATA[<h1>重生之我学操作系统——第28章 锁</h1><p>Author: Satori5ama(satori5ama@foxmail.com)</p>
        
          <h2 id="一锁的基本思想">
<a class="header-anchor" href="#%e4%b8%80%e9%94%81%e7%9a%84%e5%9f%ba%e6%9c%ac%e6%80%9d%e6%83%b3"></a>
一、锁的基本思想
</h2><ul>
<li>通过加锁来保证临界区的原子性</li>
</ul>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">lock_t</span> <span class="n">mutex</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>	
</span></span><span class="line"><span class="cl"><span class="c1">// 获取锁，如果已被占用， 则等待，直到获得锁为止
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">balance</span> <span class="o">=</span> <span class="n">balance</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 释放锁
</span></span></span></code></pre></div><ul>
<li>如何评价锁的实现
<ul>
<li>有效性：只有一个线程能拿到锁</li>
<li>公平性：所有线程都有机会拿到锁
<ul>
<li>不会出现饿死情况</li>
</ul>
</li>
<li>性能：时间开销小</li>
</ul>
</li>
</ul>
<p>锁的实现一般要使用某种特 殊硬件指令，但也可以不用</p>
        
        <hr><p>Published on 2024-10-07 at <a href='https://username.github.io/'>终端出口</a>, last modified on 2024-10-08</p>]]></description><category>笔记</category></item><item><title>重生之我学操作系统——第29章 基于锁的并发数据结构</title><link>https://username.github.io/post/note-os-29-lock-based-concurrent-data-structures/</link><pubDate>Tue, 08 Oct 2024 16:55:27 +0800</pubDate><author>satori5ama@foxmail.com (Satori5ama)</author><guid>https://username.github.io/post/note-os-29-lock-based-concurrent-data-structures/</guid><description>
<![CDATA[<h1>重生之我学操作系统——第29章 基于锁的并发数据结构</h1><p>Author: Satori5ama(satori5ama@foxmail.com)</p>
        
          <h2 id="一并发计数器">
<a class="header-anchor" href="#%e4%b8%80%e5%b9%b6%e5%8f%91%e8%ae%a1%e6%95%b0%e5%99%a8"></a>
一、并发计数器
</h2><h3 id="一个简单的计数器">
<a class="header-anchor" href="#%e4%b8%80%e4%b8%aa%e7%ae%80%e5%8d%95%e7%9a%84%e8%ae%a1%e6%95%b0%e5%99%a8"></a>
一个简单的计数器
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="kt">counter_t</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="kt">counter_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="kt">counter_t</span><span class="o">*</span> <span class="n">c</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">increment</span><span class="p">(</span><span class="kt">counter_t</span><span class="o">*</span> <span class="n">c</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">decrement</span><span class="p">(</span><span class="kt">counter_t</span><span class="o">*</span> <span class="n">c</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">get</span><span class="p">(</span><span class="kt">counter_t</span><span class="o">*</span> <span class="n">c</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>哪些地方需要加锁?</p>
<p>一种加锁方法：（全局都加上锁）</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="kt">counter_t</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pthread_mutex_t</span> <span class="n">lock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="kt">counter_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="kt">counter_t</span><span class="o">*</span> <span class="n">c</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">increment</span><span class="p">(</span><span class="kt">counter_t</span><span class="o">*</span> <span class="n">c</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">++</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">decrement</span><span class="p">(</span><span class="kt">counter_t</span><span class="o">*</span> <span class="n">c</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">c</span><span class="o">-&gt;</span><span class="n">value</span><span class="o">--</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">get</span><span class="p">(</span><span class="kt">counter_t</span><span class="o">*</span> <span class="n">c</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>问题:扩展性差</p>
        
        <hr><p>Published on 2024-10-08 at <a href='https://username.github.io/'>终端出口</a>, last modified on 2024-10-08</p>]]></description><category>笔记</category></item><item><title>重生之我学操作系统——第30章 条件变量</title><link>https://username.github.io/post/note-os-30-conditional-variable/</link><pubDate>Tue, 08 Oct 2024 17:55:27 +0800</pubDate><author>satori5ama@foxmail.com (Satori5ama)</author><guid>https://username.github.io/post/note-os-30-conditional-variable/</guid><description>
<![CDATA[<h1>重生之我学操作系统——第30章 条件变量</h1><p>Author: Satori5ama(satori5ama@foxmail.com)</p>
        
          <ul>
<li>park()可以让调用线程休眠</li>
<li>unpark(tid)可以唤醒tid标识的线程</li>
<li>setpark()可以使线程从park直接返回（其他线程调用unpark后）</li>
<li>Linux系统里提供futex实现类似机制</li>
</ul>
<h3 id="为什么我们需要条件变量">
<a class="header-anchor" href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%88%91%e4%bb%ac%e9%9c%80%e8%a6%81%e6%9d%a1%e4%bb%b6%e5%8f%98%e9%87%8f"></a>
为什么我们需要条件变量
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span><span class="o">*</span> <span class="nf">child</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;child</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="c1">// XXX how to indicate we are done?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[]){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;parent: begin</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pthread_t</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> <span class="c1">// create child
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="c1">// xxx how to wait for child?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;parent: end</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><h3 id="一种低效的实现">
<a class="header-anchor" href="#%e4%b8%80%e7%a7%8d%e4%bd%8e%e6%95%88%e7%9a%84%e5%ae%9e%e7%8e%b0"></a>
一种低效的实现
</h3><div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">volatile</span> <span class="kt">int</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span><span class="o">*</span> <span class="nf">child</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;child</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">argv</span><span class="p">[]){</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;parent: begin</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">pthread_t</span> <span class="n">c</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> <span class="c1">// create child
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span><span class="p">(</span><span class="n">done</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="p">;</span> <span class="c1">// spin
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;parent: end</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p>目的:判断A是否执行完，A执行完后B才能执行</p>
        
        <hr><p>Published on 2024-10-08 at <a href='https://username.github.io/'>终端出口</a>, last modified on 2024-10-08</p>]]></description><category>笔记</category></item></channel></rss>