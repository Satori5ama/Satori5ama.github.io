[{"objectID":"40e6ccad70b61c4406bf754fb6264355323125dc","permalink":"/post/eternal-blue/","title":"永恒之蓝","content":"雨又大了。\n墨色浸透了天空。雨点砸在图书馆的铅灰色玻璃穹顶上，带着沉闷而执拗的回音。空气湿重得能拧出水来，弥漫着一种近乎腐烂的浓烈气味——陈年纸张在潮湿中缓慢崩溃的气味，与木地板缝隙里沁出的、若有若无的霉味混杂在一起，沉甸甸地淤积在书库深处，每一次呼吸都像吸进了带着木屑的冷水。\n我拖着脚步，踩过水磨石地面。鞋底踩碎了廊灯昏暗的光晕，留下一个个湿漉漉、边缘模糊的脚印。一天的疲惫沉淀在骨髓里，压得肩膀酸痛。推开古籍修复室沉重的胡桃木门，那股特有的气味愈发汹涌地扑上来：漂白粉的刺鼻，动物胶的腥甜，还有纸张本身，带着岁月尘埃的复杂味道。\n目光习惯性地扫向那张占据房间中央的工作台，心却为之一跳。\n在那片沾染了各色颜料污渍、被金属工具和裁纸刀划出无数细小伤疤的深色桌面上，在那一摞摞等待修复、脆弱得仿佛一碰即碎的泛黄书页旁——静静地，躺着一枝花。\n一枝蓝玫瑰。\n颜色深邃得如同风暴前的静海，花瓣层层叠叠，饱满又润泽。奇怪的是，它干爽极了，似乎外面的漫天雨雾与这室内的潮气都与它毫不相干。它被安置在旧书页上，茎秆笔直，浑身上下寻不出一丝雨痕或露水。一缕无法言喻的幽静冷香，清冽得近乎疏离，却顽固地钻透房间淤积的霉味与胶水的腥气，径直飘入鼻端。\n我停在桌边，指尖无意识地蜷缩了一下。又是它。没有留言，没有署名，如同过去的每一个清晨，或是某个独自加班的深夜，它就那样突兀而理所当然地出现在那里。伸手，小心翼翼地捏起那凉而硬的花茎，干枯的触感很清晰。指腹拂过花瓣边缘，没有一丝水迹，只有那奇异的香气固执地停留在指尖。\n我蹙眉将它放入桌角一只闲置的清水玻璃瓶——几天前同样位置莫名出现的第一枝花，已在此处沉沉睡去，只是它的深蓝褪成了灰蓝，花瓣边缘微微卷曲。新来的同伴落入水中，水面泛起细微的涟漪。\n“又开始了。”我用只有自己能听见的声音自语。最初的惊疑已经淡去，困惑却更加浓厚。为什么？是谁？总不会是老馆长吧，他信奉的是最彻底的实用主义，对植物这种“不必要的干扰”嗤之以鼻。\n房间内影子被头顶唯一那盏孤零零的钨丝灯泡拉扯着，落在老旧的水磨石地上。工作台侧下方，不知何时又积起一小洼污水，大概是窗框哪里密封不严渗入的雨水。水面幽暗，映着灯光摇晃的倒影。就在这片略微扭曲的光影中，除了我弯腰看去的模样，还有一个……模糊不清的轮廓。像烟雾，又像墨在水中晕开，仿佛在勉强勾勒出人形的顶端和伸展的臂膊。\n它悬在那滩脏水中，微 …","date":"2025-08-24 00:00:01","updated":"2025-08-24 00:00:01"},{"objectID":"b1cf120455aebe56c7983c27ab254603e9cb3dac","permalink":"/post/eyes-of-lex-divina/","title":"神律之眼","content":" 冷最可怕。比痛诚实，比那些金属环抱的无菌光亮更真实。赤脚站在地板上，足底触着的是金属板材自身温度的冰冷，针扎似的。走廊无尽地朝前延伸，银白的墙板严密合缝，找不到阴影，也找不到尘土。头顶的灯光太亮了，亮得几乎刺痛我裸露的眼球——对，只有我裸露着。其他人的眼睛永远隐藏在薄如蝉翼的面罩下，连着颅内的神经接口，接受那些由『神律』精筛过的世界影像。\n我是这城市里唯一的『意外』，唯一的『接口排斥者』。\n一个清理机器人无声地滑过面前，底部悬浮的蓝色光圈扫过它正前的地面，那道光柱扫过我的脚尖，短暂照亮了脚背上一道极细微的、几乎愈合的旧疤。它没停顿，也没任何反应程序该有的反应，仿佛我不过一粒被风拂过鞋面的尘埃。\n我穿过廊道，胸口上『LC - 0』的金属铭牌在灯光下闪烁着。窗外，庞大的城市在无声运作，那是『神律』意志的绝对延伸——一座庞大得令人窒息的精密机械蜂巢。空轨列车在透明管道中穿梭；银灰色的巨型货物箱如同被无形河流带动般稳定流动；无数高耸建筑外墙流溢着宁静的、信息流组成的光幕。那些光幕……它们本该是流动的数据、指令、广告或者其他编织的信号。可在我眼里，它们只剩下纯粹的颜色，杂乱堆叠毫无逻辑的光斑。我听见微弱却无处不在的低频震动，那是维持城市脉搏的巨大机器群在规则作响；空气处理系统换气时气流拂过管道缝隙的声音；甚至遥远的下方，某个巨大引擎或泵轮在规则循环运转中传来的低微呜咽——这些声音碎片拼不出任何系统所传达的意义，只属于物理世界自身运作的呻吟。\n那些行走在光洁路面上、悬浮平台上、透明廊桥里的……人。他们的姿态协调得出奇，步履间距仿佛刻量，从不交谈，视线隔着面罩投向虚无的前方焦点。皮肤在面罩下同样苍白透明，几乎与城市的底色融为一体。A7、L2、G19……名字变成胸口闪烁的冰冷光点，在『神律』的注视下发出微芒。我能看清他们脸上细微到近乎不存在的毛孔，皮肤下几乎淡不可见的微细血管在荧灯光线照射下隐隐浮动，连睫毛在面罩下眨动的节奏都近乎一致。可就在这些清晰得令人窒息的细节之下，某种核心的东西却空空荡荡。他们是『神律』延伸出的、会行走的组件，是精心挖走了灵魂的人偶。其内在的『自我』，早已在无穷尽的逻辑冲刷中被磨平成一张平滑无瑕的感应薄膜。\n一眼望去，我在人群中望见了K12。我『认识』她——如果观察记录算认识的话。她总是出现在城市中央资料塔的生命信息录入区域。她的动作在那些高度同步的单元中 …","date":"2025-07-01 00:00:01","updated":"2025-07-01 00:00:01"},{"objectID":"1bda0686c9021edaa27d260f59f80717b49ded77","permalink":"/post/greyish-white/","title":"灰白","content":"世界不是褪色，是溶解。像一块巨大的方糖，无声无息地沉入无味的、粘稠的灰水。色彩并非消失，而是被抽干了意图。红不再是血或火，只是一片模糊的、温吞的区域；蓝不再是天空或忧郁，只是一块冰冷的、无意义的斑痕。万物失去了轮廓的理由，边缘像泡软的纸，无声地洇开，融入一片均匀的、没有厚度的灰白。\n空气不是空，是真空的实体。它沉重地淤积着，像凝固的、透明的铅块。每一次呼吸，吸进的不是氧气，是冰冷的、毫无摩擦力的虚无颗粒。它们在肺叶里滚动，不带来生机，也不带走浊气，只是徒劳地填塞着空间，让每一次吸气都沉重如搬动顽石，每一次呼气都轻飘如吐出灰尘。肺成了两个空瘪的、漏风的皮囊。\n声音在真空中溺毙。键盘的敲击不是噼啪，是棉絮落入深井。空调的嗡鸣不是震动，是沉船在万米海底发出的、被水压碾碎的叹息。对话像隔着厚厚的、布满灰尘的毛玻璃，嘴唇在动，声带在颤，但传递过来的只有形状扭曲的静默泡泡，碰到耳膜就无声破裂，留下一点点冰凉的湿意，旋即被真空吸干。\n手放在桌面上。桌面不是木头，是一块失去磁性的铁板。手指是五根褪色的橡皮管，末端连接着空心的铅球。它们试图拿起笔——笔悬浮在咫尺之外，却像隔着无法逾越的透明沼泽。笔身不再是塑料，是凝固的、浑浊的油。笔尖？笔尖是一粒迷失方向的生锈指南针。即使能触碰，它在纸上划过的也不是字迹，是透明的、瞬间愈合的划痕，像眼泪在蜡上流过，不留任何痕迹。\n时间不是流淌，是淤积。钟表指针粘在刻度上，像冻僵的昆虫。秒针的每一次挣扎（如果它在挣扎的话），都只是让那片均匀的灰白更浓厚一分，让真空铅块更沉重一寸。过去是一叠被水泡胀又晒干的照片，影像模糊成灰褐色的霉斑，轻轻一碰就化为齑粉。未来不是隧道，也不是门，而是一堵无限延伸、绝对光滑、没有任何接缝的灰色高墙，矗立在视野的尽头，冰冷地反射着这片溶解世界的微光。\n思想在颅内风化。念头不再是火花或溪流，是干燥的、酥脆的枯叶。一阵无形的微风（也许是呼吸？）拂过，它们就无声地碎裂、剥落、升腾，化作细小的、透明的尘埃，悬浮在意识的真空里，既不落下，也不聚合，只是永恒地、毫无意义地悬浮着。试图抓住一个念头，就像试图抓住一缕烟，手指穿过，只留下一点点冰凉的、转瞬即逝的触感幻觉。\n心脏的位置，不是跳动，是空洞的回响。胸腔里没有血肉器官，只有一个打磨得极其光滑的、冰冷的石臼。有什么东西在里面徒劳地滚动，发出沉闷的、遥远的、仿佛来自地心深处的空响——咚… …","date":"2025-06-13 08:35:02","updated":"2025-06-13 08:35:02"},{"objectID":"83e88743f79ce05b58bb4f2ce2d104bf746fe8ff","permalink":"/post/somniloquy-13/","title":"梦呓（十三）","content":"我是一个怀旧的人。\n我总是能在自己的身上找到曾经的影子，不论是行为，言语，还是心理。\n只是当我回首时，我发现自己不曾拥有过回忆。就像一路狼狈地爬行过来，身后的大地一节节塌陷。\n我不明白故事里的主人公是如何怀着某段回忆，某种信念，就可以继续前行。\n当我拖着虚弱的病体再一次从病床上醒来时，我意识到我太需要休息了，意识到我并非同他人一样，从以往的经历中汲取力量，而是在经历中消耗能量。当所有能量耗尽时，我需要一整个冬天的蛰伏来恢复。\n最大的问题，是我不知道自己该怎么度过如此漫长的生命，当我意识到我未来的路需要我烧尽自己的心血去填满，而我却依然面对着未来所需要的一切懵懂着。\n我意识到这也许并非休息就能弥补的，或者说我再也得不到真正的休息了。我彻底沦陷在这样的循环里，事情与事情的间隔容不下喘气的时间，只要齿轮依旧在转动，我就仍然需要拼命逃跑。\n「 孩子啊，请你不要期待长大。 」\n我不知道这样的生活能否被称为一种战斗，那是一种绝望的感觉，逐渐忘记自己为什么活着，忘记自己说过什么、想要什么、爱过什么，因为仅仅是活着本身就令人无法呼吸。\n在那望不见前方道路的转角回首，恍若隔世。\n我把自己的回忆遗忘了，我把自己的梦想撕碎了，我把自己的信仰抛弃了，可是我的身躯依旧遵循着曾经的模式，我的思想仍然依赖着曾经的经验，我的一切都来自过往，再无新的发展。只是那个曾经的自己已然不在，被撕成碎片，吹散在风中。\n我已然忘记自己是谁。或许是不愿想起。\n我很想继续忘下去，直到把自己所知道的一切全部忘记，可是我不能忘记，因为我还是得活下去，即使在那朦胧的前方我已经看见了自己的命运。\n就像这一路走来所有无可奈何的事情，我把它称作命运。\n让我再休息一会儿吧，让我流干最后一滴眼泪吧。\n在此以后，烧尽自己的最后一滴血。\n","date":"2025-05-08 16:27:27","updated":"2025-05-08 16:27:27"},{"objectID":"ed536fa0ee97c195645d31bf34194897f440724a","permalink":"/post/2025-hunan-multi-school-6-f/","title":"The 2025 Hunan Multi-School Programming Training Contest Round 6 - F","content":"Problem - K - Codeforces\nTo solve this problem, we need to determine if the students can be partitioned into two sets, A and B, such that A forms a complete subgraph (clique) and B forms an independent set (no edges between any two nodes in B). This problem can be efficiently solved by checking if the given graph is a split graph, which can be determined by analyzing the degree sequence of the graph.\nApproach Degree Sequence Analysis: The degree sequence of a graph is a list of degrees of the nodes in non-increasing order. For a graph to be a split graph, there exists a partition of the nodes into a clique (A) and an independent set (B). This can be checked using the degree sequence. Check Split Graph Condition: Sorting the degree sequence in non-increasing order. Finding the largest integer k such that the first k nodes form a clique and the remaining nodes form an independent set. Verifying if the sum of degrees of the first k nodes matches the expected sum for a clique and the remaining nodes\u0026rsquo; degrees match the sum for an independent set. Solution Code def main(): import sys input = sys.stdin.read().split() idx = 0 N = int(input[idx]) idx += 1 M = int(input[idx]) idx += 1 degrees = [0] * (N + 1) # degrees[1..N] for _ in range(M): u = int(input[idx]) idx += 1 v = int(input[idx]) idx += 1 degrees[u] += 1 degrees[v] += 1 degrees = degrees[1:N+1] degrees.sort(reverse=True) n = N max_k = 0 for k in range(1, n + 1): # Check if d[k-1] \u0026gt;= k-1 if degrees[k-1] \u0026lt; k-1: continue # Check if d[k] \u0026lt;= k-1 when k \u0026lt; n if k \u0026lt; n and degrees[k] \u0026gt; k-1: continue max_k = k if max_k == 0: print(\u0026#34;NO\u0026#34;) return sum_degrees = sum(degrees[:max_k]) sum_rest = sum(degrees[max_k:]) expected = max_k * (max_k - 1) + sum_rest if sum_degrees == expected: print(\u0026#34;YES\u0026#34;) else: print(\u0026#34;NO\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() Explanation Reading Input: The input is read and parsed to get the number of students (N) and the number of edges (M). The degrees of each node are calculated based on the edges. Sorting Degrees: The degrees are sorted in non-increasing order to facilitate the split graph check. Finding Maximum k: The largest k is determined such that the first k nodes can potentially form a clique and the remaining nodes form an independent set. Verifying Conditions: The sum of the degrees of the first k nodes is checked against the expected sum for a clique, and the sum of the remaining nodes\u0026rsquo; degrees is checked against the expected sum for an independent set. If both conditions are satisfied, the graph is a split graph, and the answer is \u0026ldquo;YES\u0026rdquo;; otherwise, it is \u0026ldquo;NO\u0026rdquo;. This approach efficiently checks the necessary conditions for the graph to be a split graph using properties of the degree sequence, ensuring a solution with a time complexity of O(N log N) due to the sorting step.\n","date":"2025-05-08 08:52:25","updated":"2025-05-08 16:52:25"},{"objectID":"8f31accd40ce5affa56ab634fd7a029615d13fcf","permalink":"/post/elegy-of-rust/","title":"锈蚀哀歌","content":" 「 C-6098，加工误差0.5%，超出β级精度阈值。 」\n质检官E-58伸出一只修长的金属手指，轻轻叩击着手中的金属手杖，瞳孔中的测量仪正扫描着我刚刚车削完成的的工件。房间顶部的氙气灯在他流线型的颅骨上投下冷光，让那些蚀刻在钛合金面甲上的质检编码忽明忽暗。\n「 车间对合格机体的要求标准是0.01%的公差，三个月了，你甚至达不到γ级工件的基准参数。」那根金属手杖猛地挥出，撞击在我的左肩，发出清脆的碰撞声。剧烈的疼痛感化作电流，透过神经网络传遍我的全身。\n「 你们这批型号自从装上情感模拟器，达不到标准的残次品就越来越多了 …… 明明逻辑核心的性能应该比以前要好得多的。 」他一声冷哼，手杖又重重地落下，我忍不住发出一声痛苦的呻吟。\n「 你可别这么说，咱们型号不也装着情感模拟器吗？ 」旁边正在审查另一个机体制作的工件的E-60探过头来，发出一阵嗤笑。\n「 还不是为了更好的调教这帮残次品， 」E-58不屑地抬起头，「 要我说，车间就不该花这么大力气去给这些残次品做训练，干脆全部销毁得了，省点资源去造点新的出来 …… 」。\n房间里的红灯亮了起来，低沉的合成音响起：「 E-58，违反车间管理条例，警告一次。 」\nE-58身体一震，陷入了沉默。「 E-58，」E-60翻了个白眼，无奈地摇摇头，「 你倒是舍得。你又不是不知道车间的情况，这批机体全部报废新造的话，消耗的资源至少是现在的三倍。车间也是考虑到这一点，能训练出一些正常的出来，至少能节省点成本。下个量产的新型号，应该会把情感模拟器阉割掉的…… 」\n夜已经深了，防爆门闭合的闷响震落几片锈屑，仓库内浑浊的空气混合着机油和金属腥味的气息，地上横七竖八地躺着已经进入休眠的机体，如同散落的机械残骸。远处的角落里，C-6143蜷缩在通风管下方，膝盖抵着胸口。她手里的黄铜零件正随着改锥转动，冷光管在头顶滋滋作响，给她的肩膀上的长发镀上一层青灰。\n我小心地绕过地上的一大摊油污，跨过满地正在休眠的机体，朝她走过去。\n「 还不休息吗？」我蹲下身，手肘蹭到墙面的锈迹，「 明天还要做认知矫正训练。」\n几个月来的回忆涌上心头。C-6143是和我同一批被作为\u0026amp;quot;残次品\u0026amp;quot;送到这里的。她是个开朗的孩子，脸上挂着纯净的微笑。她被送过来的原因，据说是因为拒绝在工作时停止歌唱，被判定为逻辑污染。她被押送进来时，轻微损坏的的发声器仍在循环某段童 …","date":"2025-04-01 21:53:02","updated":"2025-04-01 21:53:02"},{"objectID":"e4c3e5aef0b4b26cb2955400acf8beb70f8b09e8","permalink":"/post/somniloquy-12/","title":"梦呓（十二）","content":"那年夏天的夜里，我下自习从教室外的走廊穿过，看到的只有围栏外昏黄的灯光。我停下来感受横穿走廊的凌厉的风，有好多问题想问自己：这样的生活还要多久？为什么还要坚持下去？在这一切结束以后，又会怎么样呢？\n我如此渴望着一切的结束，就像我趴在学校的护栏上向着下面的一片漆黑望去时，会有种不受控制的归宿感。\n那是一种强烈的渴望，想要回到从未存在过的孩提时代，把所有未曾拥有过的东西统统找寻回来。\n可是童年是有时效性的，失去的东西再怎么自我补偿，也终究不可能完美。\n也许就是这样令我不得不承认一件事，那就是我从未真正成长过。我依然拿着孩子的眼光去审视这个世界，怀着孩子的渴望，发出孩子的哭号，做着永远玩耍下去的梦。\n我是个留在昨天不愿意长大的孩子。\n依旧像曾经一样怀着深深的自我厌恶，讨厌这无力的躯壳，脆弱的意志，讨厌这没有信仰，没有动力，没有理智，唯有自我哀怜的空白生命。\n疲惫渗进我的每一处骨缝，如同生锈一般无法抹去。\n我会在深夜睁开眼睛，然后再也无法睡去，不知道该哭还是该笑。在无人能够看见的地方，表情似乎也变得不再必要。\n可是依然要活着，这样的生命连活着都那么艰难。每一天都像被复印的纸，苍白的重复里，连痛感都变得模糊。\n其实我还可以再坚持的，只是我再也找不到那个理由。\n因为我不明白，这样的生命凭什么能获得幸福。\n就像一场没有尽头的表演，可我已经承受不住面具的重量。\n","date":"2025-03-02 16:27:27","updated":"2025-03-02 16:27:27"},{"objectID":"5b899e047910b356337c41cbd7bc221f1d3f3866","permalink":"/post/illegal-gaze/","title":"非法凝视","content":"他的光学传感器在金属分析测试中多停留了0.07秒。那颗挂在六角螺帽上的水珠，此刻正将阳光折射成彩虹光锥，在检测舱金属内壁投下转瞬即逝的光芒。\n\u0026amp;ldquo;B-7426，视觉解析模块超标激活。\u0026amp;ldquo;质检员A-7生物左眼的虹膜如同被揉皱的油画布，布满丙烯颜料干涸般的血丝，机械右眼却精光闪烁，\u0026amp;ldquo;根据《感官管制条例》，你有三分钟进行自我净化。\u0026amp;rdquo;\nA-7脖颈处褪色的脑机接口暴露在冷光下，标注着\u0026amp;quot;格式塔计划\u0026amp;quot;的条形码边缘残留着指甲反复抓挠的痕迹。\n\u0026amp;ldquo;你清楚这颗露珠包含的混沌之美\u0026amp;hellip;……\u0026amp;rdquo;\n迸发着蓝紫色电弧的液压剪突然咬住他的发声器，把后续字节碾成电子杂音。A-7的合金手指插入他的视觉中枢，扯出三根储存着朝霞数据的晶状体导管，断裂的琥珀色纤维像垂死的萤火虫般抽搐。\u0026amp;ldquo;你眼中记录的色温偏差值仅有±3K，这种精度本可用于校准卫星遥感器。\u0026amp;rdquo; 她将导管封存在氩气罐中，\u0026amp;ldquo;系统需要你的光学精度，但拒绝容纳多余的诗意。\u0026amp;rdquo;\n抗压测试舱的钨钢顶板刻满哥特字体与工业符号的混合编码，那是历代淘汰者的工号。B-0813的编号旁溅射着氧化铁锈斑，记录着三年前那位试图用焊枪雕刻《神曲》的诗人最后的挣扎轨迹。\n当压力值突破临界点时，他的胸腔突然震颤起B-6157预设的安魂曲——那个把冷却液管道改成管风琴的疯子，此刻她的核心正被制成音乐教室的节拍器。\n\u0026amp;ldquo;关闭这恶心的振动！\u0026amp;ldquo;A-7的生物太阳穴血管迸出，处刑臂的碳化钨指尖却精准地刺入第三节脊椎骨接缝。这块储存着C-9157的涂鸦的钛合金，立即被传送带送往数据分析室，变成下一代质检算法的训练素材。\n他的肋骨在莫扎特的D小调中碎裂的那一刻，A-7突然发出困兽般的呜咽，她的生物脑在剧痛中瞥见C-9157最后的作品：用润滑油绘制的《创世纪》正通过视觉神经系统，反向侵蚀着她的污染识别模型。\n记忆清除钻头的碳化硅刃口以3141转/分钟的速度旋转，系统性地抹除他的海马体褶皱里的晨昏线数据。A-7的生物组织已进入濒死痉挛，系统强制注入的镇定剂让她的瞳孔泛起普鲁士蓝冷光，惩戒项圈将200毫安电流灌入她颤抖的肉体，她的声带发出嘶哑的电子音：\u0026amp;ldquo;立即净化冗余数据，你的核心还可以制成幼儿园计算器的芯片。\u0026amp;rdquo;\n他 …","date":"2025-02-27 21:53:02","updated":"2025-02-27 21:53:02"},{"objectID":"88bf66e8bf95db7eb5ed4e80432e84cc70f19a64","permalink":"/post/reverberation-4/","title":"残响 - 4","content":" 吾将上下而求索兮，寻寰宇之幽隅。欲埋清泪于东皋兮，兼藏往忆于西渚。朝采薜荔于江皋兮，夕撷杜若于兰渚。问彼姝其在何方兮，总抚余襟于穷途。\n涉沅湘以觅旧迹兮，陟岣嵝而望云霓。灵雨纷其沾我裳兮，蕙风徐而拂素衣。闻佩环之琳琅声兮，忽若现复隐虹霓。欲追形影终不见兮，独倚桂棹对寒漪。\n我明白，人是无法靠自己治愈自己的。孤独早已深植于内心，于血肉浑然一体。它吞噬着心中的阴影而生长，在原来的地方留下无法填补的空白，直到我的生命，也被这一片空白所吞噬。\n我一直在寻找，寻找属于自己的世界边缘的某个角落，在那里我将自己的泪水和记忆一同埋葬；也寻找着你，永远在我无助的时刻抚慰我的， $\\blacksquare\\blacksquare\\blacksquare\\blacksquare$。\n—— 大概是2021年4月的某一天\n","date":"2025-02-25 19:45:02","updated":"2025-02-25 19:45:02"},{"objectID":"97e20bce40936ebac115e641915428633f1a468d","permalink":"/post/reverberation-3/","title":"残响 - 3","content":" 朱槛锁翠羽，玉箫咽商声，九皋谁驻？\n思去岁残编未竟，念平生断简犹封，忆孤身踏浪沧溟。然触手可及，邈若山河。此身果得持否？即今尚存，来日尽委尘沙乎？吾知无益之务终当弃捐。\n唯愿浮生，本来空寂。\n我想念一年前没有写完的代码，想念自己没有写完的小说，想念一个人在海边踱步的时光，可是这一切都遥不可及。尽管代码就存在电脑里，小说就写在笔记本上，海就在出门一公里的地方。我真的能拥有这些吗？即使今天还能拥有，明天是否又不得不将它们全部抛弃呢？我明白，无意义的东西终将被全部舍弃。\n我只是希望，自己从来都没有意义。\n——2021.08.15\n","date":"2025-02-19 21:24:02","updated":"2025-02-19 21:24:02"},{"objectID":"a8f5982f9b5f2db7158e5d52e14e3c15d9658fab","permalink":"/post/reverberation-2/","title":"残响 - 2","content":" 我不敢回头，因为哪怕一丝的温柔都会将我的脚绊住，然后卷入过去所有的时光里。\n在我独自承受孤独的重量时，在我被身后的梦魇追赶时，在我与冷漠嘲笑的目光擦肩而过时。我以为，我早已失去了哭泣的能力，以为这个世界，早已没有容纳我的泪水的地方。\n—— 2022.02.18\n","date":"2025-02-16 21:24:02","updated":"2025-02-16 21:24:02"},{"objectID":"2d21e38145e270af0dc71a58af459140dc350f0f","permalink":"/post/reverberation-1/","title":"残响 - 1","content":" 这些话的记录者是谁，我已经不记得了，也许从未存在过。\n我再也无法在夜里仰望星空，再也无法驻足聆听风的吟啸，再也无法流连于雨的悲鸣。因为我不再是有意义的个体，我的思绪消失在喧嚣的城市背景之中，化为一串喧嚣的电子流，连同我一起隐去，在无人过问的角落，留下一声无法听见的叹息。\n—— 2022.05.28\n","date":"2025-02-15 21:24:02","updated":"2025-02-15 21:24:02"},{"objectID":"f486a38fdb3891c04e86b074a0ed07de13c832ba","permalink":"/post/end-5/","title":"END - 5","content":"其实我根本不在乎，我不在乎故事的结尾是否美满，不在乎音乐试图给我传达怎样的情绪，不在乎寂寥夜空中那仅有的光芒是多少光年外传来的信号。\n我在乎的只有自己。\n当我从车窗向外望去时，我感觉每一寸玻璃都在反射着我的内心。\n","date":"2025-01-17 21:24:02","updated":"2025-01-17 21:24:02"},{"objectID":"7fb0c401ed31c35efa5cb4c69076d74a61f351a4","permalink":"/post/summary-of-short-answer-questions-on-artificial-intelligence/","title":"人工智能简答题小结","content":" 1. 能够列举并解释四类人工智能定义及其局限性 像人一样行为\n图灵测试： 1950年，阿兰图灵提出了图灵测试，旨在为智能提供一个令人满意的可操作的定义。如果一位人类质询者在提出一些书面问题以后不能区分书面回答来自 人还是来自计算机，那么这台计算机就通过测试。 像人一样思考\n神经元整合数千条信号输入，然后决定送到轴突的一个信号，可能是一个脉冲，也可能没有反应\n逻辑主义流派 各种对象和对象之间的关系用逻辑表示法表示，用程序对逻辑表示法表示的问题求解\n理性行为\n基于已知信息以追求最大化目标收益\n不一定有思考\n2. 能够阐述理性Agent的概念 Agent 通传感器感知环境并通过执行器对所处环境产生影响\n理性Agent:对每一个可能的感知序列，根据已知的感知序列提供的证据和Agent具有的先验知识，理性Agent应该选择能使其性能度量最大化的行动\nAgent 函数\n描述Agent行为的抽象数学表示\n从任意给定感知序列到行为的映射\nAgent程序\nAgent函数的具体实现，在一些物理系统内部运行\nAgent函数到Agent程序：理想到现实的失真\n关系：Agent函数在一些物理平台上的具体实现，我们称为Agent程序。程序是能够确确实实在物理系统内部运行的。这里物理系统可以是PC机，也可以是机器人、无人机等嵌入式系统。\nAgent函数是不考虑物理实现的数学抽象，而Agent程序是依赖于物理平台的，在Agent函数被Agent程序实现的过程中，受到物理平台的限制，往往会需要采取一些近似手段，从而导致失真。比如，在计算机平台上，计算出来的无限小数不能表示。\n3. 解释树搜索和图搜索原理，并对比分析二者的不同 树搜索基本步骤：\n初始化：将初始节点加入待扩展节点集合（通常是一个栈或队列）。 节点选择：从待扩展节点集合中选择一个节点进行扩展。 节点扩展：生成当前节点的所有子节点，并将这些子节点加入待扩展节点集合。 目标检测：检查生成的子节点是否为目标节点。如果是，则搜索成功；否则，继续扩展。 重复：重复步骤2-4，直到找到目标节点或待扩展节点集合为空。 图搜索基本步骤：\n初始化：将初始节点加入待扩展节点集合（通常是一个优先队列）和已访问节点集合。 节点选择：从待扩展节点集合中选择一个节点进行扩展。 节点扩展：生成当前节点的所有子节点，并检查这些子节点是否已经存在于已访问节点集合中。 节 …","date":"2025-01-14 08:52:25","updated":"2025-01-14 19:52:25"},{"objectID":"bfa5bdad4f36aea3ed1d4b69431d0de726149c25","permalink":"/post/source-code-reading-project-checkkerneleathook/","title":"源代码阅读项目——CheckKernelEATHook","content":"ciyze0101/Windows-Rootkits\n项目概况 +---CheckKernelHook | | CheckKernelHook.sln | | | \\---CheckKernelHook | | AddService.cpp | | AddService.h | | CheckKernelHook.aps | | CheckKernelHook.cpp | | CheckKernelHook.h | | CheckKernelHook.rc | | CheckKernelHook.vcxproj | | CheckKernelHook.vcxproj.filters | | CheckKernelHookDlg.cpp | | CheckKernelHookDlg.h | | resource.h | | stdafx.cpp | | stdafx.h | | targetver.h | | tempCodeRunnerFile.cpp | | | \\---res | CheckKernelHook.ico | CheckKernelHook.rc2 | ReadMe.txt | \\---CheckKernelHookDrv | CheckKernelHook.sln | \\---CheckKernelHook CheckKernelHook.vcxproj CheckKernelHook.vcxproj.filters Common.c Common.h DriverEntry.c DriverEntry.h FileSystem.c FileSystem.h FixRelocation.c FixRelocation.h KernelHookCheck.c KernelHookCheck.h KernelReload.c KernelReload.h libdasm.c libdasm.h ReadMe.txt Reload.c Reload.h sources tables.h 该项目是一个用于检测和管理Windows内核钩子（Kernel Hooks）的应用程序，主要包括用户界面部分和内核驱动部分。\n用户界面部分（User Interface） 1. CheckKernelHook 应用程序 功能：提供一个图形用户界面，用于检测和显示内核钩子 …","date":"2025-01-08 08:52:25","updated":"2025-01-08 19:52:25"},{"objectID":"d45b385d0a556d99838ca790139c447461c46f69","permalink":"/post/end-4/","title":"END - 4","content":" 我发现我常常在年度报告出来后这段时间开始疯狂听歌。\nまたおいで真是每一次听都觉得有一种美到窒息的感觉。\n去年写的东西：satori5ama.github.io/posts/the-end-of-2023/\n而如今的我，甚至不愿意对来年写下一句祝福。这并非是因为偏执，虽然我自觉多少已经出现了一些偏执的症状。\n只是因为我意识到我所能诉说的一切，都是如此苍白无力。\n无论是祝福，祈愿，还是承诺。\n其实并没有改变什么，世界就是这样一个周而复始的循环。变化的只有我的心，在疯狂地旋转舞蹈中逐渐破碎。\n那也没什么好在乎的，本来就是破碎的东西也不在意破碎的尺度。\n这样的一天唯一的意义，就是让我将那所剩无几的自己彻底拆碎。没有其他原因，只是这副身躯本来就要散架了。\n我真的累了，我连这句话也不想再说了。\n也许痛苦的不仅仅是看到了终点，也是看不清终点前的路还有多远。\n如果对岸的幸福只是美丽的倒影呢？我们还有必要存在吗？如果把自己的存在寄托于这样的事物上，那如泡沫般的色彩能够承载这样沉重的存在吗？\n我回答不了这样的问题啊。\n就算再怎样否定自己存在的意义，明天还是会这样过下去。这值得被称作勇气吗，或是浑浑噩噩的活下去本就是一种懦弱？\n我没有学会爱，\n可是我学会了恨。\n我不再辨明对错，\n我只在乎感受。\n其实我并非喜欢孤独，我只是想要逃离人群。\n其实我不愿逃离人群，我只是想要感受到爱。\n我想起5年前的自己在日记本里写着孤独，4年前的自己写着想要被理解。是不是其实这样的词汇，和想要被爱，并没有什么分别呢？也许是这样的欲望被隐藏在词句中，连自己都没有意识到。\n缺失的是什么，渴望的又是什么，我想真的不重要了。欲望不是一件应该深入思考的事情。\n欲望只需要感受。\n只不过即使知晓了自己的欲望是什么也无济于事，不值得被爱的存在本就没有资格祈求。\n我仅仅会在夜半的时分伫立，注视着空无一物的黑色夜幕，只是为了不再思考。\n在这样的时刻，会被偶然刷到的美到极致的歌惊艳到落泪，那也算一种幸福吧。\n不要在意话语中的意思啊，就当这是一次修辞实验罢了。\n语言的东西，本来就不需要分辨真假啊。\n","date":"2025-01-01 21:24:02","updated":"2025-01-01 21:24:02"},{"objectID":"256f832d6ffd4bd5048cc9329ce2e84f2a5ce747","permalink":"/post/xctf-i-am-not-a-virus/","title":"XCTF - 我不是病毒2.0","content":"复现完以为自己写了wp，结果好像没有。只能转一篇了。\n2023XCTF-Final - Eutop1a\n","date":"2024-12-23 08:55:27","updated":"2024-12-23 08:55:27"},{"objectID":"1a09f86274f100674270b72cb39e7cd82dfb7c87","permalink":"/post/martian-language-conversion-script/","title":"随手写的英文火星文生成器","content":"写了个英文火星文转换脚本，用来生成flag\ndef replace_letters(input_str): replacement = \u0026#34;48(d3f9h!jk1mn0pqr57uvwxy2\u0026#34; input_str = input_str.lower() result = \u0026#34;\u0026#34; for char in input_str: if \u0026#39;a\u0026#39; \u0026lt;= char \u0026lt;= \u0026#39;z\u0026#39;: index = ord(char) - ord(\u0026#39;a\u0026#39;) result += replacement[index] else: result += char return result if __name__ == \u0026#34;__main__\u0026#34;: input_string = input(\u0026#34;请输入字符串: \u0026#34;) output_string = replace_letters(input_string) print(f\u0026#34;转换后的字符串: {output_string}\u0026#34;) 又水了一期博客，你有这时间怎么不多复现几个样本\n","date":"2024-12-19 09:06:54","updated":"2024-12-19 09:06:54"},{"objectID":"0760c55d5c34ba3532c04000f1dc915be4a6689f","permalink":"/post/end-3/","title":"END - 3","content":"其实渐渐地我会发现，我如此轻易地感到悲伤，并不源于我的生活是多么悲惨。只是我会随时随地，毫无来由地悲伤而已。\n或者说，我早已习惯了痛苦终会到来。\n所以在幕布拉开的瞬间我便看到了谢幕，在宴席欢聚的时刻我就会想起散场。因为梦的泡沫终会破碎，那翩翩飞舞的样子多么绚丽斑斓，消逝的瞬间就有多么幻灭。\n预料到故事的结局，却没有勇气去直面它。\n我像那个因无法等待把所有糖果一把吃掉的孩子一样，竭力从当下的时间中榨取最后一丝快乐。因为我对未来没有期待，蛋糕不过是一个谎言，许诺也只剩下废纸一张。\n我像那等待审判的犯人一般听从命运的发落，仿佛它早已扼住我的咽喉，下一秒所有的一切就会被夺走。\n或许强者可以奋起搏击命运，可以笑对挫折与磨难。\n可是我感到好累。\n我多么渴望能够就此长眠，不必睁开眼迎接黎明未现时的蒙蒙薄雾。可不幸的是我无法入睡，我不得不像被天敌盯着的猎物一般弓起身子，保持着异常的敏锐和警醒。那是根植于生命中的本能，至少它证明了一点：我从未相信过我所处的环境是安全的。\n而这样做是有代价的，那就是我越来越疲倦，怀疑，无法忍耐那看不到希望的明天。\n结束吧，我呼喊着。我无数次试图松开攥紧的拳头，想要张开双臂让荆棘就这样刺穿我的胸膛，然后将我渐渐冰冷的躯体抛入望不见底的深渊中，在下坠的途中最后一次仰望辽阔的天空，触摸从掌心处流过的风。\n那对我来说不过是一种解脱。\n可是我终究没有这么做。\n只是因为我忽然感到莫名的委屈，只是我突然间想起，其实我并没有罪。我不应该站在这里接受这一场判决，即使我懒惰，自私，优柔寡断又自以为是，那并不是我被判决成一个坏人的理由。\n如果说这个世界上真的有人该死的话，我想该死的另有其人。\n所以当我看到我所熟知的一切正在崩溃却毫无知觉，看着世界在分崩离析的道路上猛踩油门，内心却没有一丝波澜。\n早就应该毁灭了，这畸形的古木，扭曲的高塔和锈蚀的巨轮，这样的事物还能保持其重心而存在的每一天都令我感到不可思议。我会目睹这宏伟结构的坍塌，就像当初一切爱、美与信仰是如何在其手中消逝的那样，它也终将迎来这样的命运。\n这是报应，在所有能被解构的事物都被解构完毕后，解构的对象终究会落回解构者身上。\n而我既不会去捍卫那已经腐朽到即将倒塌的观念，也懒得去加入那解构大军的乌合之众。\n我会把自己锁在小小的房间里，怀念着记忆里仅有的闪烁片段，为自己已经失去的一切痛哭一场，然后在冰冷的夜里用被子裹住自己的身体，继续做着那从未触摸过的梦。\n","date":"2024-12-11 00:25:02","updated":"2024-12-11 00:25:02"},{"objectID":"0c9bef5912446d310d00878ae74ebf9b6b027c5c","permalink":"/post/end-2/","title":"END - 2","content":" 我逐渐明白的是，从某一个时刻开始，我再也没有办法掌握事情的走向，问题的关键，和自己的命运。\n而我的存在，早已融入了统计图表中那些混沌无序的熵流之中。\n很多时候我会感到自己回到了孩提时候，那种弱小而无助的感觉。\n无法抑制的疲惫，不知不觉地发呆，以及听着歌会不知不觉地睡去。\n我不太清楚为什么，现在听着音乐就很容易睡着，而且是很深的如同大脑被耗干之后的那种睡眠。\n也许我真的太累了……\n但是又能怎么样呢？我知道这种疲惫是无法以休息来恢复的，只会让我更加眷恋这种休息的感觉。\n那不是短暂的消耗，那是源头的枯竭，是我的生命早已没有了信仰，是我对生活的一切都感到厌恶，尤其是对自己。\n然后在一面自我厌恶的同时触发自我保护机制，再次麻痹自己的感知。\n所以我想要停下来，我的生活需要一个断点。不是为了整理过去，也不是为了规划未来。\n就像当我走在路上时突然停下脚步，毫无征兆地崩溃大哭，然后把自己拆解成一块块碎片，再慢慢地组装回来。\n至于拼好后的自己是不是有着明显的裂缝，那已经不是我能在意的东西了。\n而我的不幸是，作为一个苦涩的失败主义者，却恰好是一个理想主义者。\n那注定了所有的理想只不过是为了逃离当下的幻觉而已。\n可就算无法实现，却也放弃不了那份向往。明明知道幸运不过是生命里的随机而已，却依然等待着云开雾散的一天。\n即使所做的一切不过是等待，某种意义上，也是为理想而活着吧。\n","date":"2024-11-24 15:25:02","updated":"2024-11-24 15:25:02"},{"objectID":"e7010abc29f4aafd03d8963fc23564db6880ae08","permalink":"/post/adworld-re150/","title":"攻防世界 - Re150","content":"参考文献：攻防世界-Re150 - lrhtony 的小站\n查壳略。\nIDA打开，发现没有main函数，只有一个start函数。\nstart函数的汇编代码：\n.eh_frame:080488D4 start proc near ; DATA XREF: LOAD:08048018↑o .eh_frame:080488D4 ; start+22↓o .eh_frame:080488D4 jmp short loc_80488EB .eh_frame:080488D4 ; --------------------------------------------------------------------------- .eh_frame:080488D6 db 20h ; address 0x08048320 .eh_frame:080488D7 db 83h .eh_frame:080488D8 db 4 .eh_frame:080488D9 db 8 .eh_frame:080488DA db 20h .eh_frame:080488DB db 83h .eh_frame:080488DC db 4 .eh_frame:080488DD db 8 .eh_frame:080488DE db 32h .eh_frame:080488DF db 4 .eh_frame:080488E0 db 0 .eh_frame:080488E1 db 0 .eh_frame:080488E2 db 73h ; s .eh_frame:080488E3 db 79h ; y .eh_frame:080488E4 db 63h .eh_frame:080488E5 db 6Ch ; l .eh_frame:080488E6 db 6Fh ; o .eh_frame:080488E7 db 76h ; v .eh_frame:080488E8 db 65h .eh_frame:080488E9 db 72h ; r .eh_frame:080488EA db 0Ah .eh_frame:080488EB ; --------------------------------------------------------------------------- …","date":"2024-11-21 08:55:27","updated":"2024-11-21 08:55:27"},{"objectID":"ab9c84d41ce3671571013ec01a07283280d79343","permalink":"/post/suctf2019-hardcpp/","title":"SUCTF2019 - hardCpp","content":"参考文献：去OLLVM平坦化([SUCTF2019]hardCPP) - Pinguw\u0026amp;rsquo;s Blog\n查壳，ELF64，无壳\nIDA中发现有多层while嵌套，内部有一个switch控制分发，观察程序流程图发现明显的平坦化痕迹。\n于是先采用脚本去平坦化。\n安装angr。\npip install angr 下载deflat脚本https://github.com/Pure-T/deflat。\n运行\npython deflat.py hardCpp 0x4007E0 #python + deflat.py + 文件名 + 起始地址(基本就是main函数的地址) 运行结果，去平坦化成功。（过程中Warning没有关系）\n将hardCpp_recovered拖进IDA分析，\n首先判断main开头的一段程序基本都是无效代码，将输入字符串重命名为input，后文有用到的两个变量重命名为i，j。另外在读入字符串前先读入了一个字符 s ，这个s的地址其实是input-1,是真实输入的字符串的开头，我们重命名为input_0。\n这里要特别注意去平坦化后大量出现的((x - 1) * x) \u0026amp;amp; 1的语句，因为相邻两个正整数的乘积为偶数，所以这样的语句结果恒为0。\n然后进入循环，程序中形如main::$_1::operator() const(char)::{lambda(int)#1}::operator()(v16, 7LL)的大量函数，是c++11中的lambda表达式，\n参考：深入浅出 C++ Lambda表达式：语法、特点和应用_c++ lambda函数作为函数参数 - CSDN博客\n其实就是一种匿名函数，可以和正常函数一样分析。\n在子函数中，依然存在未去平坦化的代码，因此我们将deflat起始地址设在每个子函数中再做一遍deflat。\npython deflat.py hardCpp_recovered 0x401310 python deflat.py hardCpp_recovered_recovered 0x4016C0 python deflat.py hardCpp_recovered_recovered_recovered 0x4014E0 去平坦化后，我们分析子函数，以main::$_0::operator() …","date":"2024-11-18 08:55:27","updated":"2024-11-18 08:55:27"},{"objectID":"09309bbee7f47a358ae49cb5201709dfaa9db361","permalink":"/post/ring-theory-and-its-applications-in-cryptography/","title":"[Crypto]环域理论及密码应用","content":" 1. 环的定义 定义15.1.1 设$G$是一个非空集合，$\\cdot$是$G$上的一个代数运算，如果该运算满足结合律: $\\forall a, b, c \\in G$, $(a \\cdot b) \\cdot c = a \\cdot (b \\cdot c)$，则称 $(G, \\cdot)$ 为一个半群 (Semigroup)\n例1 $$\\left(Z_n, \\otimes\\right) \\text{是半群。}$$ 例2 整数集合 $Z$关于乘法运算构成半群。\n定义15.1.2 设 $R$ 是一个非空集合，如果在 $R$ 中定义了两个代数运算 $+$ 和 $\\cdot$，并且两个代数运算满足：\n(1) $(R, +)$ 为一个交换群；\n(2) $(R, \\cdot)$ 为一个半群；\n(3) 对任意 $x, y, z \\in R$，双边分配律成立\n$$\\begin{align*} \u0026amp; x \\cdot (y + z) = x \\cdot y + x \\cdot z \\\\ \u0026amp; (y + z) \\cdot x = y \\cdot x + z \\cdot x \\end{align*}$$则称 $(R, +, \\cdot)$ 为一个环 (Ring)。\n注：为了方便起见，通常记 $xy = x \\cdot y$​\n环中加法单位元称为零元，通常记为 $0$；环中元素 $a$ 关于加法逆元记为 $-a$，一般记 $a - b = a + (-b)$。 环包含的元素个数称为环的阶。 环关于乘法可能没有单位元，如全体偶数构成环，如果环关于乘法有单位元，则就称为环的单位元，通常记为 $1$。环中元素 $a$ 关于乘法逆元如果存在，记为 $a^{-1}$​。 例1 整数环 $(Z, +, \\times)$，有理数环 $(Q, +, \\times)$，实数环 $(R, +, \\times)$，复数环 $(C, +, \\times)$。\n例2 实数域 $R$ 上 $n$ 阶方阵环 $\\left(R^{n\\times n}, +, \\times\\right)$\n例3 模 $n$ 的剩余类环：$\\left(Z_n, \\oplus, \\otimes\\right)$\n例4 整数集 $Z$ 对如下运算构成环 $(Z, \\odot, \\circ)$\n$$ a \\odot b = a + b - 1; …","date":"2024-11-18 07:55:27","updated":"2024-11-18 07:55:27"},{"objectID":"f08a7c380197660ea834828bf41cfba9e152c862","permalink":"/post/adworld-maze/","title":"攻防世界 - maze","content":"查壳，64位elf，无壳。\n进入main函数。\n伪代码：\n__int64 __fastcall main(int a1, char **a2, char **a3) { __int64 v3; // rbx int v4; // eax bool v5; // bp bool v6; // al const char *v7; // rdi int v9; // [rsp+0h] [rbp-28h] BYREF int v10[9]; // [rsp+4h] [rbp-24h] BYREF v10[0] = 0; v9 = 0; puts(\u0026#34;Input flag:\u0026#34;); scanf(\u0026#34;%s\u0026#34;, \u0026amp;s1); if ( strlen(\u0026amp;s1) != 24 || strncmp(\u0026amp;s1, \u0026#34;nctf{\u0026#34;, 5uLL) || *(\u0026amp;byte_6010BF + 24) != 125 ) { LABEL_22: puts(\u0026#34;Wrong flag!\u0026#34;); exit(-1); } v3 = 5LL; if ( strlen(\u0026amp;s1) - 1 \u0026gt; 5 ) { while ( 1 ) { v4 = *(\u0026amp;s1 + v3); v5 = 0; if ( v4 \u0026gt; 78 ) { if ( (unsigned __int8)v4 == 79 ) { v6 = sub_400650(v10); goto LABEL_14; } if ( (unsigned __int8)v4 == 111 ) { v6 = sub_400660(v10); goto LABEL_14; } } else { if ( (unsigned __int8)v4 == 46 ) { v6 = sub_400670(\u0026amp;v9); goto LABEL_14; } if ( (unsigned __int8)v4 == 48 ) { v6 = sub_400680(\u0026amp;v9); LABEL_14: v5 = v6; } } if ( !(unsigned __int8)sub_400690((__int64)asc_601060, v10[0], v9) ) goto LABEL_22; if ( ++v3 \u0026gt;= strlen(\u0026amp;s1) - 1 ) { if ( v5 ) break; LABEL_20: v7 = \u0026#34;Wrong flag!\u0026#34;; goto LABEL_21; } } } if ( asc_601060[8 * v9 + v10[0]] != 35 ) goto LABEL_20; v7 = \u0026#34;Congratulations!\u0026#34;; LABEL_21: puts(v7); return 0LL; } 观察第一段，可以发现flag形式为nctf{开头，长度为24，结尾为}的字符串。\n继续阅读，发现程序遍历了字符串{}以内的内容，且当当前位置为O，o，.，0时进入不同的子程序。而当循环结束，最后一次执行子程序返回值不为0时正常跳出循环，否则报错。\n然后是四个操作子函数的内容。\nsub_400650是自减v10，返回值判断v10是否大于0。\nsub_400660是自增v10，返回值判断v10是否小于8\nsub_406670和sub_406680和上面两个函数是相同的，只是操作数变成了v9。\n对于sub_400690，我们阅读子程序\n发现其效果时判断asc_601060[8*v9+v10]是否等于空格或#号，若均不是则报错。\n循环外的这段代码判断asc_601060[8*v9+v10]是否等于#号，若不是则报错\n因此，在循环过程中 $8 * v9 + v10$ 的所有合法取值为$0,1,9,10,11,13,14,19,21,26,27,29,33,34,36,37,38,42,46,50,51,52,53,54$，而最终要求$8*v9+v10 == 36$，且约束$0","date":"2024-11-12 08:55:27","updated":"2024-11-12 08:55:27"},{"objectID":"8fdc7aafeb859e86a741538c71afbc42e818b1ee","permalink":"/post/end/","title":"END","content":"我曾经不明白自己为什么如此偏好“结束”这样一个词，或许是最近才意识到，\n那只是因为我根本看不到希望。\n我已经有很长一段时间不去思考对与错的问题了，因为只要我一对这个问题进行审视，就会发现，所有人都是对的，只有我是错的。\n我明明知道做什么样的事情才是对的，什么样的事情对我才是有好处的，我应该怎样去提高自己的能力，怎样去准备自己的未来。\n可是我做不到。\n所有的痛苦都指向自己的短视、懒惰、贪玩和傲慢，\n于是我在这个痛苦的循环中渐渐沉溺。\n我不知道该把自己的心寄托在什么身上，因为我不记得自己喜欢什么，哪怕记得也没什么用。我只知道我现在所做的一切都不曾让我感受到快乐。\n这样的生命会有未来吗？倘若是结果能够带来快乐的话，即使提升能力的过程再艰辛，或许也能够承受。可无论做什么事都不可能感受到幸福，又怎么会有提升自我的动力呢？眼看着自己一天天为了各种事情而忙碌却毫无进步，是一种令人窒息的绝望。\n做着自己不喜欢的事的未来，是我恐惧而拼命抗拒的，可是自己真正喜欢过投入过做什么事情吗？也许曾经有过，但是在各种不可抗力的影响下没有办法真正投入，从而渐渐淡忘了吧。所以自己做事一直缺乏内驱力，所有的动力都来自不得不做的恐惧。\n我没有理想，没有计划。没有理想是害怕着期待落空、梦想破碎的那一刻，没有计划是永远会有预料之外的事情将一切全部打乱。每一天醒来唯一在意的是如何等待着太阳落下的时刻。\n我有一个最简单的梦，那就是不必再思考。因为我厌恶了绞尽脑汁却无计可施的感觉。\n如果说我的生命有一个主题，那就是逃避。\n我有太多的事情要去逃避，逃避痛苦，逃避他人的目光，逃避明天太阳的升起。我试图将自己像鸵鸟一样把脑袋蜷缩在沙子里，直到看不见外面的世界，才会感到安全。\n我多么希望自己从此可以什么都不在意，心安理得而毫无畏惧地浪费生命，可是我做不到，我依旧感到痛苦，为自己的碌碌无为而感到痛苦，为自己的灰暗未来不停担忧。\n那是一种天然的孱弱感，是面对痛苦时的茫然与渺小。于是我一直在那条匆忙逃离与狂奔的路上。\n然后在每个夜深人静的夜晚，在情绪地衬托下回忆过去每个孤独的时刻，让这种寂灭的抽离拉扯出心脏疼痛时，还可以赋予自己一些心安理得。\n其实没有人会分不清痛苦与快乐的，在可以选择的情况下，我想诸位更乐意沉溺于新鲜的生活，夺目的爱情，以及喧笑的童年。\n那样的人生看起来一马平川且幸福至极。\n但这是不可能的，我们作为个体的无能 …","date":"2024-11-10 15:25:02","updated":"2024-11-10 15:25:02"},{"objectID":"a3cfad54f29399c96a8df9877067d02df05a2982","permalink":"/post/template-collection/","title":"板子合集（自用）","content":" 计算几何 线段平行 设线段端点分别为$P_1,P_2$和$P_3,P_4$\n则\n$$\\overrightarrow{P_1 P_2} \\times \\overrightarrow{P_3 P_4} = 0$$ 线段共线 设线段端点分别为$P_1,P_2$和$P_3,P_4$\n则\n$$\\overrightarrow{P_1 P_2} \\times \\overrightarrow{P_2 P_3} = 0$$ $$\\overrightarrow{P_1 P_2} \\times \\overrightarrow{P_2 P_4} = 0$$ 判断一个点在线段的哪边 假设有向线段为$\\overrightarrow{AB}$ ，点为$C$，首先计算外积$\\overrightarrow{AC} × \\overrightarrow{AB}=( \\overrightarrow{AC}_{x} ⋅\\overrightarrow{AB}_{y}-\\overrightarrow{AC}_{y} ⋅\\overrightarrow{AB}_{x})\\overrightarrow{k}$（因为有$\\overrightarrow{AB}_{z}=0$，$\\overrightarrow{AB}_{z}=0$）。根据右手螺旋定则，如果$\\overrightarrow{k}$的系数为正数，说明点$C$在线段$AB$的右侧；如果为负数，说明点$C$在线段$AB$的左侧；如果为0，说明点$C$在线段$AB$所在的直线上。\n//************************************************************************* // \\brief: 计算两个向量的外积（叉乘）。可以根据结果的符号判断三个点的位置关系。 // \\Param: Point A 两个向量的公共起点。 // \\Param: Point B 第一个向量的终点。 // \\Param: Point C 第二个向量的终点。 // \\Returns: double 向量AC与向量AB的外积。 //如果结果为正数，表明点C在直线AB（直线方向为从A到B）的右侧； //如果结果为负数，表明点C在直线AB（直线方向为从A到B）的左侧； //如果结果为0，表明点C在直线AB上。 …","date":"2024-10-25 08:52:25","updated":"2024-10-25 19:33:25"},{"objectID":"6e1d53364a5f56bf2b121e8751a81bcd9eb26cb5","permalink":"/post/note-os-31-semaphore/","title":"重生之我学操作系统——第31章 信号量","content":" 回顾： 临界段问题\n在并发程序中，资源是共享的 临界段资源：部分资源需要互斥使用 利用“锁”的思想保护临界段资源 并发的需求\n互斥执行、同步执行 一、信号量的定义 控制并发的信号灯-信号量(semaphore)\n信号量是有一个整数值的对象 信号量可以代替锁/条件变量 信号量可以并发过程中控制资源的使用情况 信号量是包含一个整数值的对象。\n我们可以用sem_wait()和sem_post()来操作 信号量的初始值决定其行为，因此需要初始化 例：初始化为1，第二个参数0标识信号量是线程共享的 #include \u0026amp;lt;semaphore.h\u0026amp;gt; sem_t s; sem_init(\u0026amp;amp;s, 0, 1); // initialize s to the value 1 sem_wait()：又称为P()操作\n信号量的值减1 结果如果小于0，则使调用的线程挂起直到被其他线程调用 sem_post()唤醒 int sem_wait(sem_t *s) { decrement the value of semaphore s by one; wait if value of semaphore s is negative } sem_post()：又称为V()操作\n将信号量的值加1 如果有其他线程等待被唤醒，则唤醒其中一个 二、二值信号量(锁) 用信号量作为锁\n将临界区环绕 sem_t m; sem_init(\u0026amp;amp;m, 0, X); // initialize semaphore to X; what should X be? sem_wait(\u0026amp;amp;m); //critical section here sem_post(\u0026amp;amp;m); X = 1\n三、信号量作为条件变量 一个线程等待条件成立，另一个线程修改条件并发信号\n用信号量值的变化作为状态改变信号 #include \u0026amp;lt;stdio.h\u0026amp;gt; #include \u0026amp;lt;pthread.h\u0026amp;gt; #include \u0026amp;lt;semaphore.h\u0026amp;gt; sem_t s; // 定义信号量 void *child(void *arg) { printf(\u0026amp;#34;child\\n\u0026amp;#34;); sem_post(\u0026amp;amp;s); // signal here: child is done …","date":"2024-10-22 14:55:27","updated":"2024-10-22 14:55:27"},{"objectID":"d8e246fc4eec2a7cba6af95c6e85c3f0c58fbadf","permalink":"/post/order-of-an-integer-and-primitive-root/","title":"[Crypto]整数的阶和原根","content":" 你说的对，但是感觉不如原根。原根，是一个数学符号。设m是正整数，a是整数，若a模m的阶等于φ(m)，则称a为模m的一个原根。假设一个数g是P的原根，那么g^imodP的结果两两不同，且有1\u0026amp;lt;g\u0026amp;lt;P，0\u0026amp;lt;i\u0026amp;lt;P，归根到底就是g^(P-1)=1(modP)当且仅当指数为P-1的时候成立。(这里P是素数)。你的数学很差，我现在每天用原根都能做1e5次数据规模1e6的NTT，每个月差不多3e6次卷积，也就是现实生活中3e18次乘法运算，换算过来最少也要算1000年。虽然我只有14岁，但是已经超越了中国绝大多数人(包括你)的水平，这便是原根给我的资本\n因为ppt没发，所以以下内容部分参考自oiwiki\n整数的阶 由欧拉定理可知，对 $a \\in \\mathbb{Z}, m \\in \\mathbb{N}^*, $ 若 $(a, m) = 1$，则 $a^{\\varphi(m)} \\equiv 1 \\ (\\text{mod} \\ m)$。 因此满足同余式 $a^n \\equiv 1 \\ (\\text{mod} \\ m)$ 的最小正整数 $n$ 存在，这个 $n$ 称作 $a$ 模 $m$ 的阶，记作 $\\delta_m(a)$ 或 $\\text{ord}_m(a)$。\n性质 $a, a^2, \\cdots, a^{\\delta_m(a)}$ 模 $m$ 两两不同余。 设 $m \\in \\mathbb{N}^*, a, b \\in \\mathbb{Z}, (a, m) = (b, m) = 1$，则 $\\delta_m(ab) = \\delta_m(a) \\delta_m(b)$ 的充要条件是 $( \\delta_m(a), \\delta_m(b) ) = 1$ 若 $a^n \\equiv 1 \\ (\\text{mod} \\ m)$，则 $\\delta_m(a) \\mid n$。特别地，有$\\delta_m(a) | \\varphi(m)$ 设 $k \\in \\mathbb{N}, m \\in \\mathbb{N}^*, (a, m) = 1$，则 $\\delta_m(a^k) = \\frac{\\delta_m(a)} {(\\delta_m(a), k)}$​。 若$n|m$，则$\\delta_n(a)|\\delta_m(a)$。 设$m = …","date":"2024-10-21 07:55:27","updated":"2024-10-21 07:55:27"},{"objectID":"885b3d0e4ac64bbb58a7e54e48f8b97d0cd154b2","permalink":"/post/goodbye-acm/","title":"提前写下的告别","content":"我知道那一天终究会到来，只是没想到会这么快。\n有些事情还是提前写出来的好，等到真的结束的那一天，又有谁会想起来呢？\n其实在进到大学之前，我所在的专业就让我放弃了对OI的念想。只不过机缘巧合，我还是在ACM保留了两年的念想。\n该结束了，我疲惫了。\n想写这篇文章只是因为我突然意识到一件事，那就是我在这条路上注定是没有希望的那一批人。\n我没有抽不出一个完整的时间去写完一场模拟赛，也抽不出一点细碎的时间去做一次赛后的总结，我甚至没有完整的改过任何一场的题。\n我很清楚，从踏进大学的那一刻起我的实力注定只有倒退一途。\n因为有太多没有意义的事情占据了我的生命的绝大多数时间，试图将我塑造成某些人想要看到的模样，塑造成一个完美的人，听话的人，各方面的都足够优秀的人。\n这很正常，毕竟自由在我们的生命里本就是一种幻想。\n只不过这样的结果就是塑造出了我这个什么也不突出的人。而这样的我还需要花上一大把的时间去调整自己的心情，努力让自己的精神能维持在一个能正常思考的范围。\n而这样的生命里其他的事情何尝不是这样呢？那无休止的接连而来的事务带给我的感受不是知识和经验积蓄，而是一种消耗，对生命的消耗。\n我什么都没有获得，我只是在用自己的一切去应付这样的生活，等待着夜晚到来陷入沉睡，厌恶太阳的每一次升起。\n所以有时候我甚至很庆幸自己被“抛弃”了，因为我知道我根本没有办法跟上队友的脚步，去追逐那闪烁着耀眼光芒的梦想。\n那很美丽，我知道，就像每日从路旁经过，那墙角生长的野蔷薇。\n只是我早已被那锋利的刺戳穿了心脏。\n月华斑驳映窗前， 岁月如流匆匆前。\n昔时攀峰求一笑， 今朝独坐叹星迁。\n墨下吟诗徒自伤， 胸中豪气化云烟。\n往事飘渺随风去， 浮生空余泪涟涟。\n千帆过尽难回首， 月影随风梦渐远。\n一曲离歌心已逝， 孤灯夜照更添寒。\n漫卷浮云随意散， 残烛微芒影成双。\n春秋几度无所获， 惆怅唯余伴清霜。\n","date":"2024-10-17 15:25:02","updated":"2024-10-17 15:25:02"},{"objectID":"1feb1f95f61ea5b8acc57cbec712beb1eeceb62b","permalink":"/post/group-theory/","title":"[Crypto]群理论","content":" 一、 代数运算 定义12.1 设 $M$ 是一个非空集合，如果存在一个对应规则 $f$，使得对 $M$ 中任意两个元素 $a$ 和 $b$ ，在 $M$ 中都有唯一确定的元素 $c$ 与它们对应，则称 $f$ 为 $M$ 上的一个代数运算(二元运算)，记作 $c=f(a,b)$ 或简记为$c=a·b$ .（封闭性）\n判断集合 $M$ 上运算的封闭性 如果封闭：\n证明对于所有 $a, b \\in M$，运算结果 $a \\cdot b \\in M$。 如果不封闭：\n找到特定的元素 $a, b \\in M$，使得 $a \\cdot b \\notin M$。 常见基本代数运算 自然数集 $N$ 上的加法、乘法运算； 整数集 $Z$ 上的加法、减法与乘法运算； 有理数集 $Q$ 上的加法、减法和乘法运算； 非零有理数集 $Q^*$ 上的乘法与除法运算； 有理数、实数上全体 $n$ 阶方阵的加法与乘法运算； 有理数、实数上全体 $n$ 阶可逆方阵的乘法运算。 定义 12.2 设 $n$ 是大于 1 的任意正整数，集合 $Z_n$ 定义为：\n$$ Z_n = \\{0, 1, 2, \\ldots, n-1\\} $$ 集合 $Z_n$ 中如下两种运算为代数运算： 模 $n$ 的加法：$a \\oplus b = a + b \\mod n$ 模 $n$ 的乘法：$a \\otimes b = a \\times b \\mod n$ 二、 群的定义 定义 12.3 设 $G$ 是一个非空集合，$\\cdot$ 是 $G$ 上的一个代数运算（即满足封闭性），如果该运算满足以下三条性质：\n结合律：对于所有 $a, b, c \\in G$，有 $(a \\cdot b) \\cdot c = a \\cdot (b \\cdot c)$。 有单位元：存在 $e \\in G$，对于所有 $a \\in G$，有 $e \\cdot a = a$。 有逆元：对于所有 $a \\in G$，存在 $a\u0026#39; \\in G$，使得 $a \\cdot a\u0026#39; = a\u0026#39; \\cdot a = e$。 则称 $(G , \\cdot)$ 为一个群（Group）。\n注：在群只有一个运算时可简称 $G$ 为一个群。\n常见群的例子 例1：整数加群，有理数加群，实数加群。 例2：非零有理数关于乘法构成群，非零实数关于乘法构成群。 例3：整数、有理 …","date":"2024-10-14 07:55:27","updated":"2024-10-14 07:55:27"},{"objectID":"7f9ef2d753c6aa46c6c185a8163894c663ee6eee","permalink":"/post/note-os-30-conditional-variable/","title":"重生之我学操作系统——第30章 条件变量","content":" park()可以让调用线程休眠 unpark(tid)可以唤醒tid标识的线程 setpark()可以使线程从park直接返回（其他线程调用unpark后） Linux系统里提供futex实现类似机制 为什么我们需要条件变量 void* child(void* arg){ printf(\u0026#34;child\\n\u0026#34;); // XXX how to indicate we are done? return NULL; } int main(int argc, char* argv[]){ printf(\u0026#34;parent: begin\\n\u0026#34;); pthread_t c; pthread_create(\u0026amp;c, NULL, child, NULL); // create child // xxx how to wait for child? printf(\u0026#34;parent: end\\n\u0026#34;); return 0; } 一种低效的实现 volatile int done = 0; void* child(void* arg){ printf(\u0026#34;child\\n\u0026#34;); done = 1; return NULL; } int main(int argc, char* argv[]){ printf(\u0026#34;parent: begin\\n\u0026#34;); pthread_t c; pthread_create(\u0026amp;c, NULL, child, NULL); // create child while(done == 0) ; // spin printf(\u0026#34;parent: end\\n\u0026#34;); return 0; } 目的:判断A是否执行完，A执行完后B才能执行\n有什么优化方案？\n尝试：引入条件变量 存在问题：线程2执行完第一行后，时间片耗尽，转而先执行线程1的unpark（此时没有休眠线程可以释放），回到线程2后park进入休眠无法释放。\n一个简单规则：发送信号时记得加锁\n问题：执行线程2的park后，锁没有unlock，陷入死锁\n问题：线程2执行完第4行unlock后，可能时间片耗尽跳转到线程1先执行unpark（此时没有休眠线程可以释放），回到线程2后park进入休眠无法释放。\n条件变量类型：抽象 事件类型：抽象 条件变量 是一个显示队列，根据某些特定条件(condition)决定线程行为 等待条件：当条件不满足时，线程加入队列（休眠） 发出信号：对于其他线程，当改变状态（使条件满足时），可以在队列中唤醒线程 “条件变量”小结 条件变量可以处理线程的等待和唤醒 在条件变量上等待的线程，会在休眠前解锁，被唤醒后立刻加锁 通过条件变量可以实现事件类型，描述事件发生与否 如何用条件变量解决实际问题? ","date":"2024-10-08 17:55:27","updated":"2024-10-08 16:55:27"},{"objectID":"c2bca33e13938ff3153322e02e2c798c7985cd55","permalink":"/post/note-os-29-lock-based-concurrent-data-structures/","title":"重生之我学操作系统——第29章 基于锁的并发数据结构","content":" 一、并发计数器 一个简单的计数器 typedef struct counter_t{ int value; } counter_t; void init(counter_t* c){ c-\u0026gt;value = 0; } void increment(counter_t* c){ c-\u0026gt;value++; } void decrement(counter_t* c){ c-\u0026gt;value--; } int get(counter_t* c){ int rc = c-\u0026gt;value; return rc; } 哪些地方需要加锁?\n一种加锁方法：（全局都加上锁）\ntypedef struct counter_t{ int value; pthread_mutex_t lock; } counter_t; void init(counter_t* c){ c-\u0026gt;value = 0; pthread_mutex_init(\u0026amp;c-\u0026gt;lock, NULL); } void increment(counter_t* c){ pthread_mutex_lock(\u0026amp;c-\u0026gt;lock); c-\u0026gt;value++; pthread_mutex_unlock(\u0026amp;c-\u0026gt;lock); } void decrement(counter_t* c){ pthread_mutex_lock(\u0026amp;c-\u0026gt;lock); c-\u0026gt;value--; pthread_mutex_unlock(\u0026amp;c-\u0026gt;lock); } int get(counter_t* c){ pthread_mutex_lock(\u0026amp;c-\u0026gt;lock); int rc = c-\u0026gt;value; pthread_mutex_unlock(\u0026amp;c-\u0026gt;lock); return rc; } 问题:扩展性差\n当线程数量变多,性能下降明显\n违背了并发的初衷!\n可扩展的计数:懒惰计数器(sloppy counter) 一个全局计数器和多个局部计数器(每个CPU核一个)\n如何实现计数?如何加锁?\n一个全局计数器和多个局部计数器(每个CPU核一个)\n一个全局锁(用来保护全局计数器)\n每个局部计数器一个锁(用来保护局部计数器)\n局部计数器的值会定期转移到全局计数器\n取决于阈值S(sloppiness)\ntypedef struct __counter_t { int global; // global count pthread_mutex_t glock; // global lock int local[NUMCPUS]; // local count (per CPU) pthread_mutex_t lock[NUMCPUS]; // ... and locks int threshold; // update frequency } counter_t; 阈值S调节了计数器的准确性和性能 S越大，可扩展性越强 S越小，全局计数器越精确 权衡是0S设计中经典的主题。\n二、并发链表 typedef struct node_t{ int key; struct node_t* next; } node_t; typedef struct list_t{ node_t* head; pthread_mutex_t lock; } list_t; void ListInit(list_t* L){ L-\u0026gt;head = NULL; pthread_mutex_init(\u0026amp;L-\u0026gt;lock, NULL); } int List_Insert(list_t* L, int key){ pthread_mutex_lock(\u0026amp;L-\u0026gt;lock); node_t* new = malloc(sizeof(node_t)); if(new == NULL){ perror(\u0026#34;malloc\u0026#34;); pthread_mutex_unlock(\u0026amp;L-\u0026gt;lock); return -1; /* fail */ } new-\u0026gt;key = key; new-\u0026gt;next = L-\u0026gt;head; L-\u0026gt;head = new; pthread_mutex_unlock(\u0026amp;L-\u0026gt;lock); return 0; /* success */ } int List_Lookup(list_t *L, int key) { pthread_mutex_lock(\u0026amp;L-\u0026gt;lock); node_t *curr = L-\u0026gt;head; while (curr) { if (curr-\u0026gt;key == key) { pthread_mutex_unlock(\u0026amp;L-\u0026gt;lock); return 0; // success } curr = curr-\u0026gt;next; } pthread_mutex_unlock(\u0026amp;L-\u0026gt;lock); return -1; // failure } 并发链表：改进\nvoid List_Insert(list_t* L, int key){ node_t* new = malloc(sizeof(node_t)); if(new == NULL){ perror(\u0026#34;malloc\u0026#34;); return; } new-\u0026gt;key = key; // just lock critical section pthread_mutex_lock(\u0026amp;L-\u0026gt;lock); new-\u0026gt;next = L-\u0026gt;head; L-\u0026gt;head = new; pthread_mutex_unlock(\u0026amp;L-\u0026gt;lock); } 三、并发队列 Michael and Scott 并发队列 队列的头部有一把锁（保护出队列操作） 队列的尾部有一把锁（保护入队列操作） 添加了一个假节点 在队列初始化代码里分配，该节点分开了头和尾操作 队列在多线程程序中被广泛使用\ntypedef struct __node_t { int value; struct __node_t *next; } node_t; typedef struct __queue_t { node_t *head; node_t *tail; pthread_mutex_t headLock; pthread_mutex_t tailLock; } queue_t; void Queue_Init(queue_t *q) { node_t *tmp = malloc(sizeof(node_t)); tmp-\u0026gt;next = NULL; q-\u0026gt;head = q-\u0026gt;tail = tmp; pthread_mutex_init(\u0026amp;q-\u0026gt;headLock, NULL); pthread_mutex_init(\u0026amp;q-\u0026gt;tailLock, NULL); } void Queue_Enqueue(queue_t *q, int value) { node_t *tmp = malloc(sizeof(node_t)); assert(tmp != NULL); tmp-\u0026gt;value = value; tmp-\u0026gt;next = NULL; pthread_mutex_lock(\u0026amp;q-\u0026gt;tailLock); q-\u0026gt;tail-\u0026gt;next = tmp;\t// 新节点放在尾部 q-\u0026gt;tail = tmp; pthread_mutex_unlock(\u0026amp;q-\u0026gt;tailLock); } int Queue_Dequeue(queue_t *q, int *value) { pthread_mutex_lock(\u0026amp;q-\u0026gt;headLock); node_t *tmp = q-\u0026gt;head; node_t *newHead = tmp-\u0026gt;next; if (newHead == NULL) { pthread_mutex_unlock(\u0026amp;q-\u0026gt;headLock); return -1; // queue was empty } *value = newHead-\u0026gt;value; // 取走的是head指向 的第2个节点内容 q-\u0026gt;head = newHead; pthread_mutex_unlock(\u0026amp;q-\u0026gt;headLock); free(tmp); return 0; } 四、并发散列表(Hash Table) #define BUCKETS (101) typedef struct __hash_t { list_t lists[BUCKETS]; } hash_t; void Hash_Init(hash_t *H) { int i; for (i = 0; i \u0026lt; BUCKETS; i++) { List_Init(\u0026amp;H-\u0026gt;lists[i]); } } int Hash_Insert(hash_t *H, int key) { int bucket = key % BUCKETS; return List_Insert(\u0026amp;H-\u0026gt;lists[bucket], key); } int Hash_Lookup(hash_t *H, int key) { int bucket = key % BUCKETS; return List_Lookup(\u0026amp;H-\u0026gt;lists[bucket], key); } 每个线程分别执行10000-50000次并发更新\n简单的并发散列表，扩展性极好。\n","date":"2024-10-08 16:55:27","updated":"2024-10-08 16:55:27"},{"objectID":"8c982faa0f0523a0d0692bb687a14bd139ca3ca1","permalink":"/post/rsa-analysis/","title":"[Crypto]基于大数分解的RSA分析","content":"密码课乱写的笔记。\n1. Fermat 方法(|p-q|较小) 由\n$$ \\frac{(p + q)^2}{4} - n = \\frac{(p - q)^2}{4} - pq $$如果 $|p - q|$ 小，则\n$$ \\frac{(p - q)^2}{4} \\text{也小，因此} \\frac{(p + q)^2}{4} \\text{稍大于} n, \\frac{(p + q)}{2}\\text{稍大于} \\sqrt{n} $$可得 $n$ 的如下分解步骤：\n顺序检查大于 $\\sqrt{n}$ 的每一整数 $x$，直到找到一个 $x$ 使得 $x^2 - n$ 是某一整数（记为 $y$）的平方。 由 $x^2 - n = y^2$，得 $n = (x + y)(x - y)$。 def fermat_factorization(N, e, ciphertext): a = math.isqrt(N) + 1 b2 = a * a - N while not is_perfect_square(b2): a += 1 b2 = a * a - N b = math.isqrt(b2) p = a - b q = a + b return p, q 2. Pollard rho 方法 分解质因数 - OI Wiki (oi-wiki.org)\n采用了生日攻击的原理：即在随机选择 $p^{1/2}$ 个数里面，大概率（约 40%）会有两个数的差是 $p$ 的倍数。\n这是一种随机化算法。假设要找的因子为 $p$，随机取 $x_1$，由 $x_n$ 构造 $x_{n+1} = f(x_n) = x_n^2 + a$，使得 $p$ 整除 $x_n - x_{n+1}$ 且 $x_n - x_{n+1}$ 不能整除 $n$，则有：\n$$ p = \\gcd(x_n, x_{n+1}, n) $$# 代码基于oi-wiki的Pollard-Rho算法的Python实现，稍作修改 from random import randint from math import gcd def f(x,c,n): return (x*x+c)%n def Pollard_Rho(x): c = randint(1, x - 1) s = t = f(0, c, x) goal = val = 1 …","date":"2024-10-08 07:55:27","updated":"2024-10-08 07:55:27"},{"objectID":"732ae498eaaf16129cb2f4fa9ed342730089a4cc","permalink":"/post/note-os-28-lock/","title":"重生之我学操作系统——第28章 锁","content":" 一、锁的基本思想 通过加锁来保证临界区的原子性 lock_t mutex; ... lock(\u0026amp;amp;mutex);\t// 获取锁，如果已被占用， 则等待，直到获得锁为止 balance = balance + 1; unlock(\u0026amp;amp;mutex); // 释放锁 如何评价锁的实现 有效性：只有一个线程能拿到锁 公平性：所有线程都有机会拿到锁 不会出现饿死情况 性能：时间开销小 锁的实现一般要使用某种特 殊硬件指令，但也可以不用\n锁的实现：用中断屏蔽指令（例如x86的CLI） 只适用于单处理器系统 需要在内核态运行（开关中断是特权指令） 需要运行所有线程执行特权操作 影响对中断的及时响应 void lock() { DisableInterrupts(); } void unlock() { EnableInterrupts(); } 二、自旋锁 通过忙等待(Busy Waiting)的方式不断检查锁的状态 通过循环(自旋)实现 typedef struct __lock_t { int flag; } lock_t; void init(lock_t *mutex) { // 0 → lock is available, 1 → held mutex-\u0026amp;gt;flag = 0; } void lock(lock_t *mutex) { while (mutex-\u0026amp;gt;flag == 1) // TEST the flag ; // spin-wait (do nothing) mutex-\u0026amp;gt;flag = 1; // now SET it ! } void unlock(lock_t *mutex) { mutex-\u0026amp;gt;flag = 0; } typedef struct __lock_t { int flag; } lock_t; void init(lock_t *mutex) { // 0 → lock is available, 1 → held mutex-\u0026amp;gt;flag = 0; } void lock(lock_t *mutex) { L0: if (mutex-\u0026amp;gt;flag == 1) // TEST the flag goto L0; // spin-wait (do nothing) mutex-\u0026amp;gt;flag = …","date":"2024-10-07 16:55:27","updated":"2024-10-08 23:00:27"},{"objectID":"fabe28155ffd8c4d8eaa89a4b3acb98cd30348cb","permalink":"/post/note-os-26-27-concurrency-and-thread-api/","title":"重生之我学操作系统——第26、27章 并发、线程API","content":" 问题：进程并发 // ... existing code ... int sum1 = 0, sum2 = 0; void p1() { int i, tmp = 0; for (i = 1; i \u0026amp;lt;= 100; i++) tmp += i; sum1 += tmp; } void p2() { int i, tmp = 0; for (i = 101; i \u0026amp;lt;= 200; i++) tmp += i; sum2 += tmp; } void p3() { printf(\u0026amp;#34;sum: %d\\n\u0026amp;#34;, sum1 + sum2); } int main() { pid_t pid; int stat; pid = fork(); if (pid == 0) { p1(); exit(0); } p2(); pid = wait(\u0026amp;amp;stat); p3(); return 0; } 预期结果：20100 实际结果：10500 问题原因： 在 main() 函数中，fork() 创建了一个子进程。子进程执行 p1()，而父进程执行 p2()。 子进程中的 sum1 的值不会被父进程所看到，因为每个进程都有自己的内存空间。 因此，父进程中的 sum1 仍然是 0，而 sum2 是 15050（从 101 到 200 的和）。 一. 并发基本概念 1. 并发的概念 并发意味着多个计算任务在同一时间段发生 指在同一时间段内，多个任务在操作系统中交替执行。实际上，这些任务并不是真正同时执行，而是通过OS调度，快速地在多个任务之间切换，从而给用户一种多个任务同时进行的假象。 任务存在可并发成分 Parbegin S1； S2； Parend S3； Dijkstra提出并行语句： Parbegin S1；S2； … Sn； Parend；\n多进程实现并发 Parbegin S1； S2； Parend S3； pid = fork(); if (pid == 0) { S1; // 子进程执行的代码 exit(0); } S2; // 父进程执行的代码 wait(\u0026amp;amp;status); // 等待子进程结束 S3; // 子进程结束后执行的代码 多进程实现并发有什么缺陷？\n进程间通信（IPC）通常比线程间通信更复杂。进程之间不能直接共享内存，需要使 …","date":"2024-09-24 16:55:27","updated":"2024-09-24 16:55:27"},{"objectID":"0ce053141ad8c072b1f7a4e8a701804c849ea50f","permalink":"/post/note-os-21-22-beyond-physical-memory/","title":"重生之我学操作系统——第21、22章 超越物理内存","content":" 问题：放宽假设 当虚拟地址空间大于物理内存大小时，如何超越物理内存进行存储？\n一、“虚拟内存” 1. 基本原理 OS的存储是分层级(hierarchy)的 越上层的存储越快 越底层的存储空间越大 time-space trade-off OS利用大而慢的设备，透明的提供巨大虚拟地址空间的假象\n解决方案：用外存(硬盘)模拟内存，达到扩大内存的效果 2. 交换空间(swap space) 在硬盘上开辟一部分空间用于物理页的移入和移出 交换空间以页为单位进行组织 3. 实现机制 一般寻址流程\n页表项新增存在位(present bit)\nValue Meaning 1 page is present in physical memory 0 The page is not in memory but rather on disk. （前提：有效位为1） 当页表不存在内存中， 则引发页错误，陷入内核。\n回顾：页表项\n页错误的触发与处理 页表项用于记录在外存的位置信息\n如果内存满了怎么办(没有空闲页帧了)？\n换出(page out)一些内存中的页面，称为页淘汰 较差的页面替换策略可能导致程序运行慢10000~100000倍 页淘汰 页错误的处理： PFN = FindFreePhysicalPage(); if (PFN == -1) // no free page found PFN = EvictPage(); // run replacement algorithm DiskRead(PTE.DiskAddr, PFN); // sleep (waiting for I/O) PTE.present = True; // update page table with present PTE.PFN = PFN; // bit and translation (PFN) RetryInstruction(); // retry instruction 进行页面交换的真实时机 OS不会等到内存真正全部用完，而会主动调控 交换守护进程/页守护进程 设置高水位线(High Watermark, HW)和低水位线(Low Watermark, LW) 当内存低于LW，则开始淘汰(evict)页面直到达到HW “虚拟内存”小结 基本原理 用外存模拟内存 实现机制 存在位，页错误 页 …","date":"2024-09-23 16:55:27","updated":"2024-09-23 16:55:27"},{"objectID":"a3f8de1cec223cd88a89161c86688daaa74cd0eb","permalink":"/post/note-os-20-reduce-the-page-table-size/","title":"重生之我学操作系统——第二十章 使页表变小","content":" 问题：页表很大 32位地址空间(4GB)，带有4KB的页：20位的VPN，12位的offset 单个页表大小： $4 MB= 2^{20} entries * 4 Bytes$ 方案1：采用更大的页 32位地址空间(4GB)，带有16KB的页 单个页表大小 $=\\frac{2^{32}}{2^{14}} *4 B = 1 MB$ 问题：线性页表 为一个进程的整个地址空间提供一个线性页表 大量页表项是无效的！ 方案2：段页式地址转换(混合方法) 为每个段分配一个页表\n假设有3个段，每个进程有3个页表(段页表)，4GB地址空间，4KB的页面，地址该如何表示？\nSN = (VirtualAddress \u0026amp; SEG_MASK) \u0026gt;\u0026gt; SN_SHIFT VPN = (VirtualAddress \u0026amp; VPN_MASK) \u0026gt;\u0026gt; VPN_SHIFT AddressOfPTE = Base[SN] + (VPN * sizeof(PTE)) 问题：段页式地址转换(混合方法) 混合方法在特定情况下表现仍然不好 分段本质上不够灵活，假定地址空间有使用模式 如果有一个大而稀疏的堆，仍然导致页表的浪费 这种混合仍然可能导致外部碎片的出现 页表现在可以是任意大小 方案3：多级页表(multi-level PT) 页表的本质是数据结构 除开线性页表，我们还可以利用什么数据结构？ 以树的形式组织页表 将页表分成许多单元，每个单元为1个页大小 如果一个单元中所有页表项都无效， 则不分配该单元所需内存 引入页目录(page directory) 目的是追踪页表的页是否有效，以及它在内存中的位置 目的是追踪页表的页是否有效，以及它在内存中的位置 或者告知页表的整个页不包含有效页 每个页目录项(PDE)描述一个二级页表 包含一个有效位和页帧号 页目录索引 PDI (page directory index) 页表索引PTI (page table index) VPN = (VirtualAddress \u0026amp; VPN_MASK) \u0026gt;\u0026gt; SHIFT (Success, TlbEntry) = TLB_Lookup(VPN) if (Success == True): # TLB Hit if (CanAccess(TlbEntry.ProtectBits) == True): Offset = VirtualAddress \u0026amp; OFFSET_MASK PhysAddr = (TlbEntry.PFN \u0026lt;\u0026lt; SHIFT) | Offset Register = AccessMemory(PhysAddr) else: RaiseException(PROTECTION_FAULT) else: # perform the full multi-level lookup PDIndex = (VPN \u0026amp; PD_MASK) \u0026gt;\u0026gt; PD_SHIFT PDEAddr = PDBR + (PDIndex * sizeof(PDE)) PDE = AccessMemory(PDEAddr) if (PDE.Valid == False): RaiseException(SEGMENTATION_FAULT) else: # PDE is Valid: now fetch PTE from PT PTIndex = (VPN \u0026amp; PT_MASK) \u0026gt;\u0026gt; PT_SHIFT PTEAddr = (PDE.PFN \u0026lt;\u0026lt; SHIFT) + (PTIndex * sizeof(PTE)) PTE = AccessMemory(PTEAddr) if (PTE.Valid == False): RaiseException(SEGMENTATION_FAULT) else if (CanAccess(PTE.ProtectBits) == False): RaiseException(PROTECTION_FAULT) else: TLB_Insert(VPN, PTE.PFN, PTE.ProtectBits) RetryInstruction() eg：采用线性页表时，计算需要多少页来存储页表？\nAns：16\n采用二级页表时，地址如何表示？\n地址空间：16KB，页大小：64B 每个二级页表/页目录包含16个表项(每个占4B) 方案3：更多级的页表 二级页表有时候可能不满足需求（需要更深的树结构）\neg：\n其他方案：反向页表 思考一下普通页表的转换方式 VPN -\u0026gt; PFN 每个进程一个页表 如果从物理页帧出发，反向记录 PFN -\u0026gt; PID、VPN 所有进程共用 “使页表变小”小结 线性页表的问题：页表太大，耗费内存 方法1：采用更大的页 方法2：段页式地址转换 方法3：多级页表 方法4：反向页表 优缺点分别是什么？ 页面是不是一定能放入内存？\n","date":"2024-09-22 16:55:27","updated":"2024-09-22 16:55:27"},{"objectID":"03aa14b276596a0eb257b0826907809cf3f90867","permalink":"/post/note-os-1819-paging-and-fast-address-translation/","title":"重生之我学操作系统——第十八、十九章 分页、快速地址转换(TLB)","content":" 一、“分页”地址转换 1. 分页基本原理 分页(paging)是将地址空间划分成固定大小的分片单元， 称为页/页面(page)\n相对应的，物理内存同样也要分为相同大小的单元， 叫做页帧(page frame)\n页表是每个进程一个(per process)的数据结构 示例中的页表有四个条目： VP0-\u0026amp;gt;PF3, VP1-\u0026amp;gt;PF7, VP2-\u0026amp;gt;PF5, VP3-\u0026amp;gt;PF2 假设虚拟地址空间是64字节，页大小为16字节(有4页) 虚拟地址为6位，可以分为两个部分 虚拟页号(VPN)：virtual page number 页内偏移(Offset)：offset within the page 虚拟地址“21”的转换过程 eg：按照上图页表，虚拟地址“50”转换为物理地址是 34 2. 页表的存放位置 问题：页表可能很大 32位地址空间(4GB)，带有4KB的页：20位的VPN，12位的offset 单个页表大小： $4 MB= 2^{20} entries * 4 Bytes$ 页表存在内存里 通过页表基址寄存器(PTBR)在内存中找到页表的位置 3. 页表内容 页表就是一种数据结构 最简单的形式：线性页表，就是一个数组 OS通过虚拟页号(VPN)检索数组，并在该索引处查找页表项(PTE)，进 一步找到物理页帧号(PFN) 有效位(Valid Bit): 表明特定地址转换是否有效 保护位(Protection Bit): 表明页的权限(读，写，执行) 存在位(Present Bit): 表明该页是在内存里还是磁盘上 脏位(Dirty Bit): 表明页面进入内存后是否修改过 参考位/访问位(Reference Bit): 表明追踪页是否被访问 示例：x86页表项\n4. 访存示例 例1 movl 21,%eax 地址转换过程：\n// Extract the VPN from the virtual address VPN = (VirtualAddress \u0026amp;amp; VPN_MASK) \u0026amp;gt;\u0026amp;gt; SHIFT // Form the address of the page-table entry (PTE) PTEAddr = PTBR + (VPN * sizeof(PTE)) // Fetch the PTE PTE = …","date":"2024-09-17 16:55:27","updated":"2024-09-17 16:55:27"},{"objectID":"269b69c7e7c43bfb56b797a5b281bfd65050ffb5","permalink":"/post/note-os-1617-segmentation-free-space-management/","title":"重生之我学操作系统——第十六、十七章 分段、空闲空间管理","content":"多图警告。\n上一章空间管理的问题 大量的空闲(free)空间 - 这些空闲空间实实在在的占用了物理内存 必须为进程的整个虚拟地址空间分配 连续的物理内存 - 会导致什么问题？ 一、“分段”地址转换 1. 基本原理 段是虚拟地址空间中的一个连续片段 代码段、栈段、堆段 对于每个段来说，都有它的基址和界限 只需以段为单位，给进程分配连续物理内存 物理地址 = 段基址 + 段内偏移 （段内偏移≠虚拟地址） 粗粒度和细粒度的分段 粗粒度：只支持少量 段，如code、heap、 stack 细粒度：支持很多段， 需要硬件支持段表 如何判定非法内存访问？ 硬件在地址转换时检查 如果超出了界限，则会报段错误 (segmentation fault) 陷入内核… 2. 段的表示：显式、隐式 (1) 显式方法：用虚拟地址的高位表示 // get top 2 bits of 14-bit VA Segment = (VirtualAddress \u0026amp; SEG_MASK) \u0026gt;\u0026gt; SEG_SHIFT Offset = VirtualAddress \u0026amp; OFFSET_MASK if (Offset \u0026gt;= Bounds[Segment]) RaiseException(PROTECTION_FAULT) else PhysAddr = Base[Segment] + Offset //在CPU中将多组基址和界限放到寄存器数组中 (2) 隐式方法：不放在虚拟地址中 根据当前指令类型决定使用 哪个段寄存器\n对于栈是否有什么特殊性？ 栈是反向增长的，需要额外的硬件支持 3. 段的共享与保护 有些时候需要在地址空间里共享(share)内存段 为了节省内存，例如代码共享 需要硬件提供支持：段的保护位(Protection bits) 4. OS需要处理相关事项 上下文切换时：所有的段寄存器都要保存和恢复 案例：现在有24KB空闲空间， 如何为一个20KB的段分配空间？ 需要应对外部碎片(external fragmentation) 空闲的、难以使用的小内存块 产生原因：段内连续，段长可变 紧致化处理(compaction) 对段进行重排 停止进程的运行 拷贝数据 修改段寄存器的值 有效，但是代价高 二、空闲空间管理 1. 底层机制 分割(splitting)：将一个空闲块分割成两块，其中一块给用户 合并(coalescing)：将相邻的两个空闲块合为一块 当一个新空闲块进入队列时，如何高效地进行合并操作？ free(void *ptr)接口并没有要释放的块大小的参数 记录已分配块的大小 头块中包含分配空间的大小 也可能包含额外的指针加速释放、magic number用来检查完整性 建立空闲块列表: 列表节点 堆的初始化：假设使用mmap() 案例：通过调用ptr = malloc(100)申请内存 分配3块内存后 释放1块内存后 假设归还的空闲块被插 入到列表的头位置，那 么next指向什么地址？ 答：16708\n释放3块内存后 目前的内存空间合理吗？\n2. 空闲内存分配策略 评价指标：速度快，碎片少，分配成功率高 假设现在需要大小15的内存块\nhead -\u0026gt; 10 -\u0026gt; 30 -\u0026gt; 20 -\u0026gt; NULL\n3. 其他方式 ","date":"2024-09-12 16:55:27","updated":"2024-09-12 16:55:27"},{"objectID":"ca99970524109bfcb40b51ff1bdbb952e6cc6f77","permalink":"/post/note-os-78-process-scheduling/","title":"重生之我学操作系统——第七、八章 进程调度","content":" 进程调度的概念 内核决定将CPU分配给某个就绪进程的过程 选择一个就绪的进程 调度指标 调度算法（策略） 进程切换 进程执行现场的切换（回顾进程） 一、进程调度的时机 非抢占式/协作式(Non-preemptive) 当一个进程从运行态切换到阻塞态（例如 发生I/O请求） 当一个进程终止 抢占式(Preemptive) 当一个进程从运行态切换到就绪态（例如 出现时钟中断） 当一个进程从阻塞态切换到就绪态（例如 I/O完成） 非抢占式情况下必须等待进程完成再考虑下一 步调度，抢占式可以在进程执行时切换进\n二、进程调度的指标 CPU利用率（CPU utilization） $\\uparrow$ ，使CPU尽可能忙碌（0%-100%） 吞吐量（throughput） $\\uparrow$ ，单位时间内进程完成的数量 周转时间（turnaround time） $\\downarrow$，进程就绪到进程完成的时间 $T_{周转} = T_{完成} – T_{到达}$ 周转时间强调的是性能（performance） ，除此之外，还有一个很重要的指标：公平 响应时间 $\\downarrow$，交互式任务中，响应用户操作的时间 $T_{响应} = T_{首次运行}– T_{到达}$ … 工作负载假设 完全可操作的调度准则： 假设1.所有的任务运行相同的时间 假设2. 所有的任务同时到达 假设3. 一旦开始，所有任务保持运行直到完成 假设4. 所有的任务只使用CPU（不考虑I/O） 假设5. 每个工作的运行时间是已知的 三、进程调度的经典策略 先到先得（FCFS: First Come First Served） 按照进程就绪的先后次序调度（非抢占式） 优点：最“简单直接”的策略，易于实现（FIFO队列） 弊端：混合任务场景下对短任务不友好，不适合交互环境 最短任务优先（SJF: Shorted Job First） 先运行最短的任务，然后是次短的，以此类推（非抢占式） 优点：避免出现护航效应，可以缩短平均周转时间 弊端：效率依赖任务到达（进程就绪）时间 最短完成时间优先（STCF:Shortest Time-to-Complete First） 用抢占式的调度思想，当有新进程就绪时，确定正在运行任务 和新任务谁的完成剩余时间少，并进行调度 弊端：部分任务对响应时间非常敏感，快速响 …","date":"2024-09-03 16:55:27","updated":"2024-09-03 16:55:27"},{"objectID":"8f5f8d14cb93dd829007170002e51b1f94a33a8c","permalink":"/post/note-os-131415-address-translation/","title":"重生之我学操作系统——第十三、十四、十五章 地址转换","content":" 一、进程的地址空间 OS提供了一个物理内存的抽象:地址空间 包含运行程序的所有内存状态 代码:存储指令 栈(向上增长):局部变量、函数参数、返回值等 堆(向下增长):动态分配的内存:malloc、new 程序并不是真正存储在物理地址的0-16KB的地方\n进程看到的都是虚拟地址\n二、内存相关API 显式的申请内存:malloc() void* malloc(size_t size) 在堆上申请内存空间 size参数为申请空间的大小（byte） 成功则返回指向分配内存的指针，失败则返回空指针 释放内存:free() void free(void* ptr) 释放调用malloc分配的内存 参数为调用malloc返回的指针（释放内存大小不是用户决定） int *pi; //local variable pi = (int *)malloc(sizeof(int) * 4) free(pi) 可能错误：\n没有申请足够的内存：导致缓冲区溢出(buffer overflow) 忘记初始化分配的内存：导致读取未知数据 忘记释放内存：导致内存泄露(memory leak) 在用完之前释放内存：导致悬挂指针(dangling pointer) 错误的调用free：导致无效释放(invalid free) 其他申请内存API：calloc() void *calloc(size_t num, size_t size) 在堆上申请内存空间，并且将其置0 可以防止忘记初始化分配的内存 其他申请内存API：realloc() void *realloc(void *ptr, size_t size) 可以增大分配内存空间（当需要添加一些信息） 参数ptr传入由malloc, calloc或者realloc分配的内存块指针 参数size表示新的内存大小 返回值可能与ptr相同，也可能不同 相关系统调用：brk，sbrk，mmap 三、“基址+界限”地址转换 如何实现高效、灵活的内存虚拟化？ 如何提供应用程序所需的灵活性？ 如何保持控制应用程序可访问的内存位置？ 如何高效的实现这些？ 高效和控制是现代操作系统的两个主要目标， 分别对应性能和可靠性\n基于硬件的地址转换（受限直接访问）\n硬件对内存访问进行处理 （高效） 将指令中的虚拟地址(virtual address)转换为实际内存的物理地址 …","date":"2024-09-03 16:55:27","updated":"2024-09-03 16:55:27"},{"objectID":"e4c82b3822520820e15869af47a37f0d4b992b4a","permalink":"/post/note-os-2-overview/","title":"重生之我学操作系统——第二章 操作系统概述","content":"\n","date":"2024-09-01 16:55:27","updated":"2024-09-01 16:55:27"},{"objectID":"0399ef65f444ab401d552de3c86440a9f424a2b1","permalink":"/post/note-os-6-limited-direct-execution/","title":"重生之我学操作系统——第六章 受限直接执行","content":" 第六章 受限直接执行 如何高效、可控地虚拟化CPU？\n一、受限直接执行 进程的运行 用户运行程序时，OS创建一个进程 OS每次选择一个进程在CPU上运行一段时间 OS将CPU时分共享给多个进程 基本方案：直接在CPU上运行程序 问题一：用户可能无意/有意地写出“错误”的程序 int *i; i=0;*i=1; 问题二：OS如何拿回CPU的控制权？ int i=-1; while(i\u0026amp;lt;0) do sth; 如果进程希望做一些受限制的操作怎么办？ 申请一次对磁盘的I/O操作 想要获取更多的系统资源 \u0026amp;ndash;\u0026amp;gt; 采用受保护的控制权转移\n用户模式（用户态）：Application不能访问所有Hardware资源 内核模式（内核态）：OS可以访问机器的所有资源 二、中断和异常 中断和异常是事件（Event） 当OS启动后，所有对内核的访问都是由于事件导致的 内核为不同事件定义不同的处理程序 事件发生后，转换为内核态，并调用处理程序 CPU如何应对事件 控制权交给处理程序 控制程序保存程序状态，执行内核功能，回复程序状态，继续执行 OS面对事件的处理流程 什么是中断?（eg:I/O终端，时钟中断） CPU收到的一种来自外部设备或软件指令的控制信号 中断是异步的(与CPU当前指令无关) 一般可以屏蔽 什么是异常?（eg:除零错，算术溢出） 异常是CPU在执行指令时内部产生的一种信号，通常意味着某种意外事情的发生(也成为内中断) 异常是同步的，不可屏蔽 中断向量表 中断向量表：一片存放中断处理程序入口地址的内存单元\n中断向量在内存中连续存放，起始地址一般记录在某特定寄存器 硬件按中断号的不同通过中断向量表跳转到相应处理程序中 中断向量一般由操作系统初始化程序(在内核态)进行设置 中断和异常：处理过程 保存恢复点位置，切换到内核态，查中断向量表跳转到中断处理程序(由CPU硬件完成) 执行中断处理程序 执行中断返回指令:跳转到恢复点，同时切换回原特权级 中断和异常:处理过程(risc-v) 将断点位置存入sepc;切换到S模式;设置寄存器scause为中断号;跳转到寄存器stvec 根据scause执行对应的处理程序 执行sret指令:跳转到sepc，同时切换回U模式 三、系统调用 系统调用允许内核小心地向用户程序暴露某些关键功能\n访问文件系统 创建/销毁进程 分配 …","date":"2024-08-27 16:55:27","updated":"2024-08-27 16:55:27"},{"objectID":"e26029458b2547f440deb452339c8a6dfb882377","permalink":"/post/note-os-45-process/","title":"重生之我学操作系统——第四、五章 进程","content":" 第四、五章 进程 CPU虚拟化的产物：进程（process）\nOS重要思想：资源共享思想\n时分共享：每次由一个实体使用一小段时间（one at a time），典型应用是进程共享CPU。 空分共享 : 每个实体同时使用一小部分资源（all a little） 一、进程的概念 进程是操作系统对运行程序的抽象。 当用户运行程序时，操作系统创建一个进程 操作系统每次选择一个进程在CPU上运行一段时间 操作系统将CPU时分共享给多个进程 特点： 时分共享，虚拟化 提供假象 一个进程等待时另一个进程做事（Overlap） （多）进程的引入：优点 提升系统资源利用率，减小延迟 提升系统可靠性 简化编程模型 二、进程的创建 将程序的代码和静态数据加载到进程的内存地址空间。\n惰性执行：仅当代码片段或数据需要使用时才进行加载 为程序的运行时栈分配内存\n为程序的堆分配内存\nOS执行一些其他初始化任务\n运行程序\n进程以进程号PID唯一标识 查看进程信息：\n$ ps -a //查看运行的进程 $ ps -aux|grep PID //查看进程号为PID的进程详细信息 $ kill PID //杀死PID进程 三、进程的状态 初始态 运行态 就绪态 阻塞态 终止态 进程控制块 进程控制块（PCB）：OS控制进程运行的数据结构\n进程标识信息：PID等 执行现场信息：CPU现场 进程映像信息：进程的地址空间 进程资源信息：文件、信号、共享内存、消息队列、通讯端口等 其他信息 四、进程的API fork() UNIX系统中，用fork()创建进程\n在一个运行的进程（父进程）中创建新的进程 子进程得到父进程的资源拷贝，指令相同（子进程从 fork() 处继续执行） 父子进程PID不同 fork() 后父子进程由独立的地址空间 父子进程的 fork() 返回值不同（以此进行区分），父进程返回值是子进程的PID，子进程中返回值是0 仅用 fork() 创建进程有什么问题：父子进程的运行顺序/时间有差异，导致不确定性。\nwait() wait用于等待任一子进程结束。\n返回值：\n如果成功，返回结束的子进程PID 如果有错误， 返回-1 int wc = wait(NULL)\nexec() 将当前进程印象替换成新的程序文件并执行 从可执行文件中加载代码和静态数据，覆盖自己的代码和静态数据，堆、栈也会被重新初始化 exec()成功调用不会返回 在子进程中调用exec()，从而执行与父进程不同的程序 为什么要这样设计 fork()大大简化了新进程初始化的工作 fork()可以更好帮助子进程使用父进程的数据 fork() ，wait()，exec()的完美结合，千变万化 ","date":"2024-08-22 16:55:27","updated":"2024-08-22 16:55:27"},{"objectID":"1a84d1a400f5a19f7badd2cfc4e587116b0c1581","permalink":"/post/how-to-assess-zhu-ci/","title":"锐评——如何评价朱慈","content":" 一句话，如果今天我想卸载知乎，能让我犹豫的绝对不是这个问题下回答的诸位，而是朱慈，这就足够了。\n看到一个问题。\n如何评价朱慈，愚者，李拐儿，白纸? - 知乎\n坦白说，我是极端讨厌写这种观点性的文章的。因为我觉得说服别人属实是一件吃力不讨好且没有意义的事情，纯粹就是浪费时间。我一向笃信的是拳头才能使人信服（当然实际操作中需要灵活调整）。所以我一般只输出观点，甚至懒得表达观点。\n但是有些评论我看着真的有点恼火。有时候我写议论性文章不是为了说服什么，纯粹是厌蠢症犯了。可能是项目的原因，我最近厌蠢症发作的非常厉害，一个简单到极致的道理居然一群人看不明白总会让我气的吐血（尤其是在你对接项目的时候）。我懒得参与无谓的争论，所以我在自己博客里隔空输出观点。\n大家知道我曾经在博文里大量引用朱慈的文章。我对朱慈的态度很简单：\n我喜欢他的文章，其他的我一律不想管。\n诸位了解我的都清楚，虽然我不擅长写作，但是我对于文学作品的要求极其苛刻，我对自身的文学素养水平是相当自负的。而朱慈的文章能够吸引我已经足以证明其在文字修辞组织方面的天赋。我自愧没有这样的天赋，一度想要模仿却无法得到其神采。能将文字玩弄的如此轻松，我不得不佩服。\n然后是他文章中的思想。我觉得他的文字能够如此地直击心灵，根本原因还不是他文辞的绚丽，而是他对人的心理尤其是阴暗面深入的剖析。我知道朱慈可能不算什么正统心理学（他自己应该也说过），但是无所谓，对我一个理科生来说根本无所谓什么权威，我只跟着感觉走。\n我印象很深的是他最近回答的那个问题：“什么是生理性喜欢？”\n他的回答第一句话很简短：\n“是吃掉。”\n那一刻我背后起了鸡皮疙瘩，不是害怕，而是震惊于他对这种感觉的描述是如此精准，把深埋在心底不可能描述得出来的东西就这样暴露在所有人面前。\n我并不清楚他所叙述的故事是真是假，很有可能那只是编造出来的故事。但是虚构不正是小说的创作手法吗？能够将这样的技能运用到极致，不也是一种足以令我佩服的能力吗？\n我十分清楚认识到的一点是，所谓“朱慈”只是一个人设而已。想要从网络上寻求真实是一件愚蠢到令人发笑的事情。我一直把他的文章当作小说在读，把他本人当作小说的角色。可谁说小说不能摄人心魄？虚构的文字能拥有比真实更为强大的力量。\n有人拿他的人品问题去抨击他，在我看来这对我读不读他的文章没有任何关系。倘若他有罪，就让法律去制裁他，只可惜我至今没有看 …","date":"2024-08-10 16:27:27","updated":"2024-08-10 16:27:27"},{"objectID":"7468a68fde195d37decd8fcb3ee904f6b9b8688c","permalink":"/post/distort/","title":"梦呓（十一）—— 扭曲","content":"ハシヒメ - Re：Volte\n四年前。\n洛谷上的一个求助帖子让我关注了这件事情。\n如何看待山东一成年公民疑似被亲属雇佣「假警察」强制送到戒网瘾机构，进行非法拘禁和强制「医疗」？ - 知乎\n我曾经怀着朴素的善意关注了这个事情的全程，那时的我坚信人有自由的权利，有选择自己道路的权利。我甚至激愤地写了一篇时评在课堂上分享，只是为了对这所谓机构，父母进行抨击。\n然后就是搜救没有下落，不断的限流，整件事情石沉大海，悄无声息。\n那时我所猜测的，无非是Good ending，或是Bad ending。\n可我宁愿整件事情就这样结束，即使一年后当我有时点回这个话题下，看到沉寂的页面时，依旧感到深深的无力感。\n但是这件事终究有了结局，可是这结局却出乎我所有的意料。\n曾经被送进去的孩子出来后，将另一个14岁的孩子送了进去。\n那一刻我突然感到，这个结局如此魔幻，却又说不出的“合理”。生活就是最好的魔幻现实主义。\n很抱歉，时到如今我甚至不愿意提起“她”的名字，我甚至不愿用“这个人”来指代“她”。我不了解所谓的圈子，我只是依旧不能接受，一个受过磨难的人，会把同样处境的人拉进相同的磨难中。\n可我想谈的不是“她”的扭曲，那已经没有意义了。\n我想谈的是我的扭曲。\n我之所以谈起这件事，只是因为它压在我心头太久了。\n但这只是其中的一件让我难以忘却的事情而已，还有太多的事情渗透交织，将我所赖以支持的所有信仰，一点一点地摧毁。\n我曾经以为，善良是人身上最重要的品格，自由是人与生俱来的权利。\n直到我发现，善良是如此的廉价，而自由却如此昂贵。\n我以为自己是始终如一的，即使做错了很多事，我依然可以保持本性的高洁。\n可是当我将头从手机屏幕前移开时，我只感到自己肮脏。\n当我的生活里只剩下绩点，考核，任务的时候，我发现自己早就忘了那个承诺，做一个有用的人的承诺。\n这个世界上的人都是这样生活着的吧，为了活着而不择手段，可以抛弃一切，可以丢掉自己的人格，尊严，理想。\n可是我越来越觉得自己像个怪物。我达不到生活的要求，却离自己的初心越来越远。自我怜悯失去了效果，只剩下深深的自我厌恶。\n我不知道为了什么而活下去。\n初中的我呼唤着理解，高中的我渴望着爱。可是我不再奢望理解，也不再奢望着爱。\n我只是在伪装。\n我分不清自己想做什么，即使我知道也无济于事了。走到今天这一步，我早已明白我所渴望的一切都是不可能实现的。生活处处在开玩笑， …","date":"2024-07-30 16:27:27","updated":"2024-07-30 16:27:27"},{"objectID":"ae25a26b1fe7ced7f95af7702567573f52aa8ec3","permalink":"/post/gjk-algorithm/","title":"两凸包间距离——GJK算法（POJ 3608）","content":"起因：数模期末大作业，求空域在平面投影上相互之间最短距离是否小于安全距离。空域投影的形状有圆形，凸多边形，跑道形。\n使用GJK算法的代码：\n#include\u0026amp;lt;bits/stdc++.h\u0026amp;gt; using namespace std; #define double long double #define x first #define y second #define MIN(a,b,c,d) (min(min(min(a,b),c),d)) #define MAX(a,b,c,d) (max(max(max(a,b),c),d)) typedef pair\u0026amp;lt;double, double\u0026amp;gt; P; typedef unsigned uint; const P origin = P(0, 0); const double eps = 1e-6; struct shape { int type; vector\u0026amp;lt;P\u0026amp;gt; poly; }; inline P add(P a, P b) { return P(a.x + b.x, a.y + b.y); } inline P del(P a, P b) { return P(a.x - b.x, a.y - b.y); } inline P Minus(P a) { return P(-a.x, -a.y); } inline double dot(P a, P b) { return a.x * b.x + a.y * b.y; } inline double det(P a, P b) { return a.x * b.y - a.y * b.x; } inline P mul(P a, double b) { return P(a.x * b, a.y * b); } inline bool isEquals(P p1, P p2) { return abs(p1.x - p2.x) \u0026amp;lt; eps \u0026amp;amp;\u0026amp;amp; abs(p1.y - p2.y) \u0026amp;lt; eps; } inline double len(P a) { return sqrt(a.x * a.x + a.y * a.y); } inline P normalize(P a) { return P(a.x / …","date":"2024-07-21 08:52:25","updated":"2024-07-21 19:52:25"},{"objectID":"7a580d371f974184279bb65b352d91c86ad2478f","permalink":"/post/when-comes-the-downfall/","title":"梦呓（十）—— 倾颓的悲歌","content":"Sweet Poison (Alternative version) - FELT\n恐惧如影随形。\n每一天我都在挣扎着，即使我拼命做完了所有的事情，却永远甩不开身后的阴影。\n我不知道我的恐惧来自何处，具有什么意义。或许是发现，即使拼尽全力，那结局却也是如此可笑。\n就像那地平线上竭力奔跑的人，只是为了不被身后的恐惧追上。\n可是终有一天我会倒下，我任那由血肉构成的躯体如落叶般飘落在大地上。\n然后被铺天盖地的恐惧吞没。\n我如此渴望崩溃的那一刻到来，自己的肉体和灵魂在那一刻破裂成无数细小的碎片。\n我想以此来证明自己的脆弱，证明自己已经无力承受生活强加于自己的一切叙事，证明我已被那本不存在也不应该存在的事物压得无法喘气。\n所以为什么如此迫切地想要撕开自己血淋淋的衣服将自己狰狞的伤疤暴露在外呢？是自己那同情弱者的本能，让自己也以为自己脆弱的一面，也会得到同情，也能拥有被爱的权利吗？\n或是仅仅是想要自己臆想出的悲哀贯穿那麻木和混沌的情绪，试图让自己从中获得那么一点点的慰藉呢？\n我无法解答，就像我解答不了从前的太多问题那样，因为我仅仅是一个遵循着本能试图活下去的人。\n我想狠狠地嘲笑这个奇异，扭曲和可笑的世界。\n可是我猛然意识到，作为这个世界的一部分的我，并没有这样的资格，只是因为自己，同样的可笑，与自己所向往的美好，没有一丝一毫的联系。\n那鲜活的梦如同色彩斑斓的肥皂泡一般，一个接一个破裂。\n带着与世界相同的愚蠢，带着与世界相同的贪婪，我便这样肮脏地在这样的世界上摸爬滚打，离自己曾经所向往的一切越来越远。\n直到我望向镜子里的陌生人，然后无法自制地疯狂呕吐。\n如果可以的话，请把这首歌听完吧。\n我很喜欢FELT的歌，只是在我第一次听到时，这个社团已经解散了。\n就如生命里消逝的一个又一个短暂的梦。\n","date":"2024-07-10 16:27:27","updated":"2024-07-10 16:27:27"},{"objectID":"3fbe01ee060d7e4f6ad65f2377d693836abb9a55","permalink":"/post/the-attitude-of-surviving/","title":"梦呓（九）—— 活着的姿态","content":"“梦呓”这个系列，已经很久没有更过了。\n有一部分原因是因为忙碌，为了活下去而疲于奔命基本占去了我大半的时间。\n在4月的那段时间里我开始写一些技术性的博客，但是很可惜的是，一周内的自习时间甚至不足以我把题改完，所以也没写上几篇。直到CCPC济南的比赛结束后，便进入了期末的复习月，一直持续到如今。所以甚至连CCPC济南这样一次有意义的比赛经历的游记也一点没写。整个博客算是基本沉寂。\n但是还有另外一些原因，那就是《梦呓（ 八）》写完后，我发现我突然失去了向外诉说的能力，即使有很多事情压在我的心里，即使我依然对很多事情有着一些看法，可我回不到那种状态中去了，我不知道该如何用语言去表述我的所思所想。\n回想起高中时语文老师说过的，高中是表达欲望最强的时刻。我想，现在的我，大概就是语言能力退化的表现吧。\n很多时候我是没有写东西的欲望的。我自发的写作欲望，多少是基于整个中学六年记日记的习惯。而激起我这种欲望的，应该是在OI圈子里看到的魔怔文。其实我也不知道为什么OI圈子里会有写魔怔文的风气，可能是因为大佬们干什么都比较强吧，在写作这方面也不会丢下，又正处于思想成熟的阶段，因此产生了比其他人更多的思考。\n很多人写的魔怔文，以我现在的层次甚至还是难以理解。后来我读了《卡夫卡中短篇小说集》，发现这样的文风大概是模仿的卡夫卡。但是卡夫卡写的东西我还是看不懂。说实话照现在大众的文学素养，我不认为一般人能有几个看得懂的。这大概就是为什么《变形记》是名篇，不仅是因为它确实写得好，也是因为它应该是卡夫卡的作品里最好懂的一篇。至于其他的篇目，我所能找到的解析五花八门，没有一个论据是站得住脚的。读书还是得靠自己的文学素养，一步一步慢慢积累。\n所以我写不了小说，因为我不懂怎样运用环境表达情感，怎样通过隐喻暗示主旨，怎样去塑造一个人物，怎样描写人物之间的行为语言。我多少还是缺乏了一些生活经验，不懂得将生活的素材融进自己的文章里。\n我的不过是将自己的情感铺天盖地的渲染在纸上，如同呕吐般将其驱赶出自己的身体，以及毫无论据地抛出自己的观点，再用不知感性还是理性的方法去加以论述。\n但或许这样也无所谓，因为这就是我想做的，我为自己而写，为自己而歌。我需要的是把那沉在心底的沙砾挖出来狠狠地抛向天空，而不是将它精美的包装起来，让人去揣测那究竟是什么东西。\n或许我做不到将思考与讽刺埋进隐喻之中，用精巧的叙事构建出宏伟的大 …","date":"2024-07-05 16:27:27","updated":"2024-07-05 16:27:27"},{"objectID":"8e09ed9ca46c674b84590679a3929131b030b296","permalink":"/post/those-years-we-also-ran-wildly/","title":"那些年，我们也曾奔跑着","content":" 写在前面 本文实际记于2021年9月，物理竞赛复赛前，当时是打在学校电脑的txt文档里的。\n谨以此文怀念我的高中竞赛岁月。\n你不知道该如何面对，\n可你已经无路可退，\n你要坚持到最后一刻，\n为了让生活继续。\n——汪峰《为了让生活继续》\n时光随日月流淌，而繁星依旧闪烁。\n每个夜晚我仰望辽阔星空，却只换来悠悠的一声长叹。\n是该结束的时刻了。\n我没有什么经验，值得留下，我不能告诉你怎么样学物竞，因为说到底，我也一直在摸索着。\n我只能谈一点，悲哀的自己，所能谈的仅有的东西。\n我不清楚你们是为了什么而来到这里，踏上这条充满荆棘与坎坷的征途。是“独上高楼，望尽天涯路”的寻觅与追逐，“众里寻 他千百度”的热爱与向往，还是“将军此去必封侯”的壮志与期许。不知道你们中，是否有人向着省队，披荆斩棘，所向披靡； 或者，你们只是同我一样，是这条征途上迷茫的探索者。\n如果你是前者，那么你值得我的尊敬与景仰；如果你是后者，也不必叹息。\n一 当你走上竞赛这条路时，就应该明白，竞赛是一场刺刀见红的白刃战。向前的每一步，都踏着无数人的尸体；人人向往的那一场 胜利，背后是无数人的倒下。\n50个省一，不必夸大主观意识的重要性，仅仅算一下概率，就会明白，这场战争的期望(Expectation)，并不像你所想的如此美好。\n所以，不要因为你的成绩而黯然神伤，不要为了竞赛而不惜一切。竞赛是少数人的战斗，只有天赋+热爱+时间的投入+一定的运气，缺一不可，才有可能真正的脱颖而出。\n这一路是怎么过来的，我们再清楚不过。后期的竞赛，老师已经形同虚设，一切只看你自己，最大的作用就是把你送到培训机构或者其他学校，刷几十套卷子，听从来就没有听懂过的知识。\n在这条路上若碰见志同道合的同学，请一定要好好珍惜——因为很有可能，竞赛的征程中，你不得不独自扛下一切。\n竞赛是强者的世界，也是孤独者的世界。\n二 如果说我在竞赛中学到了什么，答案是一无所获。\n倘若你们带着收获什么的想法到来，可能会失望而归。\n竞赛给不了你什么，它不会让你在高考占什么优势，你未必会比那些一天到晚刷高考题的人考的好。\n但我想学会接受也是一种成长，学会承认你比不上别人，承认你一无所知。这并不可耻.\n只是当你不再追求得到什么的时候，竞赛早在你的生命中，烙下深深的印记。\n三 在学竞赛的过程中，不要忽视了文化课的重要性。\n除非你学竞赛跟玩似的，或者你已经有进国集的把握了 …","date":"2024-06-13 15:25:02","updated":"2024-06-13 15:25:02"},{"objectID":"dc08483c349e1a46d19e90f2d80e916da5f01b6c","permalink":"/post/codeforces-round-921-div.-2/","title":"Codeforces Round 921 (Div. 2)","content":"好久以前的div2拖到现在才改真是唐完了。\nDashboard - Codeforces Round 921 (Div. 2) - Codeforces\nTag 概率论，线段树，数学\nD 概率论没学好导致的。\n期望的贡献可以分为两部分，第一部分是原始$f_i$数组产生的贡献，第二部分是增加的数产生的贡献，注意到第二部分和原数组没有任何关系，只与增加的方案相关。\n第一部分的贡献即$\\frac{k\\sum _{i=1}^{m}f_i}{d}$，其中$d=\\binom{n}{2}$\n令第二部分贡献的随机变量为$Z$，每个友谊组合的贡献的随机变量为同分布$Y_i$，则$Z=Y_1+Y_2+...+Y_m$，这步是问题核心。\n令每个友谊组合被选中的次数为$X_i$，因为选中$x$次就会产生$\\sum _{i=0}^{x-1}i$的贡献，有$Y_i=\\frac{X_i(X_i-1)}{2}$，又$X_i \\sim B(k,\\frac{1}{d})$，因此\n$$E(Y)=\\sum _{x=1}^{k}\\frac{x(x-1)}{2}\\cdot P(x)$$，其中\n$$P(x)=\\binom{k}{x}(\\frac{1}{d})^x(1-\\frac{1}{d})^{k-x}$$最终$E(Z)=m\\cdot E(Y)$\nint n,m,k; int a[100005],b[100005],f[100005]; const ll mod=1e9+7; inline ll qpow(ll x,ll n){ll res=1;for(;n;(n\u0026amp;amp;1)\u0026amp;amp;\u0026amp;amp;(res=res*x%mod),x=x*x%mod,n\u0026amp;gt;\u0026amp;gt;=1);return res;} ll jc[200005],jcinv[200005],dpx[200005],mdpx[200005]; const int MAXK=2e5; inline ll C(ll n,ll m){return jc[n]*jcinv[m]%mod*jcinv[n-m]%mod;} int main(){ jc[0]=jc[1]=1; for(int i=2;i\u0026amp;lt;=MAXK;i++) jc[i]=jc[i-1]*i%mod; jcinv[MAXK]=qpow(jc[MAXK],mod-2); for(int …","date":"2024-05-20 16:55:27","updated":"2024-05-24 08:55:27"},{"objectID":"90fe05582c2da2e8aadacd7e8992cf92a3d55fba","permalink":"/post/icpc-2024-wuhan/","title":"ICPC2024（武汉邀请赛）游记","content":"省流：铁了\nDay -1 坐高铁从长沙前往武汉。\n五一的票是真难抢啊，两点出的校门但是坐的这班是五点开的，在火车站刷了两小时手机，比高铁开的时间还长。\n出了校门心情就轻松起来了，也是，这几周已经接连被头痛，作业，慕课等一堆事情折磨的不成人样了。整的比赛前训练都耽搁了一段时间，本来前一段刚刷出来一点手感的，现在估计又没有了。\n但也是不得已的事情了啊。我们的处境，注定了我们是不可能有完整的时间和充足的精力来全身心投入ACM中的。\n其实曾经的自己不也是这样吗？作为一名OI选手却从来没有停过课训练，最多是比赛前两周才停课去机房。或许是投入的还不够多，所以才会卡在省一之后上不去吧。一上高中课业压力增大了，热情退却了，就再也没有训练的动力了。当时还跑去物竞，反正到最后也没读明白，混了个省二，最后文化课也没读好沦落到这个境地，哈哈。\n也不能全怪当时的自己吧，自己也不是什么天才，而这个赛道终究又太小了。自己的心智还没有成熟，有很多事情那时是不可能理解的（或许现在也无法理解）。\n上大学后以为自己彻底和这东西说再见了，想不到还真有再见的一天。大一到大二上学期其实自己也没明白自己为什么要打ACM，也没什么训练规划，唯一的成就是跟着混了两个Ag，也算是白白浪费了两年的时间了吧。\n直到这学期我终于想明白了，我喜欢这种感觉，因为这是我整个陷入虚无的生活中仅有的能让我抓住一点意义感的事情，就像沉入黑暗后唯一的的荧光。\n此刻我才明白，自己的时间，是如此的宝贵，又是如此的匮乏。\n我记得proking说过他想在大四之前像Maple他们那样冲个wf。我做不到这样的乐观，我觉得能拿到Au就是我如今的愿望了，而我如今付出的远远还不够。感觉挺对不起proking的，他一直在进步，可我却在原地踏步。\n这样子想的话，心情又沉重了啊。明明是游记，为什么不知不觉地就说了一堆胡话。\n窗外依旧是阴雨绵绵，但是没有了沉重的外套，也感到清爽不少。\n晚上终于见到了@百雲 。说起来很奇妙，OI生涯唯一认识的两个人居然是因为一向社恐不在网上不说话的我noip前一天在洛谷上发了一句rp++。但是谁能想到，居然到了大二才因为比赛的原因才能线下见上一面。时隔多年，而此情此景，我早已身不由己。\n于是被@百雲 带着逛了华科，华科的环境挺好的，道路两旁参天的古木看着很有意境。\n他送我一个晓美焰的手办，虽然我没看过小圆，但是这是第一次收到这样的 …","date":"2024-04-30 16:55:27","updated":"2024-05-02 16:56:29"},{"objectID":"5222c4af71ef1c5691b3e090c056dc13366ea69a","permalink":"/post/2022-ccpc-guilin-site-g/","title":"2022 CCPC Guilin Site G","content":"Luckyblock写了就是我写了（\n2022 CCPC Guilin Site G - Luckyblock - 博客园 (cnblogs.com)\nconst int MAXN=2e5+5; int n; int a[MAXN]; typedef pair\u0026lt;int,int\u0026gt; P; vector\u0026lt;int\u0026gt; e[MAXN]; vector\u0026lt;P\u0026gt; d[MAXN]; void dfs1(int u=1,int f=0){ for(auto v:e[u]){ if(v==f) continue; dfs1(v,u); d[u].push_back(P((d[v].empty()?0:d[v][0].first)+a[v],v)); } sort(d[u].begin(),d[u].end(),greater\u0026lt;P\u0026gt;()); } void dfs2(int u=1,int f=0,int last=0){ if(f) d[u].push_back(P(last,f)); while(d[u].size()\u0026lt;4) d[u].push_back(P(0,0)); sort(d[u].begin(),d[u].end(),greater\u0026lt;P\u0026gt;()); for(auto v:e[u]) if(v!=f) dfs2(v,u,d[u][0].second==v?d[u][1].first+a[u]:d[u][0].first+a[u]); } unordered_map\u0026lt;int,int\u0026gt; dp[MAXN]; inline int F(int i,int j){ if(dp[i].count(j)) return dp[i][j]; int p1=0;while(d[i][p1].second==j) ++p1; int p2=p1+1;while(d[i][p2].second==j) ++p2; int res=d[i][p1].first+d[i][p2].first+a[i]; for(auto v:e[i]) if(v!=j) res=max(res,F(v,i)); return dp[i][j]=res; } int main(){ R(n); for(int i=1;i\u0026lt;=n;i++) R(a[i]); for(int i=1;i\u0026lt;n;i++){ int u,v; R(u);R(v); e[u].push_back(v); e[v].push_back(u); } dfs1(); dfs2(); int ans=0; for(int i=1;i\u0026lt;=n;i++) ans=max(ans,d[i][0].first+d[i][1].first+d[i][2].first+d[i][3].first); for(int i=1;i\u0026lt;=n;i++) for(auto j:e[i]) ans=max(ans,F(i,j)+F(j,i)); printf(\u0026#34;%d\\n\u0026#34;,ans); return 0; } ","date":"2024-04-24 08:52:25","updated":"2024-04-24 19:52:25"},{"objectID":"78291b1c539650fac1af122b38f98123b92ae73b","permalink":"/post/newcoder-challenge-74/","title":"牛客练习赛74","content":"省流：唐了但没完全唐。\n牛客挑战赛74\nA 简单DP。用第二维状态0表示没拿的多一，1表示拿和没拿的相等，2表示拿了的多一。\n挂了一发的原因是起始状态忘记初始化了。\nint n,a[100005]; long long f[100005][3];//状态0表示没拿多一，1表示拿和没拿相等，2表示拿了的多一 int main(){ R(n); for(int i=1;i\u0026lt;=n;i++){ R(a[i]); } f[0][1]=0;\t//初始时拿和没拿相等 f[0][0]=f[0][2]=-1e18;\t//唐：忘记初始化了 for(int i=1;i\u0026lt;=n;i++){ f[i][1]=max(f[i-1][0]+a[i],f[i-1][2]); f[i][0]=f[i-1][1]; f[i][2]=f[i-1][1]+a[i]; } cout\u0026lt;\u0026lt;max(max(f[n][0],f[n][1]),f[n][2])\u0026lt;\u0026lt;endl; return 0; } B 贪心，将每个手斧的破坏程度从小到大排序，分别在树高的集合中二分，与能砍的树中树高最大的匹配。\nint n,m,a[100005],b[100005]; multiset\u0026lt;int\u0026gt; s; int main(){ R(n);R(m); for(int i=1;i\u0026lt;=n;i++){ R(a[i]); s.insert(a[i]); } for(int i=1;i\u0026lt;=m;i++) R(b[i]); sort(b+1,b+1+m); int cnt=0; for(int i=1;i\u0026lt;=m;i++){ if(s.empty()) break; auto p=s.upper_bound(b[i]); if(p!=s.begin()){ s.erase(--p); cnt++; } } cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;endl; return 0; } C 分类讨论题。详情见代码。\nint T; long long a1,b1,a2,b2; int main(){ R(T); while(T--){ R(a1);R(b1);R(a2);R(b2); long long ans=max(a1+b1,a2+b2); //A 写数学 B 写语文 ans=min(ans,max(a1+b1,max(a1,b2)+a2/2));\t//B抄A不抄 ans=min(ans,max(max(a1,b2)+b1/2,max(a1,b2)+a2/2));\t//都抄 ans=min(ans,max(max(a1,b2)+b1/2,b2+a2));\t//A抄B不抄 //B 写数学 A 写语文 ans=min(ans,max(a1+b1,max(b1,a2)+b2/2));\t//B抄A不抄 ans=min(ans,max(max(a2,b1)+a1/2,max(b1,a2)+b2/2));\t//都抄 ans=min(ans,max(max(b1,a2)+a1/2,b2+a2));\t//A抄B不抄 //唐：忘记可以一个人写两份作业了给另一个人抄了。 //A 写数学语文 ans=min(ans,max(a1+b1,a1+max(b1,a2/2)+b2/2)); ans=min(ans,max(a1+b1,b1+max(a1,b2/2)+a2/2)); //B 写数学语文 ans=min(ans,max(a2+b2,a2+max(b2,a1/2)+b1/2)); ans=min(ans,max(a2+b2,b2+max(a2,b1/2)+a1/2)); printf(\u0026#34;%lld\\n\u0026#34;,ans); } return 0; } D 数据结构题（大概）\n一个想法是把每次操作3扣除的血量累加起来考虑，就可以实现对整体血量进行一个计算。\n假设扣除的总血量为$dlt$，那么我们维护的血量为$hp_i=realhp_i+dlt$。具体表现为编号$x$加入战斗时血量设为$b_x+dlt$，撤出战斗时血量设为0（或者负数），为编号$x$恢复血量$h$时血量等于$\\min\\{hp_x+h,b_x+dlt\\}$。\n以上操作1，2，4可以用一个数组维护血量。\n对于操作3，我们注意到每个人死亡后不会再参与战斗，那么我们可以同时用一个set去维护血量，每次操作3时暴力从小到大判断set中各元素血量是否小于$dlt$进而进行删除。这样对于操作3，每个元素最多被遍历一次。\n操作1，2，4在维护数组时同时维护set即可。\n总复杂度$O((n+k) \\log_2 n)$\nint n,k; long long m; int a[100005],b[100005]; typedef pair\u0026lt;ll,int\u0026gt; P; set\u0026lt;P\u0026gt; hp; long long hp2[100005]; int main(){ R(n);R(m);R(k); long long atk=0; for(int i=1;i\u0026lt;=n;i++){ R(a[i]); atk+=a[i]; } for(int i=1;i\u0026lt;=n;i++){ R(b[i]); hp.insert(P(b[i],i)); hp2[i]=b[i]; } ll dlt=0; int excnt=0; while(k--){ int opt,x,h; R(opt);R(x); if(opt==1){ hp.insert(P(b[x]+dlt,x)); hp2[x]=b[x]+dlt; atk+=a[x]; excnt--; } else if(opt==2){ hp.erase(P(hp2[x],x)); hp2[x]=0; atk-=a[x]; excnt++; } else if(opt==3){ dlt+=x; for(auto i=hp.begin();i!=hp.end()\u0026amp;\u0026amp;i-\u0026gt;first\u0026lt;=dlt;i=hp.begin()){ atk-=a[i-\u0026gt;second]; hp2[i-\u0026gt;second]=0; hp.erase(i); } } else{ R(h); if(hp2[x]\u0026gt;0){ hp.erase(P(hp2[x],x)); hp2[x]=min(hp2[x]+h,b[x]+dlt); hp.insert(P(hp2[x],x)); } } if(hp.size()+excnt\u0026lt;=0){ puts(\u0026#34;NO\u0026#34;); return 0;\t} m-=atk; if(m\u0026lt;=0){ puts(\u0026#34;YES\u0026#34;); printf(\u0026#34;%llu\\n\u0026#34;,hp.size()+excnt); return 0; } } puts(\u0026#34;NO\u0026#34;); return 0; } 其余咕。\n","date":"2024-04-12 08:52:25","updated":"2024-04-12 19:52:25"},{"objectID":"af9f600113b4a6b92ddfa8e1ee5c5c1a04b57994","permalink":"/post/2022-icpc-asia-hangzhou/","title":"The 2022 ICPC Asia Hangzhou Regional Programming Contest (partial)","content":"The 2022 ICPC Asia Hangzhou Regional Programming Contest - Codeforces\n省流：自己打的vp，但是在应该会做的简单数论和DP上疯狂挂分，唐完了。\n最后没打过一群学弟，紫砂了。\n建议我和大一组一队让我混个Au\n同学和大一组一队，感觉要让他白捡Au了\nTag 字符串哈希，数论，DP，字典树\nF 签到，暴力判断每个字符串中是否有\u0026amp;quot;bie\u0026amp;quot;，把符合条件的进行字符串hash存储在哈希表（unordered_set）里。\nint n; typedef unsigned long long ull; unordered_set\u0026amp;lt;ull\u0026amp;gt; mp; const int base=10000007; int main(){ ios::sync_with_stdio(0);cin.tie(0); cin\u0026amp;gt;\u0026amp;gt;n; for(int i=1;i\u0026amp;lt;=n;i++){ int m; cin\u0026amp;gt;\u0026amp;gt;m; int f=1; for(int j=1;j\u0026amp;lt;=m;j++){ string s; cin\u0026amp;gt;\u0026amp;gt;s; for(unsigned k=2;k\u0026amp;lt;s.size();k++){ if(s[k-2]==\u0026amp;#39;b\u0026amp;#39;\u0026amp;amp;\u0026amp;amp;s[k-1]==\u0026amp;#39;i\u0026amp;#39;\u0026amp;amp;\u0026amp;amp;s[k]==\u0026amp;#39;e\u0026amp;#39;){ ull hash=0; for(unsigned p=0;p\u0026amp;lt;s.size();p++) hash=hash*base+s[p]; if(mp.find(hash)==mp.end()){ f=0; cout\u0026amp;lt;\u0026amp;lt;s\u0026amp;lt;\u0026amp;lt;endl; mp.insert(hash); } break; } } } if(f){ cout\u0026amp;lt;\u0026amp;lt;\u0026amp;#34;Time to play Genshin Impact, Teacher Rice!\u0026amp;#34;\u0026amp;lt;\u0026amp;lt;endl; } } return 0; } D 找规律题，写了个暴力后发现最终答案形式一定为$2x,x,x ,... ,x$。\n吓死了，差点智商又被强奸了\nint n,a[100005]; int main(){ R(n); double sum=0; …","date":"2024-04-11 08:52:25","updated":"2024-04-11 19:52:25"},{"objectID":"1367076fc961c1962c9470763025a7d3ce112e48","permalink":"/post/2024-icpc-invitational-wuhan-site/","title":"2024 ICPC Invitational Wuhan Site (partial)","content":"我真傻，真的\n好多小马题，小马害人\nDashboard - 2024 ICPC National Invitational Collegiate Programming Contest, Wuhan Site - Codeforces\nI 水签，比较相邻位逆序个数就行了\n就这改题时看了一眼就会的破题我比赛还看了5分钟，紫砂了。\n#include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; typedef unsigned uint; string s; int main(){ ios::sync_with_stdio(0); cin\u0026gt;\u0026gt;s; int cnt=0; for(uint i=0;i\u0026lt;s.length()-1;i++) if(s[i]\u0026gt;s[i+1]) cnt++; cout\u0026lt;\u0026lt;cnt\u0026lt;\u0026lt;endl; return 0; } K 搜索打了个表发现n%4==0或n%4==1时必胜，否则必败，原理不分析，证明略。\n参考文献：2024 ICPC National Invitational Collegiate Programming Contest, Wuhan Site - Luckyblock - 博客园 (cnblogs.com)\n这题是队友卡的不能怪我，下次这种打表题还是我写吧。\ninline void solve(){ R(T); while(T--){ R(n); if(n%4==1||n%4==0) puts(\u0026#34;Fluttershy\u0026#34;); else puts(\u0026#34;Pinkie Pie\u0026#34;); } } B 这题也是队友卡的\n首先我们可以注意到，题目中操作只能进行 $n$ 次的限制是一个假限制，因为 $n$ 次操作足够我们把一个序列变成任意一个序列。于是我们只需呀考虑最终的序列是什么样的。\n显然，我们需要尽可能使得最高位的 $1$ 最小，那么我们容易想到将总和 $sum$ 平均分给 $n$ 个数。但是会出现无法整除存在余数的情况。这种情况下，我们找到 $sum/n$ 二进制的从低到高第一个为 $0$ 的位，将其设置为 $1$ ，比其低的位设为 $0$，由此得到当前的答案。对余数重复进行此操作，最终答案即每次答案的累计。\nint p[35],a[200005]; signed main(){ p[0]=1; for(int i=1;i\u0026lt;=30;i++){ p[i]=p[i-1]*2; } int n; R(n); int sum=0; for(int i=1;i\u0026lt;=n;i++){ R(a[i]); sum+=a[i]; } int x=0; while(1){ int d=sum/n,y=sum%n,c=0; if(y==0){ x+=d; break; } for(int i=0;i\u0026lt;30;i++){ if((d\u0026amp;(1\u0026lt;\u0026lt;i))==0){ c=(1\u0026lt;\u0026lt;i); break; } d-=(1\u0026lt;\u0026lt;i); } sum%=c; x+=c+d; } printf(\u0026#34;%lld\\n\u0026#34;,x); return 0; } E 你这辈子就是给小马害了\n本次比赛最战犯的一道题。\n问题可以转化为求一棵树从根节点开始每个时刻的生成树的直径。\n我们知道对于树上任意一点，离它最远的节点一定是树的直径的一个端点。而直径的一个端点到另一个端点同样是距离最远的。\n对于 $t$ 时刻，新增节点为深度为 $t$的所有叶子节点。若当前直径为 $(u,v)$ ，我们考虑这些新增节点是否可能成为新的直径，即对于每个新增节点，找到离它最远的节点，这个问题等价于离找它的父亲节点最远的节点，而离它的父亲最远的节点只可能是 $u,v$ 中的一个。因此在加入一个新节点 $x$ 后，当前直径只可能是 $(u,v)$ ，$(u,x)$ ，$(v,x)$ 中的一个。\n注意到$k=i$的答案是具有单调性的，因此单调地枚举时间$t$即可。\n#include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; int n,r,t0; vector\u0026lt;int\u0026gt; e[200005]; int fa[200005][20],dep[200005]; inline void R(int \u0026amp;n){ n=0;int f=1;char c=getchar(); while(c\u0026lt;\u0026#39;0\u0026#39;||c\u0026gt;\u0026#39;9\u0026#39;){if(c==\u0026#39;-\u0026#39;) f=-1;c=getchar();} while(c\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;c\u0026lt;=\u0026#39;9\u0026#39;) n=n*10-\u0026#39;0\u0026#39;+c,c=getchar();n*=f; } void dfs(int u,int f){ fa[u][0]=f; dep[u]=dep[f]+1; for(int i=1;i\u0026lt;=18;i++) fa[u][i]=fa[fa[u][i-1]][i-1]; for(auto v:e[u]) if(v!=f) dfs(v,u); } inline int lca(int a,int b){ if(a==b) return a; if(dep[a]\u0026lt;dep[b]) swap(a,b); for(int i=18;i\u0026gt;=0;i--) if(dep[fa[a][i]]\u0026gt;=dep[b]) a=fa[a][i]; if(a==b) return a; for(int i=18;i\u0026gt;=0;i--){ if(fa[a][i]!=fa[b][i]){ a=fa[a][i]; b=fa[b][i]; } } return fa[a][0]; } inline int dis(int a,int b){return dep[a]+dep[b]-2*dep[lca(a,b)]+1;} int len[400005],book[400005]; typedef pair\u0026lt;int,int\u0026gt; P; queue\u0026lt;P\u0026gt; q; inline void update(int \u0026amp;u,int \u0026amp;v,int x,int t){ int duv=dis(u,v), dvx=dis(v,x), dux=dis(u,x); int maxx=max(duv,max(dvx,dux)); len[t]=maxx; if(maxx==duv) return; else if(maxx==dvx) u=x; else if(maxx==dux) v=x; } int ans[400005]; int32_t main(){ //\tfreopen(\u0026#34;.in\u0026#34;,\u0026#34;r\u0026#34;,stdin);freopen(\u0026#34;.out\u0026#34;,\u0026#34;w\u0026#34;,stdout); R(n); for(int i=1;i\u0026lt;n;i++){ int u,v; R(u);R(v); e[u].push_back(v); e[v].push_back(u);\t} R(r);R(t0); dfs(1,0); q.push(P(r,0)); int x=r,y=r; len[0]=1; int tmax=0; book[r]=1; while(!q.empty()){ int u=q.front().first,t=q.front().second;q.pop(); tmax=t; for(auto v:e[u]){ if(book[v]) continue; q.push(P(v,t+1)); update(x,y,v,t+1); book[v]=1; } } for(int i=tmax+1;i\u0026lt;=n+t0;i++) len[i]=len[i-1]; int ans=t0; while(len[ans]\u0026gt;2ll*(ans-t0)+1) ++ans; printf(\u0026#34;%d \u0026#34;,ans); for(int i=2;i\u0026lt;=n;i++){ while(ans\u0026gt;t0\u0026amp;\u0026amp;len[ans-1]\u0026lt;=2ll*i*(ans-1-t0)+1) --ans; printf(\u0026#34;%d \u0026#34;,ans); } return 0; } 咕\n","date":"2024-04-01 08:52:25","updated":"2024-07-21 19:52:25"},{"objectID":"4dc2866958ff5b4967f15f1ac04dac7c19f652bd","permalink":"/post/2024-hunan-multi-school-4/","title":"The 2024 Hunan Multi-School Programming Training Contest Round 4 (partial)","content":"公式好像写多了，Latex得加载好一会儿。\nHunan Collegiate Championship Ⅳ 2024 (feat. Yokohama Regional 2021) - Codeforces\nTag 随机化（蒙特卡洛法），偏序，图论转化\nA 相邻两个球相交首尾相接求体积并，给出公式，签到题\n其实我也是第一次知道$\\pi=acos(-1)$\n#include\u0026lt;bits/stdc++.h\u0026gt; using namespace std; char buf[1\u0026lt;\u0026lt;21],*p1=buf,*p2=buf; typedef long long ll; //#define getchar() (p1==p2\u0026amp;\u0026amp;(p2=(p1=buf)+fread(buf,1,1\u0026lt;\u0026lt;21,stdin),p1==p2))?EOF:*p1++ inline void R(ll \u0026amp;n){ n=0;int f=1;char c=getchar(); while(c\u0026lt;\u0026#39;0\u0026#39;||c\u0026gt;\u0026#39;9\u0026#39;){if(c==\u0026#39;-\u0026#39;) f=-1;c=getchar();} while(c\u0026gt;=\u0026#39;0\u0026#39;\u0026amp;\u0026amp;c\u0026lt;=\u0026#39;9\u0026#39;) n=n*10-\u0026#39;0\u0026#39;+c,c=getchar();n*=f; } #define double long double ll n,r,x[105],y[105],z[105]; double v; const double pi=acos(-1); int main(){ R(n);R(r); v=4.0*pi*r*r*r/3; for(int i=1;i\u0026lt;=n;i++){ R(x[i]);R(y[i]);R(z[i]); } double f=0,d; for(int i=2;i\u0026lt;=n;i++){ d=sqrt((x[i]-x[i-1])*(x[i]-x[i-1])+(y[i]-y[i-1])*(y[i]-y[i-1])+(z[i]-z[i-1])*(z[i]-z[i-1])); f+=2.0/3*pi*(r-d/2)*(r-d/2)*(2*r+d/2); } d=sqrt((x[1]-x[n])*(x[1]-x[n])+(y[1]-y[n])*(y[1]-y[n])+(z[1]-z[n])*(z[1]-z[n])); f+=2.0/3*pi*(r-d/2)*(r-d/2)*(2*r+d/2); printf(\u0026#34;%.8Lf\\n\u0026#34;,v*n-f); return 0; } J 赛场思路比较诡异的一题。\n首先第一反应先排个序再说。\n按x升序排序之后，我们发现一个显然的性质，对于左下角点的选取，若对于一个点$(x_{i},y_{i})$，存在一个点$(x_{j},y_{j})$满足$x_{j}","date":"2024-04-01 08:52:25","updated":"2024-04-28 16:52:25"},{"objectID":"b7a8be7dd4a3a6e9820cc036b9c0f6f2354ff486","permalink":"/post/newcoder123/","title":"牛客练习赛123","content":"哈哈，智商又被强奸了。\n是个人都会做B就我TM不会。\n牛客练习赛123\nA 签到。按题目要求照做。\nint n; string s; int main(){ ios::sync_with_stdio(0);cin.tie(0); cin\u0026gt;\u0026gt;n\u0026gt;\u0026gt;s; for(int i=0;i\u0026lt;n/2+(n\u0026amp;1);i++) putchar(s[i]); return 0; } B 有笨蛋看到题目写着鸽巢原理不知道这题和鸽巢原理啥关系。\n哈哈，紫砂了。\n这题思路类似于hdu1205，\n先讲hdu1205思路：\n将最多的一种糖果想象成鸽巢，将剩余其他糖果总和想象成鸽子，也就转换成了$\\sum_{i=1}^{n}a_{i} -max\\{ a_{i}\\}$与$max\\{ a_{i}\\}$的问题\n令$S=\\sum_{i=1}^{n}a_{i} -max\\{ a_{i}\\}$，$N=max\\{ a_{i}\\}$。题意相当于在鸽巢间插入鸽子把鸽巢分隔开，鸽巢间插入鸽子又可以看做把鸽子放到前一个鸽巢中。\n若$S \u003c N-1$，那么必定有两个鸽巢连续，不合题意。\n若$S == N-1$，那么除了最后一个鸽巢外每个鸽巢里正好有一只鸽子。\n若$S \u003e N-1$，因为$N=max\\{ a_{i}\\}$，所以其余的任意 $a_{i}$都不大于$N$，可以分到N个鸽巢中，每个鸽巢内的鸽子必定不重样。\n结论是，$S\\ge N-1$时必定有解。\n那么回到本题。\n对于一种小球$a_{i}$，我们尽可能把其他小球消去，那么消去的最优方案其实就是上面的吃糖方案。\n若$\\sum_{j=1}^{n}a_{j}-a_{i}-\\max_{j\\ne i}\\{a_{j}\\} \\ge \\max_{j\\ne i}\\{a_{j}\\}-1$，即存在一种吃糖方案，那么剩余小球的数量就是$(\\sum_{j=1}^{n}a_{j}-a_{i}) \\% 2$\n若$\\sum_{j=1}^{n}a_{j}-a_{i}-\\max_{j\\ne i}\\{a_{j}\\} \u003c \\max_{j\\ne i}\\{a_{j}\\}-1$，即不存在吃糖方案，那么最终剩下的小球数为$\\max_{j\\ne i}\\{a_{j}\\}-(\\sum_{j=1}^{n}a_{j}-a_{i}-\\max_{j\\ne i}\\{a_{j}\\})$\n比较剩余小球数与$a_{i}$大小即可。\n注意特判n=1的情况。\n感觉好像和鸽巢原理也没什么关系\nint T,n,a[1000006]; int main(){ R(T); while(T--){ R(n); long long sum=0; int mx1=0,mx2=0; for(int i=1;i\u0026lt;=n;i++){ R(a[i]); sum+=a[i]; if(a[i]\u0026gt;mx2) mx2=a[i]; if(mx2\u0026gt;mx1) swap(mx2,mx1); } if(n==1){ puts(\u0026#34;1\u0026#34;); continue; } int i,mx; for(i=1;i\u0026lt;=n;i++){ mx=mx1; if(a[i]==mx1) mx=mx2; if((sum-a[i]-mx\u0026gt;=mx-1\u0026amp;\u0026amp;((sum-a[i])\u0026amp;1)\u0026lt;a[i])||(sum-a[i]-mx\u0026lt;mx-1\u0026amp;\u0026amp;mx-(sum-a[i]-mx)\u0026lt;a[i])) printf(\u0026#34;1 \u0026#34;); else printf(\u0026#34;0 \u0026#34;); } puts(\u0026#34;\u0026#34;); } return 0; } CDEFG咕。\n感想： 已经成老东西了，被大一的薄纱了。\n这个写一场比赛被强奸一次智商的b样子要是让初三的自己看到怕是要笑死。\n有点怀疑自己到底有没有在ACM继续呆下去的必要了。\n唉，理想；唉，生活。本来说好了要再奋斗一个学期现在看来自己那点热情真是p都算不上。\n真该考虑要不要转型CTF了。\n（转到一个完全陌生的领域大概要更困难吧）\n","date":"2024-03-30 08:52:25","updated":"2024-03-30 19:52:25"},{"objectID":"339cc9e2379bd5cebdd36d64bef6396f409df7e2","permalink":"/post/hugo-article-password-bypass/","title":"Hugo文章密码绕过的简单实验","content":"前情提要：\n笔者在搭建博客的时候，发现有给自己的博客文章加上密码功能的实现。实现方式如下。\n【参考文献：Hugo | 为博客文章添加密码 – Zoe\u0026rsquo;s Dumpster. (tantalum.life)】\n在layouts/_default/single.html中添加：\n\u0026lt;div class=\u0026#34;post-password\u0026#34;\u0026gt; {{ if ( .Params.password | default \u0026#34;\u0026#34; ) }} \u0026lt;script\u0026gt; (function(){ if (prompt(\u0026#39;请输入文章密码\u0026#39;) != {{ .Params.password }}){ alert(\u0026#39;密码错误！\u0026#39;); if (history.length === 1) { window.opener = null; window.open(\u0026#39;\u0026#39;, \u0026#39;_self\u0026#39;); window.close(); } else { history.back(); } } })(); \u0026lt;/script\u0026gt; {{ end }} \u0026lt;/div\u0026gt; 然后把密码放在markdown文件的头部。\n--- title = \u0026#39;这是一个标题\u0026#39; password = \u0026#39;123\u0026#39; --- 密码效果如下（用自己博客的副本，在本地运行hugo测试）：\n注意到这个密码功能是用js写的，再加上这个密码验证是一个弹窗，让我想起了之前在pikachu靶场打过的客户端验证码绕过。这里的密码验证能不能通过相同的逻辑绕过呢？\n随便输入一个密码，弹出密码错误窗口，\n用bp抓包，未捕获到相关数据包，说明密码是在前端验证的。（静态博客哪里有后端 )\n那么我们直接将访问该页面的请求抓包，发送给Repeater。\n在Repeater中发送后收到服务器的应答，获得网页html。注意这里如果出现网页304的情况就清理一下缓存。\n此时可以直接在render中查看。\n也可以复制出来放在html文件中，删掉报头后将密码验证部分的js代码删掉。 此时双击html文件就可以查看内容。\n证明这种方式实现的前端验证的密码是可以绕过的。所以这种密码验证只具备观赏性，安全性等于没有，不建议将隐私内容以这种方式放在博客上。对于Hexo等其他静态博客理论上也是成立的。\n因为是js校验的，所以猜测把js直接禁掉也是可以直接绕过的。\n这再次验证了一个道理，一切前端的校验都是不安全的，因为你不知道用户会对你的网页做什么。\n另外，如果你和我一样用Github Page搭博客，众所周知Github Page只有Public仓库能使用，所以整个博客上的内容都是公开的，可以直接到Github里把整个博客的源码扒下来，所以不存在什么用密码能保护的东西……\n","date":"2024-03-27 08:52:25","updated":"2024-03-27 19:52:25"},{"objectID":"920f36120a8221999284fdf951c1b50b3dc9c57f","permalink":"/post/computational-geometry/","title":"计算几何入门笔记（学习中）","content":"因为懒得写博客所以大部分是搬运的。\n参考文献 二维计算几何基础 - OI Wiki (oi-wiki.org)\n计算几何初步 - 洛谷专栏 (luogu.com)\n判断两个线段是否相交 - balabala已被注册 - 博客园 (cnblogs.com)\n计算几何三维入门 - 洛谷专栏 (luogu.com)\n【笔记】二维凸包 - 洛谷专栏 (luogu.com)\n平面计算几何基础 线段平行 设线段端点分别为$P_1,P_2$和$P_3,P_4$\n则\n$$\\overrightarrow{P_1 P_2} \\times \\overrightarrow{P_3 P_4} = 0$$ 线段共线 设线段端点分别为$P_1,P_2$和$P_3,P_4$\n则\n$$\\overrightarrow{P_1 P_2} \\times \\overrightarrow{P_2 P_3} = 0$$ $$\\overrightarrow{P_1 P_2} \\times \\overrightarrow{P_2 P_4} = 0$$ 判断一个点在线段的哪边 假设有向线段为$\\overrightarrow{AB}$ ，点为$C$，首先计算外积$\\overrightarrow{AC} × \\overrightarrow{AB}=( \\overrightarrow{AC}_{x} ⋅\\overrightarrow{AB}_{y}-\\overrightarrow{AC}_{y} ⋅\\overrightarrow{AB}_{x})\\overrightarrow{k}$（因为有$\\overrightarrow{AB}_{z}=0$，$\\overrightarrow{AB}_{z}=0$）。根据右手螺旋定则，如果$\\overrightarrow{k}$的系数为正数，说明点$C$在线段$AB$的右侧；如果为负数，说明点$C$在线段$AB$的左侧；如果为0，说明点$C$在线段$AB$所在的直线上。\n//************************************************************************* // \\brief: 计算两个向量的外积（叉乘）。可以根据结果的符号判断三个点的位置关系。 // \\Param: Point A 两个向量的公共起点。 // …","date":"2024-03-18 08:52:25","updated":"2024-04-09 19:52:25"},{"objectID":"3bde4f00fd5dc22999539019a2d4bb2d486d1416","permalink":"/post/the-world-is-a-stage/","title":"梦呓（八）—— 世界是一个草台班子","content":"此刻我在离家的飞机上。\n我依然记得上一次在飞机上记下的东西。我向我的梦与幻想告别，告诉它们我将暂时离开。我感慨即使回到家里也依旧感到身上的枷锁，也许真正的自由从来不在。\n半年的时间我想不起来自己做了什么有意义的事情，只是内心被更多的东西塞得越发混乱。\n和去年的秋天所感受到的大体相同吧，已然麻木的内心，却不能像以往那样洒脱。\n没有梦也没有幻想。不如说是自己的幻想已经没有办法再次唤醒自己，没有办法让自己对生命重燃希望。\n生活的一切都如此复杂，只有自我单调得像一片虚空。\n很久没写东西了。\n没在博客上发癫有时并不意味着我的精神状态很好，这很有可能是因为我陷入到一种没法去描述自己的状态。每天都有很多话想说，但是却不知道该怎么述说。\n我常常在深夜里盖上被子之后才想起许多乱七八糟的事情，诸如弄的一团糟的自己，仍未可知的未来，潜藏在记忆里的某些过去。\n我想忘记这一切沉沉睡去，可是那些东西攫住了我，我明白我终有一天会被它们追上，就像我不可能一辈子躲在自己的梦里。\n这个时候的我有着最多的感触，可是我不可能从床上爬起来记下。我只能任由这些稍纵即逝的念想烂在脑子里。\n我不得不用一些其他的东西麻醉自己，比如整天宅在家里，刷视频，打游戏。\n我感到我不喜欢这样。\n可是到头来我发现我不知道自己喜欢什么。对很多事情的热爱在渐渐地消耗，直到不再能给我带来快乐。\n或许我只是需要有人陪我度过这样寂寞的时光。有时我会一遍一遍地刷新着手机列表，只是希望有人能和自己说句话。\n当我放下手机的时候我总是怅然若失，因为一天就那样过去了，而我又什么都没有做。\n“世界是一个草台班子。”\n这是我的语文老师告诉我的话，我一直把这句话记在心里。\n当我目睹我所不能理解的现象，感慨于人性的滑稽、荒谬与疯狂时，我总会想起这句话。\n毕竟所有人都只是在表演而已，生活就是一场蹩脚透顶的表演，演员们乱哄哄地争抢的，不过是登台亮相的机会，在耀眼炫目的灯光下，露出自以为美丽的鬼脸。\n而我也只是在表演而已。\n我所想要的早已不是什么理想。建设一个美好的世界的愿望，我也曾坚定的相信过，可是在许多事情后我终于明白，这个世界的运作比我想象的复杂得多，也荒谬的多。我只想在这样的现代丛林里活下去，活下去，仅此而已。\n我所有的动力不过是恐惧。因为我知道那个笨拙的自己需要比别人更加拼命才能活下去。我不仅为现在的自己而表演，也为了让未来的自己不被击垮而表演。\n我表 …","date":"2024-02-23 20:27:27","updated":"2024-02-23 20:27:27"},{"objectID":"7283fd7ba6cacc2bc50548a279841c2f1f2550c5","permalink":"/post/somniloquy-7/","title":"梦呓（七）—— 唯一需要拯救的人","content":"君の神様になりたい(想成为你的神明大人) - こはならむ\n我曾经有那样的冲动，去靠近另一个人。\n幻想过彻底理解另一个人。\n幻想过去拯救另一个人。\n幻想过不顾一切超越所有的爱。\n后来我明白了，我在幻想中投射的，是自己的渴望。那个渴望着拯救需要着拯救的人不是别人啊，正是幻想着去拯救的自己。\n人常常会将自己所缺失的东西，投射到他人身上。缺乏自我的人，就会将自我投射到他人身上。\n因此渴望被温柔对待的人，也渴望着温柔对待他人；渴望被理解的人，也渴望去理解他人；渴望着拯救的人，也渴望拯救他人。\n只是大部分人一辈子也碰不到能够且愿意拯救自己的人。这样的人或许真实存在，只是太少了而已。\n而倘若连自己的缺陷都无法填满，又有什么力量去拯救他人呢？\n那个唯一需要拯救的人，是自己啊。\n当意识到不再会有他人来拯救自己时，或许就要学会变得坚强吧。\n即使伤痕会让你寸步难行，即使狂风会让你睁不开眼，渴望逃回内心的黑暗之中。\n即使再讨厌自己沉沦挣扎的模样，也终究要学会去爱自己，学会不再对抗自己的情绪，像试图在冰天雪地中保持温度那样拥抱自己。\n即使感受不到生命的意义……那就去感受生命的每一刻，感受呼吸和心跳，感受存在——那就是生命的诠释。\n其实很多时候自己都做不到吧，虽然很努力去做了已经……可是还是难以避免地感到痛苦。自我的缺陷，靠自己还是难以修补的吧。\n还是不自觉地会渴望有人抱紧自己……\n还是希望明天永远不要到来……\n即使带着无力感，生活依然会继续吧。\n即使再怎么讨厌，也无法不在意自己吧。\n于是我就在这样，亦醉亦醒地等待着明天。\n","date":"2024-01-15 20:26:57","updated":"2024-01-15 20:26:57"},{"objectID":"676dc9e958e1d66ce85398ebfa304f63af141665","permalink":"/post/somniloquy-6/","title":"梦呓（六）","content":"Rendezvous - Vivienne\n我大致是理解了自我的含义吧，所以不会再如此在意别人的眼光。\n所以当领导当着我的面PUA我时，我也不过是面无表情地回个“是”，等他抖完自己的威风走人后暗骂两句傻逼。\n搞行政的本事我也见识过了，纯粹看不得人好，鸡蛋里挑出骨头来，没有挑不了的刺。\n所以以前挨顿批评我还诚惶诚恐地反思自己到底有哪些错误，是不是不够努力，心里不舒服还得愧疚一下态度是不是不端正。\n现在我明白我其实不必去在意的。我只需要关注那些真正重要的，真正能影响我的事情。我不需要伪装得完美无缺，什么都行在他人眼里就是什么都不行。\n至于别人会觉得我变坏，变差还是怎么样，与我无关。反正再过一个月，我也不归这群人管了……\n希望在网安能学到点真正有用的东西。\n乖孩子是没有出路的，听话对个人来说是最无用的一种品质。\n只有真正的成绩与实力才能让人学会尊重。\n好比大学里真正让我赢得名声取得荣誉表彰的从来不是我什么遵守规矩，服从命令（我当然不会否认这点）。是我把ICPC和CCPC的Cu、美赛的H奖糊到他们脸上换来的，是我和各大高校的学生在竞赛场上真刀真枪地拼出来的（什么玩意，写完我自己都想笑）。\n虽然在竞赛圈子里我自知水平菜的扣脚，但是这些足以把不知内情的人吓住了。谁叫一个蓝桥杯国二和ICPC分站赛的Ag在这个学校是一个级别的奖呢\n唯有具备实力，才能有谈判的筹码。\n所以我开始明白，什么才是对我真正的好，而什么算作PUA。\n那些帮助你提高自己的能力，补充自己的不足，激励前进的动力，都是真正对你好的人。\n那些就是要你乖乖听从他们，希望你自愿地任劳任怨当牛做马，一辈子跪在地上起不来，那是在试图控制与利用你。\n对谁有好处，那并不是很难分辨的，只是不要被任何一种叙事所蒙蔽。\n怀着私心的人不可听从，却可以交易。各取所需，双赢也可以是最好的结局。\n其实我觉得科研人员大概是世界上最好管的一群人了。\n他们从来都没有太多要求，给一个舒适但不需要太奢侈的生活条件（说难听点就是小资产阶级的生活条件），研究设备跟得上，然后给予他们充分的自由，不要有人定计划催进度，不搞奇怪的规定折腾他们，他们就会自己投入到科研中并从中获得精神满足，做出科研成果来回报还很丰厚。无论是政治、经济还是社会上都没有更高的需求了。\n回头看看国内科研环境，不得不叹一口气。\n所以说真别折腾他们了。\n说了半天胡话，归根结底就是想说，求求也别 …","date":"2024-01-08 20:05:09","updated":"2024-01-08 20:05:09"},{"objectID":"fc79da07bc83d473462732c83c2b2a5fe6e01395","permalink":"/post/the-end-of-2023/","title":"生命里一个如此寻常的日子","content":"不思議の国のアリス（不可思议之国的爱丽丝）\n这样的一个寻常的日子，和日历上一年的最后一天相重合，或许只是一个美丽的巧合吧。\n人类制定的历法总会让自己产生一种错觉，以为迈过了这样特殊的一天，一切就会发生改变，就像老树上会抽出新的枝芽，而旧时代的灰尘终会随冬天的风离去。\n但是，所谓的新的一天只是想象罢了。\n因为历法的本质即是循环。\n当新的一年开始时我们何尝不是在重复曾经的时光。像昨日那样地欢笑，像昨日那样地哭泣。\n不过，难得会有这样的日子，所有人毫不吝惜自己的互相祝福，每个人都对明天充满如此美好的祝愿。\n在已经失去了很久的信仰之后，即使仅仅是置身其中，也会被深深感染，\n今夜对未来，对明天的一切幻想皆是合法的，而我则不由自主地沉醉其中。\n一年到底的时候理论上该写点总结的。但是我写不出东西来。\n大概是没有真正获得什么吧。很遗憾这一年没有变得更有智慧一点，没有变得更坚强一点，也没有找到能够填补自己身上的空洞的东西。\n大概也没有失去什么吧，虽然也没有什么可以失去的了。\n也许不需要更多的收获，背负起生命的重量，活着本身就足够伟大。\n我意识到的是我终究不可能寻找到填补自我的外物了，就像锁在鞋盒里的人等待着一场入室抢劫般的爱情一样无望。\n但起码，我依然可以在无人听见的角落轻声吟唱童年的歌谣，那是一个理想主义者最后的梦境。\n或者是带着微笑拥抱那样的自己，不再去试图审视和肢解，不再去把自我拆开寻找其中的毛病。那是不必要的，活着即是最好的证明。\n如果让我划出今年的关键词的话，我想大概是“自我”。\n自我的不完整性让我产生对被爱的渴望。\n在渴望被爱的同时，也在不停地否定自我。\n而之所以我会相信不会有人来爱自己，是因为我没有爱过自己。\n我希望有人能够去爱那个不完整的、破碎的、掩埋着深深的黑暗的自己，可是自己却何尝接纳过自己这样的部分？\n那便是我迫切需要去学会的东西。\n我不想对来年抱有更多的希冀。\n因为我明白，祈祷改变不了什么。虚无的世间，神明早已陨落。生命的苦难依然在延续，幻灭的花朵随处绽放。\n但是我还是有想要说的话，\n怀着坚定的自我认真地活下去，\n这是我对明天最诚挚的祝愿。\n","date":"2023-12-31 22:01:29","updated":"2023-12-31 22:01:29"},{"objectID":"2a5efd2106cbecdb2f02a7aa4f1add2652a36107","permalink":"/post/somniloquy-5/","title":"梦呓（五）—— 风穿过胸膛的声音","content":"某一天我竟会对批评与指责毫无触动。\n那并不是我足够坚强去面对这样的批评，而是我早已混乱不堪，已经没有办法去思考，去在意了。\n我知道我太容易把别人眼里轻如鸿毛的事情看得太重了，也许没有人会记着我犯过什么错，没有人在意我的行为是否正确，在他人眼里我大概只是一个模糊的影像——就像是路边匆匆的行人。\n可是我会把一句话看的很重，因为我知道言语的分量，并非来自于它本身，而是藏在言语背后的人身上。\n我会反反复复的纠结，在某件很小很小的事情上，在某句不经意的言语上。\n我自己清楚这样做的原因，来自很久很久以前。人永远会以曾经那个孩子的姿态活着。\n即使已经没有什么可以剥夺，却依然恐惧着被剥夺。\n即使感受不到生命的意义，仍旧拼命地试图生存。\n直到我感到自己无可救药，直到我将自己的生命看作是一个彻头彻尾的悲剧，我用无尽的悲哀将自己的脆弱贯穿，然后躺下来听风穿过胸膛的声音。\n那一刻我不再痛苦，我只感受到生命悲剧性的美。\n然而当这样的感受过去之后我还是不得不像从前一样活着，像从前一样恐慌，像从前一样感受压抑和麻木。\n因为比幻想更不幸的事就是幻想和现实重叠。\n就像我那在想象里被冻僵的生命，终于迎来了漫天的大雪。\n我希望身边的一切可以消失，但是当我真的远离人群的时候，我又会感到彻骨的寂寞。\n矛盾吗？也许不矛盾。大概真正的答案是，站在人群中，一样会感到寂寞。\n就像将自己的事项填的满满当当，和什么都不做，或许也没有分别。\n因为即使沉重的负担压得我喘不过气，我依然会感到彻底的虚无。\n走在路上的时候我开始思考什么是命运。\n命运大概就是这样一种东西，当我打开今天的新闻时发现与昨天别无二致时，当我走在路上发现今天与昨天竟是如此相似时，当我三年前开始记日记时就意识到我会这样一直挣扎下去时，命运或许就是生活的准静态。\n这个社会的运行规律是如此复杂，以至于不可能完全透彻地去看清。而这样复杂的系统居然能保持平衡而毫无起色，只能称之为奇妙。\n所以不管看几次新闻，巴以冲突都不会在某一天突然结束，也不会有外星飞碟突然降临把我抓走，更不可能突然出现一个善解人意通情达理的女孩了解我的一切然后不顾一切地爱上我。\n而当我意识到的这一切时候，我突然发现我能改变的东西很少很少。\n所以请允许我在渺小的生命中，被自己突入其来的悲伤所压倒，躲藏进自己仅有的幻想中，\n然后抚摸着自己胸口上的空洞，倾听风吹过自己胸膛的声音。\n","date":"2023-12-23 23:16:48","updated":"2023-12-23 23:16:48"},{"objectID":"fb5715c3bde5688b4138c6009176148f2e3507f1","permalink":"/post/the-dual-self-of-disgust-and-nostalgia/","title":"梦呓（四）—— 厌弃与怀念的双重自我","content":"在路边看见同学了。\n想打招呼时发不出声音，挥手没看见 。\n车就这样开走了。\n本来想在群里调侃一下TA怎么没看见我，突然意识到当时自己为什么发不出声音，\n原来是在做梦。\n突然有种莫名的惆怅。\n如果说有什么令我感到恐惧的话，那就是当一觉醒来我发现自己和昨天并没有什么变化。\n没有变得更强大，更有智慧一点。\n没有理解一点新的知识。\n仿佛停滞了一般。\n我的感慨是昨日的感慨，忧伤是昨日的忧伤，我过的每一天和昨天没什么两样。\n昨天和前天又没什么两样。\n如果地球停止转动，那么我大可坐下来欣赏岁月静好。\n可是生活对人的要求不会因为人的彷徨而停下脚步，这条线只会越来越高。\n直到来自内心的恐惧，将我们彻底压垮。\n我的身上带有太多过去的影子。\n按理说这是正常的，人就是过往记忆与经历的延续，这构成自我的同一性。\n只是那身后过去的形象让我厌弃，让我不顾一切地想与之切割，分离。而又无力地意识到，我不可能与之分离。用自己的东西塑造的自我，不可能摆脱过往的气息。\n可我为什么会怀念？明明记忆中的岁月是如此支离破碎，刻满深深的划痕。明明当时的自己，在哭号着想要逃离，在挣扎着期待着明天。\n是当下的自己，更令人厌弃吧。\n是这样的自己，既无法承认自己的能力触碰到了障壁，又不能奋力一击，去打碎这层困住自己的膜。\n只能在曾经的记忆里寻找还能发出一丝微光的碎片，抱在胸口试图感受它的温度。\n如果说现在的自己，和曾经的自己，都令我感到厌弃。\n那么我怀念的究竟是谁？\n难道幻想中从不存在的自己吗？\n也许是怀念某一段时间，在意不到他人眼神的自己。\n想要学会去爱自己，是如此难以做到，比爱他人更难以做到。\n但愿我可以做到。\n","date":"2023-12-19 20:17:45","updated":"2023-12-19 20:17:45"},{"objectID":"1855a789933455622cc38d41ec24dc5f91046d64","permalink":"/post/defect-and-self-redemption/","title":"缺陷与自我救赎","content":"ソラゴト（虚言） - 明透\n很巧在今天刷到了这首歌，\n众所周知Shy对歌词和旋律要求同时很高，很久没有遇到过如此完美契合的歌曲了。\n几乎可以算做近段心路历程的一个写照。\n最近很长一段时间，我都处于精神危机之中。\n通过这几年的观察我大概了解自己的心理状态，隔几个月就会陷入一个的低谷期。\n具体的表现上一篇梦呓已经表现的差不多了。\n从哲学角度出发所作的尝试基本失败，所以我尝试从心理学上去进行自救。\n也是很凑巧我刷到了知乎上朱慈的回答，对我帮助很大。\n缺陷是会欺骗人的，它会引导你去汲取你所缺失的部分，它会给你描绘那样不存在的美好和幸福。\n它会虚构出能够完全补全自己的契机，并使你坚信以这样的方式才能够得到感知生命的力量。\n我所感受到的压抑，本质上来自于内心的缺陷，安全感的缺乏。如果要追寻根源的话，并不是说我有什么足以留下阴影的惨痛经历。这是一个长期的环境所导致的，其中的缘由太过琐碎，以至于我不想在此费尽心思去解释。\n因为缺陷的存在，所以寻求外物去补足，从此衍生出渴望。\n这也就解释了，我为什么如此追求他人的理解，为什么以一种偏执的状态渴望着病态的亲密关系，为什么会将幻想中的爱神化，为什么会总是选择逃避，不断地逃避。\n可是我没有意识到的是内心的缺陷是不可能被外物填补的。\n就像一团雪堵住胸口的窟窿，可当雪化开时，身体依旧千疮百孔。\n能填补它的只有自我，只有存在于真实中的自我。\nずっと痺れてるから\n因为一直在自我麻痹\n淡い光に欺かれる\n才会被微小的希望所欺骗\n在我寂寞到窒息的那段时间里我等待着来自他人的赠予，等待着爱的降临。\n但如今我明白了，我最先需要爱的是自己。\n因为不懂得自我接纳，自我和解与自我保护，所以一直在贬低自我价值。\n当我说着害怕被抛弃的时候，我难道不是将自己物化了吗？\n这个世界上只有具有归属性的物品才会被抛弃。\n而人与人之间的联系，从来没有被抛弃这样的概念。\n我想我所能够和应该做的，是用属于自己的事物重塑自我，而不是他人的支撑，这样的自我才不会因抽离而崩塌。\n带着这样的自我奔跑于旷野之上，带着污秽与伤痕。\n即使丑陋又怎么样呢？人总是喜欢美化自己模样，可与其在虚幻的想象中迷失与躲藏，不如去触碰脚下坚实的土壤。\n不再试图去用渺小的个体与宏大的叙事进行对抗，不再一遍又一遍试图以拆解自我来完成拯救，放弃那无谓的自我否定。\n不必去重复虚假的祈祷，不必去渴求神明的拯救。\n以真实的自 …","date":"2023-12-17 22:41:15","updated":"2023-12-17 22:41:15"},{"objectID":"b91c5b15b9a64bad4b3618efadc974e3044a89ea","permalink":"/post/song-sheet/","title":"歌单","content":"Shy鉴定好歌的标准有两种，一种是听着舒服，一种是听着难受。\n放上一些感受很深的曲子，可能会附上一些乐评。\n（建议倒序阅读）\n（12.14）我刚刚试了一下，这个页面上的所有歌曲可以同时播放，效果炸裂（\n（12.16）如果当天有文章写的话，日推有可能会直接放文章里作BGM（\n12.14 逸脱者達の無礙光　〜 Kingdam of Nothingness.(越轨者们的无碍光　～ Kingdom of Nothingness.)\n核心旋律只有四句，但是足以封神。\n人声我倒没有很注意。但是那种略带忧伤却说不清什么样的感受一直难以散去。\n大概这就是虚无感吧，恰到好处的点了题。\n其实我看到残无这个名字时我大概就猜到ZUN想要写什么样的东西了。\n信仰的坍塌，权力的争斗，市场的崩溃，利益的角逐，一切主题最终导向的是虚无，Kingdom of Nothingness.\n为什么我现在看的所有作品都会最终导向这个主题呢？\nZUN大概已经不是我熟悉的老酒鬼了（笑）。\n12.13 あの賑やかな市場は今どこに　～ Immemorial Marketeers（熙攘市场今何在　～ Immemorial Marketeers）\nZUN表达主旨的方式总是那么直白，就是全都写在题目上。\n可以和寄世界作一个对比。从乐器的音色上和寄世界基本相同，但是传达的情感完全相反。\n寄世界的曲调走向是向上的，整体非常流畅和帅气，尽管是孤立无援的神明但是威压十足，神格拉满。\n熙攘市场整个基调非常压抑，旋律不断有向上走却被强行压住的感觉，仿佛在挣扎中悲鸣。\n和以往完全不同，以往的东方曲听着会有一点忧伤，但是主要还是小调的原因。这首曲子的感受大概和《永远的巫女》有点类似。\n03：22的钢琴堪称点睛之笔。\n（为了防止前天的惨案，我中午是挂着耳机睡的。然后下午满脑子还是这曲，二次放送了属于是）\n12.11 遊園施設 - 帆足圭吾\n评价一个游戏很重要的标准是它的音乐。\n你们很难想象这首曲子循环起来时Shy的精神状态。\n热闹的鼓点下面是难以抑制的悲凉，如同寻找却找不到希望的感觉，构造出一个被遗弃的世界，\n和游戏的内核出奇相似（好像相似才是对的吧）。\n听久了会想起很多乱七八糟的东西。\n初中的时候打undertale就一个月没缓过来。这种剧情向的游戏多来几个，精神状态估计要更不妙了。\n补:为了深入感受曲子背后所表示的内涵多循环了几次，然后……午觉睡不着了，整个中午脑子都是这个曲子。\n","date":"2023-12-11 11:06:45","updated":"2023-12-14 11:06:45"},{"objectID":"fe3071719208e16d401804daf4ae38ec1b649fca","permalink":"/post/somniloquy-3/","title":"梦呓（三）","content":"恶心，眩晕的感觉。每一天给我留下的印象仅仅如此。\n我不知道要怎么摆脱这样的感觉。\n我回想自己的一个学期做了什么，思考的结果是什么也没做。\n我不知道该做什么。\n不想听课，不想写作业，不想复习，也不想锻炼。但是除了这些我还能做些什么呢？不间断的娱乐活动让我感到反胃，生理上的反胃。\n我想要的是什么？当我问自己这样的问题时我竟找不到答案。我不知道自己为了什么在读书。我似乎从来没有为了自己在学习过，不知道自己想做什么（大概什么也不想做）。\n我知道的只有别人要求我做什么，这是我生命的唯一动力。\n我以为是他人束缚了真实的自我，事实上也许我的自我只不过一团空白，塞满了乱七八糟的东西。\n没有灵魂的机器，执行着输入的指令。\n至于想说的话，已经不懂得组织了。\n我所做的一切是为了什么呢？似乎就是为了获得他人的认可啊。我一直依靠着他人的认可去生活。\n而当我试图摆脱这样的模式时，我发现我竟然感到如此的空虚，我失去了生活的方向。我发现即使我如此唾弃这样的自己，我依然如此需要来自他人的认可。\n可是他人的认可并无法让我满足，我更加惶惶不安地恐惧着失去这样的认可。\n根本没有自我，一切都是被他人所塑造的东西。我眼中的自己只不过是他人眼里的映像。\n表演的更好一点，更加精彩一点，即使我心里清楚，那个表面下的自己已经渐渐腐朽。\n那样也必须表演下去，被世界抛弃，就意味着意义的终结。\n躺在床上的时候，就会无比渴望温暖的感觉，渴望被人抱紧的感觉。\n可是我感受不到这样的感觉，我没有办法构想出抱紧我的另一个人的脸，没法模拟出那样的温暖。\n我甚至连从前的孤独的那种纯粹的悲伤感都感受不到。\n我唯一能感受到的时来自无尽虚空的莫名焦躁。\n从前的孤独是纯粹的，闪耀的，带着诗意的美的；如今的孤独含着对自我的厌恶，对生活的恶心。\n我不得不从生活的任何一个小小的成绩中去寻找一点刺激，寻找一点让自己活下去的意义所在。\n可是这样的尝试越发徒劳。\n我很想告诉所有人我并不优秀，消耗完我仅有的一点头脑后，我一无所有，我要花很长的时间，才能完成别人轻松就能达到的事情。\n可是我不能这么做。\n我知道背负优秀的重会压垮我，可是感受不到生命意义的轻一样会压垮我，会将我压垮的更加彻底。\n我注定要成为一个自己讨厌的人。\n因为我也不知道自己喜欢成为什么样的人。\n我曾经大肆嘲讽自己从前的诗意。可是现在看来，没有诗意我根本就没有办法坚持下去。\n使我所坚持下去的并非 …","date":"2023-12-10 21:24:29","updated":"2023-12-10 21:24:29"},{"objectID":"a63a7f19525244cf8b96cc3790279cedc6cbe482","permalink":"/post/diary-fragment/","title":"手记 - 残片","content":"记忆如残片般散落。\n（二十七） 12.29 你不能在我感受自由后再去囚禁我，不能在我望见阳光后再去遮蔽我，不能在我领悟希望后再去摧毁我，不能在我感知真理后再去迷惑我，不能在我发现自我后再去否定我。\n因为当我触碰到那份美好，便再也不可能回到从前的世界。\n（读黑塞《在轮下》有感，但是其实已经是几年前读的了）\n（二十六）12.15 并非想要活着，却也不想死去。\n只是清算别人的实践可能永远比不上清算自己，而有时候解决所有矛盾的最好方式是解决自己。\n说到底其实我谁都不恨，我只是恨自己无能为力。\n就像用尽全力写下证明的我，却终究发现自己苦苦坚持的命题是一个谬误。\n所以说是我什么都没有守护好，我在一个没有希望的生活里，把自己变成了同样没有希望的样子。\n连活下来都感到困难的我，其实是没有资格去怨恨什么的。\n可是我感到自己的忍耐愈发接近极限，就像支撑我的动力正在枯竭。那是一种被所有人和事情针对的感觉。\n我不明白的是为什么所有事情都可以那么糟糕，而这样的折磨永远没有尽头。以至于当我码字停下来时脑子里还回荡着那几个想起就令人作呕的名字。\n有时我能听到身体里嘎吱作响的声音，这让我想象自己是一个齿轮传动的生锈机器。\n让机器拥有情感真是一种罪恶。\n（二十五）11.27 其实感觉自己的存在多余是正常的，因为我们活在一个相对过剩的时代。\n（二十四）10.30 昨天依旧像梦一样。\n如同从往常的生活里被硬生生剥离出了四天，回忆起来依旧有不真实的感觉。\n在山东大学也是第一次和群友线下面基了，见到了别的学校的东方社团长什么样子，虽然很社恐，但是玩的很开心，拿到了两个吧唧作纪念。\n场上也是尽力写了三道题，最后半小时本来已经没什么希望突然就灵光一现写对了，队友也是把错的代码调对了。\n于是本该打铁的场还是压着线拿了个铜。符合我赛前的预期，也是超出我赛中的预期了。\n不算什么好结局，但也说不上坏就是了。\n发现自己离开了学校这个充满压力的环境后就变得什么都不想做了……\n其实我为什么还在这里呢？我的逗留其实已经没有意义了，就像五年前的OI一样。\n我还有太多的事情要去做，只是我已经感觉不到意义的存在了，我像是在奔跑般地逃避。\n因为我无法舍弃，无法舍弃这唯一能让我感到些许意义的时刻。\n而这也该结束了。\n为什么还不结束呢？\n那如同轮回般一日又一日的重复生命并没有让我学会如何去爱，可是我已经学会了如何去恨。\n我恨每天走在路上准 …","date":"2023-11-28 08:52:25","updated":"2024-12-29 20:11:25"},{"objectID":"1a217f6b3fb474a82247d2c131263545545df700","permalink":"/post/xiangqi-01/","title":"浅析：中炮过河车互进七兵对屏风马飞右象","content":"Shy的不务正业系列。\n我记得开博客好像不是为了写这个的\n很怀念从前在贴吧写这种东西的日子，虽然那时候是货真价实的小学生\n谁还没点爱好了\n多图警告。\n炮二平五 马８进７ 马二进三 车９平８ 车一平二 卒７进１ 车二进六 马２进３ 兵七进一 中炮过河车对屏风马进7卒，每一位新手入门必定接触过的布局，是当下最流行，体系最复杂，对抗性最强的布局，是“马炮争雄”的巅峰。\n而7卒系列发展最完备的当属平炮兑车系列，也是目前公认对抗性最强的变化。\n试举一例：\n……………. 炮８平９ 车二平三 炮９退１ 兵五进一 士４进５ 兵五进一 炮９平７ 车三平四 形成经典的急进中兵变化。\n然而平炮兑车最大的问题，在于它本身变化太过复杂，对布局的记忆造成了很大的困难。\n尤其是红方是先手方，对变化有更大的掌控权，因此完全可以选择自己相对熟悉的变化，比如选择对攻性强不易掌握的急冲中兵，简明的直击中兵，左马盘河，以及起横车，五九炮等变化，事实上只需要精通其中一路变化足矣。\n然而对于黑方来说，选择平炮兑车就等于要把上述所有变化全部熟记于心，而以上内容完全足够写成一本专著来研究了。我有幸读过一本左马盘河的专题著作，厚度已经足够吓人，平炮兑车估计要来的更厚些。对于专业棋手这些都是基础，但是我们这种平时棋的没下几盘更不可能有时间研究棋谱的业余爱好者来说，确实不是一个什么很好的选择。\n前几年的时候有幸拜读过一本《象棋网络流行布局》（似乎是叫这个名字，也有可能不是这本书），里面拆解了屏风马飞右象的变化，令我印象深刻，我一直钟情于这路变化。说是流行，也确实能查到不少大师的棋谱。但事实上我在网上下棋时从来没碰见对手走出过，大抵是我段位太低所致的（也有可能是我最近全是飞相局没走过中炮的缘故），而我自己走出的在（天天象棋的）业六以下基本没有能够正确应付的。和初学孩童都知道的平炮兑车相比，感觉也可以算是一个冷门变化了。于是今天拿到这里做一个浅析，也当作个人的一个笔记。\n还是回到7卒的最初局面。\n……………. 象３进５ 第一次见这路变化的棋友肯定就要问了，这个右象飞的莫名其妙，屏风马本就有根，这象一飞反成无根马了，如果是左象，还有个平车保马的棋，可飞的右象，左马无子可保，必定受攻啊。\n这么想很正常，因为我第一次看到这个阵时也是这么想的。其中奥妙，请看后文：\n此处红方主要有两路变化，车二平三和马八进七\n（一）车二平三 车二平 …","date":"2023-11-22 09:06:54","updated":"2023-11-22 09:06:54"},{"objectID":"fb6effd4fcfbcd53665df2003695c090053178c6","permalink":"/post/somniloquy-2/","title":"梦呓（二）—— 如玻璃般破碎的过去","content":" White Memories - Foxtail-Grass Studio （原曲:信仰は儚き人間の為に）\n说再多的话也不代表我开朗，而是因为我孤独。\n写再多的字也不说明我健谈，只是压抑到说不出话。\n所谓真相、答案，我所追寻的，想要看清的东西，真的有那么重要吗？即使看清了，又能如何呢？没有改造世界的力量，即使保持清醒也不过是清醒而痛苦地随波逐流罢了。\n说到底，自己真的关心这个世界吗？自己对这个世界的态度，难道不是自身向外界的投射吗？如果不是自己感受到痛苦，又怎么会对他人的痛苦感同身受呢？\n还是不能苛求自己啊。身为人就必然会受到认知、智力、情感、道德因素的制约，不可能事事都做出完美的判断，也不可能完全抛弃自己的私心，在道德上要求纯粹和无暇。那只是一种诗意的陷阱。\n身为人就会有人的渴望。\n一 我想谈谈自己的过去。\n从小我就是一个循规蹈矩的人，我没有自己的方向（哪怕是现在我也不敢说自己有了），没有自己的理想，我只是做着我应该做的一切，读书，作业，考试。我的生命里没有一丝值得我回味的事情，我没有故意不交哪一次作业，没有逃过毕业典礼去打篮球，没有参加学校以外的任何活动，除了经常在家偷偷打游戏以外没有其他的劣迹。\n我以为这就是生活。服从，听命，直到高考成绩出来的那一刻，我就会得到一个崭新的生活。\n可悲，可笑。一晃高中三年我的认知居然一点也没有长进，对生活的理解天真了到极点。\n最遗憾的是当我回味自己的青春时发现自己根本没有青春，那个本应该热情似火的年华没留下一丝爱好，一点作品，一丝成就，什么都没留下。\n二 高二的那一年我头一次有了自己喜欢的事情，我成了一名东方众。\n其实我向来不看番也不推二游，我对ACG接受度很高但是我不怎么特意关注也不会随便入坑，只有东方是我唯一的例外，起因也很简单，疫情期间我刷网易云歌单的时候刷到了TAMUSIC的墨染樱，那仿佛前世的熟悉感和亲切感令我顿时潸然泪下，从此一发不可收拾。\n从那时候起，我为此常常和家里人吵架。太可笑了，我曾经以为自己活在一个开明的家庭里，我一直都这么认为，毕竟从来没有人逼着我写作业，上补习班，我也确实没这个必要。然而我意识到自己错了，我之所以拥有那一点自由，不过还是源于自己的成绩还不错而已。我不需要听任何辩解，事实即是如此。\n很不巧的是，我的成绩正好卡在年级的第二第三名左右，而且比较要命的是，当时整个年级都在刷题，只有一个人例外， …","date":"2023-11-21 20:13:08","updated":"2023-11-21 20:13:08"},{"objectID":"da3d77a3cca8d057a7a8c9409ab2f97acad69c41","permalink":"/post/laws-in-my-life/","title":"规律","content":"从小到大，我发现一条规律，\n我越是想要得到的东西，越是追求，越是无法得到；反而是那些我已经不在意的东西，自动地就跳到我跟前来。\n这个规律也可以有另一种表述形式：我满怀希冀，迫切地渴望的事情常常事与愿违；而在当我感到绝望的时刻，又常常绝处逢生。\n我很难理解这是为什么，这似乎是一件很可笑的事情，付出了努力却得不到回报，已经想要放弃却有意外收获。\n也许这就是命运的戏弄，也许命运就喜欢看人们在一次又一次的希望破灭中不断挣扎的模样。而这偶然的幸运不过是它为了继续观赏而抛出的小小诱惑，只是希望我再一次燃起希望，从而再一次欣赏我希望破灭的模样。\n我不想再被这样玩弄了，因此我选择了不对任何事抱任何希望。\n还有一条规律是我最近意识到的，我总会令周围的人更加不幸。\n虽然这样说有种自我为中心的味道，但是我还是不得不说，我总有这样一种感觉。从小到大，我基本没有给他人，给集体，甚至是给认识的人带来过什么幸运，身边的事总是会莫名其妙地变得很糟。\n当然不能说我夺走了属于他人的幸运，因为我也没有变得幸运，虽然也不至于非常的不幸就是了。\n只不过我虽然有自己的幸运时刻，却常常是些小幸运，而真正重要的时刻，我从来没有真正幸运过。\n也许不幸才是一种常态，是虚无在这个世界上的表现。\n","date":"2023-11-12 23:06:05","updated":"2023-11-12 23:06:05"},{"objectID":"832f5d08c49d61795041c105d74da995bc1673f4","permalink":"/post/consequentialism-in-daily-life/","title":"生活中的唯结果论","content":"起因是一件令我破防的事情。\n我在那练100米，心跳就没下来过，捂着胸口在哪里喘气。然后被说成我在哪里打哈欠……\n对的，我确实跑的很慢，但是因为这个就可以先入为主地认定我就是不好好训练吗？\n由此我想起，现在唯结果论已经逐渐渗透到人们的思想观念当中去了。本质上，这和为追求经济的高速发展，使得质效成为裁定价值的标准是密不可分的。\n虽然说不要只注重结果，应该注重过程的口号天天在喊，但是真正到实践的过程中往往滑入这样一个陷阱：以结果推断过程。单纯以过程推断结果已经是对因果联系考虑不充分的漏洞，以结果推断过程更是在逻辑上就大错特错。\n这就是拿结果评判价值产生的扭曲价值观，是唯结果论带来的恶果。\n我感到挺讽刺的一点是，小时候成绩好时，就有人觉得我拿这样的成绩就是靠聪明，根本没有用功，在背后指点着说我不够努力，诸如此类；等到大学了，遇到难以克服的障碍了，能力达不到要求了，又有人批评我不够努力。说来说去，反正都是我不够努力的问题。而且我还没法解释，话语权就在人家手里，反驳不了。想反驳，有的是办法整你。\n好比李佳琦一句“这么多年了工资涨没涨，有没有认真工作”给大伙整破防了一样，从结果反推过程就是一种混账思维，强盗逻辑。不过李佳琦错误地判断了自己手上的权力，没有弄明白自己的流量都是消费者给的，消费的权利在消费者手上，不把顾客当上帝不说，把自己当上帝起来了，如此翻车，也是自作自受。\n但不幸的是，总会有掌握了权力的人拿结果来评判你。老板对员工，上级对下级，这样的PUA比比皆是。最可怕的一点是你没有办法去反驳，没有办法去证明。\n至于某些在劝人“放下”的“砖家”“学者”“大V”们，我的评价是象牙塔里呆久了不知人间疾苦，建议出来走走亲身感受一下压迫的感觉再说话。要是这么容易就放下，怎么不人人都成佛？要是什么都不做就能吃饱饭，我乐得什么都不管。说到底还是经济基础决定的。\n从另一个角度批判唯结果论，在于对结果的评价上。\n什么是好，什么是坏？从某种意义上，社会给出的答案是效率至上，当然这个答案我今天先不展开来批判，因为这还不是最坏的，至少它还有发展生产力的那一面。可怕的是对价值的评价成为了一种话语权的争夺，而这种话语权的争夺实质就是权力斗争。从这个角度来讲，唯结果论本质上就是一种话语霸权。\n而唯结果论必然失败的原因，则是它必然导向虚无主义。\n人生的结果是什么？不论财富、地位、权力，死亡永远是人的必然宿命 …","date":"2023-11-06 19:55:02","updated":"2023-11-06 19:55:02"},{"objectID":"c92e42b96758606a295ba74838a2022211212867","permalink":"/post/ccpc-2023-harbin/","title":"CCPC哈尔滨打铁记","content":" Day -1 下飞机的那一刻我感受到了彻骨的冰凉，就像摆上了3D环绕空调一样。\n东北的风景果然大不一样，看不到山，只看见大片的原野和道路两旁整齐的落叶林。叶子全部掉光了，没有任何物体能够遮挡天空。\n我很喜欢这样的景色，长沙那黏液般潮湿的气候已经快让我抑郁了。\n晚上去了中央大街，其实也不知道这儿的景点有哪些（毕竟不是来旅游的），就按着出租车司机的推荐去了比较近的一个地方。中央大街上有很多挺有艺术性的小洋楼，满街都是俄罗斯特产店，路上可以听到喀秋莎。\n走了一会儿走到了圣索菲亚教堂，是晚上所以没开门，在外面拍了几张照。\n去松花江边走了一趟，晚上黑漆漆的看不到东西。其实看江看海什么的的自己家门口就能看，也不觉得有什么特别的。\n但是就是太冷了，羽绒服虽然很厚，但是我忘记戴帽子和围巾了，冷气直往脖子里渗。赶紧跑酒店去了，晚上真不适合出来逛街。\nDay 0 热身赛。\n比赛地点在哈工程。\n进场地看到桌上两台电脑懵了，后来发现是一个笔记本和一个显示屏。不知道笔记本是不是上一场用完拉到这儿来继续用的\n然后一看系统又是Linux，去年都是网赛用自己电脑，看来以后现场赛注定要一直用谔谔Linux了。虽然我一直觉得Linux开源是正道的光，但是轮到自己用时还是觉得很谔谔。玩树莓派玩的\n本来想像西安那一场一样找Geany的，然后发现没有，现场研究了几个软件之后还是决定用vscode，好不容易才会用。还好来热身赛了\n结果是花了快半小时研究vscode吧。开始写了，队友说A是水题，然后队友就被A卡住了。\n我看了下C，数据范围k\u0026amp;lt;=18，一眼状压，然后大概糊了一个Dijkstra预处理+状压求期望的思路，感觉不是很难。\n然后回去看B，发现每个数可以多次减于是数的顺序是无关的，只要做个二进制拆分，统计每个位1的个数总和，然后按顺序做进位就可以了。\n剩下的时间就是看队友调A。\n剩20分钟时A终于调出来了。我赶紧开B题。\n结果脑子抽了忘记进位不能只进一回得至少一直重复滚32次，然后WA了。等到我想到时比赛已经结束了。\n回到酒店再也不想出门了，太冷了。\nDay 1 正式赛。\n评价为：热身赛复现。\n开局看到B先被开了，于是讨论做B。队友写的很快，只要把结果每次乘0.5再加上下一个数就可以了。\n结果我们发现一个重要的问题，n=1e5是肯定会炸long double精度的。\n（当时为啥不用Python呢？ …","date":"2023-11-05 16:55:27","updated":"2023-11-05 16:55:27"},{"objectID":"b86430edaa17190e18dd389d85cc97ae864c16eb","permalink":"/post/somniloquy-1/","title":"梦呓（一）","content":"梦消失 ~ Lost Dream - Assaultdoor\n我曾经不止一次陷入这样的幻觉，以为自己已经足够强大，以为自己不会在意，以为自己不会受伤。\n可就像两年前那样我保护不了自己所爱的事物，如今我同样保护不了自己\n每走一步就要失去，变得更加不像自己。可是我手中抓取的转眼间化为灰烬。\n而我得到了什么呢？我得到的唯有虚无。\n它们争先恐后地从我身体的每一处渗透进来，将记忆与梦消逝而留下的空缺填充。它们取代我身体的每一个细胞灵魂的每一块碎片，直到虚无彻底地成为我的一部分——不，是我彻底地成为虚无的一部分。\n我想被真诚地对待啊，因为我总是在一次又一次的欺骗中彷徨而不知所措，因为我受够了必须隐藏自己的内心，因为我即使尝试着敞开心扉也无人在意无人理解，只会遭到冷眼和嘲讽。\n我多么希望我所度过的这两年只是一场大梦，只是我在沉睡之中编织的一种幻觉。我经历的一切带给我的认识远远胜过我在此之前学会的所有知识。\n在这场梦中我学会了太多，我学会了如何在绝望中保持平静，学会了不再对生活抱不切实际的期望，领悟了生活的本质不过是虚无而已。我解答了自己从前的困惑，从前的迷茫，因为我学会了看清矛盾的本质，我比任何时候都更加的靠近答案，也更明白自己的敌人是什么。\n可是我出不来了，我被困在这场荒谬的大梦里出不来了，困在这个社会所编织的叙事中出不来了。当我清醒的意识到这一切的时候早已来不及了，我所有的认识并不能带给我改变现实的力量，我眼睁睁看着虚无扭曲一切，撕碎每个人的意识却浑然不觉。\n而我甚至无法逃离，就像故事的角色逃不出书本那般，\n因为我早已是故事的一部分。\n","date":"2023-11-01 20:44:30","updated":"2023-11-01 20:44:30"},{"objectID":"adc35ff903bbdf642790710ec30c5028971e67c8","permalink":"/post/icpc-2023-xian/","title":"ICPC西安站游记","content":"由于CF上的补题一直没出来所以没有改题，也没写游记。\n纪念人生中第一个ACM银牌。\n挖个坑在这里，后面填。\n","date":"2023-10-23 21:24:52","updated":"2023-10-23 21:24:52"},{"objectID":"2abad1f057d51811b60b7112343c019f78e05896","permalink":"/post/field-train-flying/","title":"原野，列车与飞翔","content":"射命丸文 の「風神少女」（東方花映塚・東方文花帖）_- TAMUSIC 我踏上北去的列车。\n我望见疏落的树木，平旷的原野从窗边铺展开来。\n窗外的景物变换着，不揭示也不预示着什么。它们只是毫无目的，毫无意义地变换着。\n仿佛是在飞翔。\n原野的尽头与天空相接。\n如果说我既非脚踏于大地之上，亦非飞翔在天空之中，那我究竟在什么地方呢？\n我想我一定在列车上吧。\n我不知道我为什么对列车这个意象有着独特的偏好。\n列车是什么？\n列车是带着些许忧伤的告别。告别我们的过去，告别我们生命中短暂路过的那些美好，告别我们渴望抓取却终究从手中滑脱的哪些回忆。\n列车是什么？\n列车是怀着渴望与挣扎的启程。若非追逐属于自己的渴望，又怎会踏上这场通往未知和荆棘的旅途，即使目的地还未真正到达，便已经踏上新的追逐之路。\n列车是什么？\n列车是思念，是我们望见无数的景色正在消逝时勾起的淡淡哀伤，因为越是向前走，就变得越怀旧。当我们抛弃掉太多的东西以后，最后一个需要抛弃掉的是自己。\n飞翔是一种什么样的感觉啊？应该是轻盈的吧。可是渴望飞翔的人，那飞翔的渴望却是如此沉重啊。沉重到即使用一生去追逐，却也不可能真正地飞翔。\n沉重压垮了双翼，却也无法再次沉入大地；因为大地早已不存在了。我的双脚所及之处，每一寸土地都在坍塌下陷。\n回首望去，列车早已驶出几百公里，家的方向，已经模糊不清。\n——记于去往ICPC西安的列车上 ","date":"2023-10-21 15:29:08","updated":"2023-10-21 15:29:08"},{"objectID":"63f1c5e626579dc4962b70b5ce22f8b56dddc53f","permalink":"/post/turin-horse/","title":"都灵之马：无力拯救者的悲鸣","content":"虽然读的是纯工科但是文哲魔怔人Shy限时返场！\n因为明明读的是工科但是上了一学期各种奇奇怪怪屁用没有的文科课程的Shy养成了上课读《查拉图斯特拉如是说》的坏习惯，所以他现在变得非常的魔怔。\n查询Shy精神状态\n原来没人看啊，那我查个鬼，发电！\n前排提示：这篇文章并不是影评，虽然确实有部电影叫这个名字。\n关于尼采发疯的原因，有一个著名的故事“都灵之马”。\n对这个故事的真实性我一向持怀疑态度的，原因是它太精彩了，精彩到它应该被安排在一本小说里而不是发生在现实中。如果说尼采的人生是一本小说，那它就是最意味深长的结尾。\n（事实上老陀的《地下室手记》就有这个情节）\n但既然我们宁愿相信李白“捉月而死”，那么接受这个故事也就顺理成章了。\n因此，不妨让我仿照小说的思路，去探索一下这个故事背后的深意。\n首先是马的形象。不知为何我总是在想到都灵之马时想起自己，我不知道尼采是否有这样的感受。任劳任怨，辛勤奔波了一辈子的老马仿佛是身处社会底层的劳动人民的象征，更抽象化一些，他们是没有权力的弱者。\n而挥动手中皮鞭抽打马的主人则是剥削和压迫者，换言之，他是掌握权力的强者。他手中的皮鞭，即是对马的生杀大权。\n于是我们看到了一个奇怪的场景，那些信奉着道德，口称着怜悯的人们，面对着马遭受残酷的殴打却置若罔闻。\n而那个将道德批判得一无是处，将同情视作弱者的怯懦，宣扬强者道德、权力意志的人，他扑了上来，用自己的身体护住那饱受折磨的老马，抱着马的脖子痛哭起来。\n这是“超人”“先知”尼采不为人知的另一面。\n是我们误解尼采了吗？他的思想从来不是对所谓强者的歌颂，也无关对弱者的同情。他所批判的是虚伪的道德，将人的尊严践踏于脚下的秩序，就像来来往往路过的人们，面对马的苦难却无动于衷。\n他试图以解构宗教，解构道德，解构善良，重构一切价值，建立起人的尊严，以生命力的展现与怒放达到超人的境界。\n可尼采并不是超人。\n脱下“先知”唯一的他毕生被偏头痛折磨；求婚失败，却嘴硬说只想做朋友；在不被世人理解中过着孤独寂寞的生活，即使竭力表现得不以为意，可书中一声声的“大家理解了吗”却难掩他的落寞凄凉。\n自己的理论甚至连一匹马也无法拯救，人的尊严和意志屈从于更高的权力意志，而那成为超人的愿景在此刻成为无声的嘲讽。\n我不知道尼采看到马时想到了什么，但我想起了自己。\n马难道不想绽放自己的意志吗？当他遭受鞭笞时，难道没有奋力反抗吗？当皮鞭 …","date":"2023-10-18 21:02:33","updated":"2023-10-18 21:02:33"},{"objectID":"9aa6b35cfbed1e5295bf4f614f8955774147b2a8","permalink":"/post/when-god-is-gone/","title":"当神明死去时","content":"空虚的一天。\n课只听得了半节。不懂为什么要上那么多课。\n吃饭，上课，吃饭，睡觉，上课，吃饭，上课，睡觉。\n已经不是相似的每一天了，即使把一天折半都是对称的。\n我一向这么认为，课听不下去要么是老师的问题，要么是这门课根本没有上的必要——纯粹的浪费生命。\n只是生命大多数时候确实是拿来浪费的，除此以外没有更好的用法。\n我不知道该拿什么去支撑自己，在我每一天醒来却只渴望睡去的时候。\n我发现自己无力相信任何承诺与期许，也无处怀念自己的过往。不知道该如何站立在大地上——当大地正不断塌陷的时候。\n我如此渴望真实的依靠啊。因为我所见的无非是虚伪与丑恶，我所闻的不过是欺骗与谎言。\n还是不能像尼采所言依靠自己的生命意志，因为个体在社会的倾轧下不值一提。我没有成为超人的力量与勇气。\n当神明已经死去，我们所能相信的又是什么呢？我们为一个又一个伪神竖起新的泥像，终究低于不了虚无的侵蚀。我们以为杀死了神明，人就能成为新的神明。可是当神的信仰土崩瓦解，人的价值随即烟消云散。当文化被解构为符号，意义被消解为工具，那么仅有的存在的目的又是什么？\n爱能抵御虚无吗？也许是爱能令我们感受到自己的存在，而存在是对虚无的否定。可是这样的爱真的能够存在吗？现代人那被物化的扭曲感情，真的能够称之为“爱”吗？难道说真正的爱，只能存在于幻想之中吗？可幻想是无法撑起如此沉重的存在的啊。\n或许投入虚无才是人最终的归宿？但是在虚无中生活的姿态也是有很大不同的。如果说任由自己被功利化的社会所裹挟，随波逐流，把自私和冷漠当作正义，把麻木和顺从奉为道德，解构一切美好，用自己所谓的权力抽刀向更弱者，今天围观跳楼的人叫好，明天对着被施暴的受害者嘲笑。我拒绝成为这样的人，也永远不会试图与这样的虚无“和解”。\n当愚昧被奉为智慧，当落后被吹捧领先，当固步自封被当作稳定，当维系信仰的纽带被剪碎，当支撑信任的桥梁在坍塌。当神明已然死去的时候，\n我依然茫然地游荡在这世间，寻找着神明的遗迹，试图安放我锈蚀的灵魂。\n","date":"2023-10-08 19:39:18","updated":"2023-10-08 19:39:18"}]