<!doctype html><html lang=en data-theme-mode=auto><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title>源代码阅读项目——CheckKernelEATHook | Satori5ama</title><meta name=description content="我们称之为路的，其实不过是彷徨。"><script>window.siteConfig=JSON.parse('{"anchor_icon":null,"base":"https://username.github.io/","clipboard":{"copyright":{"count":50,"enable":false,"license_type":"by-nc-sa"},"fail":{"en":"Copy failed (ﾟ⊿ﾟ)ﾂ","ja":"コピー失敗 (ﾟ⊿ﾟ)ﾂ","pt-br":"Falha ao copiar (ﾟ⊿ﾟ)ﾂ","zh-cn":"复制失败 (ﾟ⊿ﾟ)ﾂ","zh-tw":"複製失敗 (ﾟ⊿ﾟ)ﾂ"},"success":{"en":"Copy successfully (*^▽^*)","ja":"コピー成功 (*^▽^*)","pt-br":"Copiado com sucesso (*^▽^*)","zh-cn":"复制成功 (*^▽^*)","zh-tw":"複製成功 (*^▽^*)"}},"code_block":{"expand":true},"i18n_languages":[{"Lang":"en","LanguageName":"English","LanguageCode":"","Title":"","LanguageDirection":"","Weight":1,"Disabled":false},{"Lang":"zh-cn","LanguageName":"简体中文","LanguageCode":"","Title":"","LanguageDirection":"","Weight":2,"Disabled":false},{"Lang":"zh-tw","LanguageName":"繁體中文","LanguageCode":"","Title":"","LanguageDirection":"","Weight":3,"Disabled":false},{"Lang":"ja","LanguageName":"日本語","LanguageCode":"","Title":"","LanguageDirection":"","Weight":4,"Disabled":false}],"icon_font":"4552607_4k4bc36ef96","outdate":{"daysago":180,"enable":false,"message":{"en":"This article was last updated on {time}. Please note that the content may no longer be applicable.","ja":"この記事は最終更新日：{time}。記載内容が現在有効でない可能性がありますのでご注意ください。","pt-br":"Este artigo foi atualizado pela última vez em {time}. Observe que o conteúdo pode não ser mais aplicável.","zh-cn":"本文最后更新于 {time}，请注意文中内容可能已不适用。","zh-tw":"本文最後更新於 {time}，請注意文中內容可能已不適用。"}}}')</script><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link rel=preload as=style href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap"><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Mulish:400,400italic,700,700italic%7cNoto%20Serif%20SC:400,400italic,700,700italic%7c&amp;display=swap" media=print onload='this.media="all"'><link rel=preload href=//at.alicdn.com/t/c/font_4552607_4k4bc36ef96.woff2 as=font type=font/woff2 crossorigin=anonymous><link rel=stylesheet href=/css/loader.min.ac746e154f756f8220326eeb52a719f142ab038be5a8ddf30ea5ef15ef2356ea.css><meta property="og:type" content="website"><meta property="og:title" content="源代码阅读项目——CheckKernelEATHook | Satori5ama"><meta property="og:description" content="我们称之为路的，其实不过是彷徨。"><meta property="og:url" content="https://username.github.io/post/source-code-reading-project-checkkerneleathook/"><meta property="og:site_name" content="终端出口"><meta property="og:image" content="/"><meta property="article:author" content="Satori5ama"><meta property="article:published_time" content="2025-01-08T08:52:25+08:00"><meta property="article:modified_time" content="2025-01-08T19:52:25+08:00"><meta property="article:tag" content="Security"><meta name=twitter:card content="summary"><meta name=twitter:image content="/"><link rel="shortcut icon" href=/favicon.ico><link rel=stylesheet href=/css/main.min.1ecb7ea7cc8615de8f8ca0f0fe9bef9c98fae8a032ddbd3c28b02ea46b34ee14.css><link rel=preload as=style href=https://npm.webcache.cn/photoswipe@5.4.4/dist/photoswipe.css integrity=sha384-IfxC36XL/toUyJ939C73PcgMuRzAZuIzZxE38drsmO5p6jD7ei+Zx/1oA/0l8ysE crossorigin=anonymous onload='this.onload=null,this.rel="stylesheet"'><link rel=preload as=style href=https://npm.webcache.cn/katex@0.16.24/dist/katex.min.css integrity=sha384-tTgKLjMYmJr94v8qu2PE5MUGSMbyN2xiH266JUB3gpm8vnnJywd1dWSOEfrFz+YI crossorigin=anonymous onload='this.onload=null,this.rel="stylesheet"'><script src=https://npm.webcache.cn/pace-js@1.2.4/pace.min.js integrity=sha384-k6YtvFUEIuEFBdrLKJ3YAUbBki333tj1CSUisai5Cswsg9wcLNaPzsTHDswp4Az8 crossorigin=anonymous></script><link rel=stylesheet href=https://npm.webcache.cn/@reimujs/aos@0.1.2/dist/aos.css integrity=sha384-GMRP93c6Hkz9JVKGAuRR3nTS7M07RwPgTFenXiosjq2VbVgvdDNcz1g6Mkj8AONa crossorigin=anonymous></head><body><div id=loader><div class="loading-left-bg loading-bg"></div><div class="loading-right-bg loading-bg"></div><div class=spinner-box><div class="loading-taichi rotate"><svg width="150" height="150" viewBox="0 0 1024 1024" class="icon" shape-rendering="geometricPrecision"><path d="M303.5 432a80 80 0 01-12 160 80 80 0 0112-160z" fill="var(--red-1, #ff5252)"/><path d="M512 65a447 447 0 010 894V929a417 417 0 000-834 417 417 0 000 834v30a447 447 0 010-894zm0 30A417 417 0 01929 512 208.5 208.5.0 01720.5 720.5V592a80 80 0 000-160 80 80 0 000 160V720.5A208.5 208.5.0 01512 512 208.5 208.5.0 00303.5 303.5 208.5 208.5.0 0095 512 417 417 0 01512 95z" fill="var(--red-1, #ff5252)"/></svg></div><div class=loading-word>Loading...</div></div></div></div><script>var time=null,loaderEl=document.getElementById("loader"),startLoading=()=>{time=Date.now(),loaderEl.classList.remove("loading")},hideLoader=()=>{document.body.style.overflow="auto",loader.classList.add("loading")},endLoading=()=>{time?Date.now()-time>500?(time=null,hideLoader()):(setTimeout(endLoading,500-(Date.now()-time)),time=null):hideLoader()};window.addEventListener("DOMContentLoaded",endLoading),loaderEl.addEventListener("click",endLoading)</script><div id=copy-tooltip></div><div id=lang-tooltip>This article does not have a corresponding language version</div><div id=heatmap-tooltip></div><div id=container><div id=wrap><div id=header-nav><nav id=main-nav aria-label="Primary navigation"><a class=main-nav-link-wrap href=/><div class='main-nav-icon icon rotate'>&#xe62b;</div><span class=main-nav-link>Home</span>
</a><a class=main-nav-link-wrap href=/archives><div class='main-nav-icon icon rotate'>&#xe62b;</div><span class=main-nav-link>Archives</span>
</a><a class=main-nav-link-wrap href=/about><div class='main-nav-icon icon rotate'>&#xe62b;</div><span class=main-nav-link>About</span>
</a><a class=main-nav-link-wrap href=/friend><div class='main-nav-icon icon rotate'>&#xe62b;</div><span class=main-nav-link>Friend</span>
</a><a id=main-nav-toggle class=nav-icon aria-label="Toggle navigation" role=button></a></nav><nav id=sub-nav aria-label="Secondary navigation"></nav><nav id=i18n-nav aria-label="Language selection"><div class=custom-dropdown><div class=select-selected id=select-selected role=button aria-haspopup=listbox aria-expanded=false aria-label="Language menu"><span id=nav-language-btn class=nav-icon style="padding:0 20px 0 0"></span>
<span id=selected-lang>English</span></div><ul class=select-items id=select-items role=listbox aria-label=Languages><li data-value=en role=option class=selected arial-selected=true>English</li><li data-value=zh-cn role=option arial-selected=false>简体中文</li><li data-value=zh-tw role=option arial-selected=false>繁體中文</li><li data-value=ja role=option arial-selected=false>日本語</li></ul></div><script>var selectSelected=document.getElementById("select-selected"),selectedLang=document.getElementById("selected-lang"),selectItems=document.getElementById("select-items"),selectOptions=selectItems.querySelectorAll("li");selectSelected.addEventListener("click",()=>{selectItems.classList.toggle("show");var e=selectSelected.getAttribute("aria-expanded")==="true";selectSelected.setAttribute("aria-expanded",(!e).toString())}),selectOptions.forEach(e=>{e.addEventListener("click",()=>{const t={};if(selectedLang.textContent=e.textContent,selectItems.classList.remove("show"),selectOptions.forEach(e=>{e.classList.remove("selected")}),e.classList.add("selected"),e.dataset.value==="en")return;if(!t[e.dataset.value]){_$("#lang-tooltip").style.opacity="1",setTimeout(()=>{_$("#lang-tooltip").style.opacity="0"},1e3);return}window.location=t[e.dataset.value]})}),document.addEventListener("click",e=>{e.target.closest(".custom-dropdown")||(selectItems.classList.remove("show"),selectSelected.setAttribute("aria-expanded","false"))})</script></nav><a href=https://github.com/Satori5ama class=triangle-badge title=github target=_blank rel="noopener nofollow noreferrer"><div class="icon icon-github triangle-badge-icon"></div></a></div><header id=header aria-label="Site header"><picture></picture><img fetchpriority=high src=/images/ST.webp alt=源代码阅读项目——CheckKernelEATHook><div id=header-outer><div id=header-title><span id=logo><h1 data-aos=slide-up>源代码阅读项目——CheckKernelEATHook</h1></span><h2 id=subtitle-wrap data-aos=slide-down></h2></div></div></header><div id=content aria-label="Page content" class=sidebar-right><aside id=sidebar aria-label=Sidebar><div class="sidebar-wrapper-container sticky"><div class=sidebar-wrapper><div class=sidebar-wrap data-aos=fade-up><div class=sidebar-toc-sidebar><h3 class=toc-title>Contents</h3><div class="sidebar-toc-wrapper toc-div-class"><nav id=TableOfContents><ul><li><ul><li><a href=#用户界面部分user-interface>用户界面部分（User Interface）</a></li><li><a href=#内核驱动部分kernel-driver>内核驱动部分（Kernel Driver）</a></li><li><a href=#总结>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#用户界面部分>用户界面部分</a></li><li><a href=#内核驱动部分>内核驱动部分</a></li></ul></li></ul><ul><li><a href=#11-checkkernelhookh>1.1 CheckKernelHook.h</a><ul><li><a href=#总结-1>总结</a></li></ul></li><li><a href=#12-checkkernelhookcpp>1.2 CheckKernelHook.cpp</a><ul><li><a href=#总结-2>总结</a></li></ul></li><li><a href=#13-checkkernelhookdlgh>1.3 CheckKernelHookDlg.h</a></li><li><a href=#14-checkkernelhookdlgcpp>1.4 CheckKernelHookDlg.cpp</a><ul><li><a href=#包含的头文件>包含的头文件</a></li><li><a href=#全局变量>全局变量</a></li><li><a href=#列表结构体定义>列表结构体定义</a></li><li><a href=#列表列信息初始化>列表列信息初始化</a></li><li><a href=#对话框类的实现>对话框类的实现</a></li><li><a href=#ccheckkernelhookdlg对话框类><code>CCheckKernelHookDlg</code>对话框类</a></li><li><a href=#oninitdialog-方法><code>OnInitDialog</code> 方法</a></li><li><a href=#检查内核-hook-状态>检查内核 Hook 状态</a></li><li><a href=#插入数据到列表>插入数据到列表</a></li><li><a href=#消息处理程序和绘画>消息处理程序和绘画</a></li><li><a href=#总结-3>总结</a></li></ul></li><li><a href=#15-addserviceh>1.5 AddService.h</a></li><li><a href=#16-addservicecpp>1.6 AddService.cpp</a><ul><li><a href=#1-头文件包含>1. 头文件包含</a></li><li><a href=#2-release-函数>2. Release 函数</a></li><li><a href=#3-unloaddrv-函数>3. UnloadDrv 函数</a></li><li><a href=#4-loaddrv-函数>4. LoadDrv 函数</a></li><li><a href=#总结-4>总结</a></li></ul></li><li><a href=#核心代码>核心代码</a></li></ul><ul><li><a href=#21-commonh>2.1 Common.h</a></li><li><a href=#22-commonc>2.2 Common.c</a></li><li><a href=#23-driverentry>2.3 DriverEntry</a><ul><li><a href=#1-头文件引入><strong>1. 头文件引入</strong></a></li><li><a href=#2-驱动入口函数><strong>2. 驱动入口函数 <code>DriverEntry</code></strong></a></li><li><a href=#3-设备控制函数><strong>3. 设备控制函数 <code>ControlPassThrough</code></strong></a></li><li><a href=#4-默认透传函数><strong>4. 默认透传函数 <code>DefaultPassThrough</code></strong></a></li><li><a href=#5-驱动卸载函数><strong>5. 驱动卸载函数 <code>UnloadDriver</code></strong></a></li><li><a href=#6-关键功能总结><strong>6. 关键功能总结</strong></a></li><li><a href=#7-代码总结><strong>7. 代码总结</strong></a></li></ul></li><li><a href=#24-fixrelocation>2.4 FixRelocation</a><ul><li><a href=#代码逐步分解与详细解释>代码逐步分解与详细解释</a></li><li><a href=#代码总结>代码总结</a></li></ul></li><li><a href=#25-kernelhookcheck>2.5 KernelHookCheck</a><ul><li><a href=#代码逐步分解与详细解释-1>代码逐步分解与详细解释</a></li><li><a href=#总结-5>总结</a></li></ul></li><li><a href=#26-libdasmc>2.6 libdasm.c</a><ul><li><a href=#1-文件头和相关库>1. 文件头和相关库</a></li><li><a href=#2-包含库和宏定义>2. 包含库和宏定义</a></li><li><a href=#3-字节序转换函数>3. 字节序转换函数</a></li><li><a href=#4-指令解析函数>4. 指令解析函数</a></li><li><a href=#5-操作数解析函数>5. 操作数解析函数</a></li><li><a href=#6-打印操作数字符串>6. 打印操作数字符串</a></li><li><a href=#7-获取指令函数>7. 获取指令函数</a></li><li><a href=#8-打印指令字符串>8. 打印指令字符串</a></li><li><a href=#9-辅助函数>9. 辅助函数</a></li><li><a href=#总结-6>总结</a></li></ul></li><li><a href=#27-reloadc>2.7 reload.c</a><ul><li><a href=#1-代码结构概述>1. <strong>代码结构概述</strong></a></li><li><a href=#2-全局变量>2. <strong>全局变量</strong></a></li><li><a href=#3-函数重载逻辑->3. <strong>函数重载逻辑 (<code>ReLoadNtosCALL</code>)</strong></a></li><li><a href=#4-内核模块初始化->4. <strong>内核模块初始化 (<code>ReLoadNtos</code>)</strong></a></li><li><a href=#5-安全操作模块初始化->5. <strong>安全操作模块初始化 (<code>InitSafeOperationModule</code>)</strong></a></li><li><a href=#6-ssdt修复逻辑->6. <strong>SSDT修复逻辑 (<code>FixOriginalKiServiceTable</code> 和 <code>GetOriginalKiServiceTable</code>)</strong></a></li><li><a href=#7-代码总结-1>7. <strong>代码总结</strong></a></li><li><a href=#总结-7>总结</a></li></ul></li></ul></nav></div></div><div class="sidebar-common-sidebar hidden"><div class=sidebar-author><img data-src=/avatar/avatar.webp data-sizes=auto alt=Satori5ama class=lazyload><div class=sidebar-author-name>Satori5ama</div><div class=sidebar-description>我们称之为路的，其实不过是彷徨。</div></div><div class=sidebar-state><div class=sidebar-state-article><div>Posts</div><div class=sidebar-state-number>79</div></div><a class=sidebar-state-category href=/categories/ aria-label=sidebar-state-category-link><div>Categories</div><div class=sidebar-state-number>7</div></a><a class=sidebar-state-tag href=/tags/ aria-label=sidebar-state-tag-link><div>Tags</div><div class=sidebar-state-number>26</div></a></div><div class=sidebar-social><div class="icon-github sidebar-social-icon"><a href=https://github.com/Satori5ama itemprop=url target=_blank aria-label=github rel="noopener nofollow noreferrer"></a></div></div><div class=sidebar-menu><div class=sidebar-menu-link-wrap><a class=sidebar-menu-link-dummy href=/ aria-label=Home></a><div class='sidebar-menu-icon icon rotate'>&#xe62b;</div><div class=sidebar-menu-link>Home</div></div><div class=sidebar-menu-link-wrap><a class=sidebar-menu-link-dummy href=/archives aria-label=Archives></a><div class='sidebar-menu-icon icon rotate'>&#xe62b;</div><div class=sidebar-menu-link>Archives</div></div><div class=sidebar-menu-link-wrap><a class=sidebar-menu-link-dummy href=/about aria-label=About></a><div class='sidebar-menu-icon icon rotate'>&#xe62b;</div><div class=sidebar-menu-link>About</div></div><div class=sidebar-menu-link-wrap><a class=sidebar-menu-link-dummy href=/friend aria-label=Friend></a><div class='sidebar-menu-icon icon rotate'>&#xe62b;</div><div class=sidebar-menu-link>Friend</div></div></div></div><div class=sidebar-btn-wrapper style=position:static><div class="sidebar-toc-btn current"></div><div class=sidebar-common-btn></div></div></div></div><div class=sidebar-widget></div></div></aside><section id=main aria-label="Main content"><article class="h-entry article" itemscope itemtype=https://schema.org/BlogPosting><div class=article-inner data-aos=fade-up><div class=article-meta><div class=article-date><span class="article-date-link icon-calendar" data-aos=zoom-in><time datetime="2025-01-08 08:52:25 +0800 CST" itemprop=datePublished>2025-01-08</time>
<time style=display:none id=post-update-time>2025-01-08</time></span></div><div class=article-category><a class=article-category-link href=/categories/%e7%ac%94%e8%ae%b0 data-aos=zoom-in>笔记</a></div></div><div class=hr-line></div><div class="e-content article-entry" itemprop=articleBody><p><a href=https://github.com/ciyze0101/Windows-Rootkits/tree/master>ciyze0101/Windows-Rootkits</a></p><h1 id=项目概况><a class=header-anchor href=#%e9%a1%b9%e7%9b%ae%e6%a6%82%e5%86%b5></a>项目概况</h1><div class=highlight><pre tabindex=0 class=chroma><code class=language-markdown data-lang=markdown><span class=line><span class=cl>+---CheckKernelHook
</span></span><span class=line><span class=cl>|   |   CheckKernelHook.sln
</span></span><span class=line><span class=cl>|   |
</span></span><span class=line><span class=cl>|   \---CheckKernelHook
</span></span><span class=line><span class=cl>|       |   AddService.cpp
</span></span><span class=line><span class=cl>|       |   AddService.h
</span></span><span class=line><span class=cl>|       |   CheckKernelHook.aps
</span></span><span class=line><span class=cl>|       |   CheckKernelHook.cpp
</span></span><span class=line><span class=cl>|       |   CheckKernelHook.h
</span></span><span class=line><span class=cl>|       |   CheckKernelHook.rc
</span></span><span class=line><span class=cl>|       |   CheckKernelHook.vcxproj
</span></span><span class=line><span class=cl>|       |   CheckKernelHook.vcxproj.filters
</span></span><span class=line><span class=cl>|       |   CheckKernelHookDlg.cpp
</span></span><span class=line><span class=cl>|       |   CheckKernelHookDlg.h
</span></span><span class=line><span class=cl>|       |   resource.h
</span></span><span class=line><span class=cl>|       |   stdafx.cpp
</span></span><span class=line><span class=cl>|       |   stdafx.h
</span></span><span class=line><span class=cl>|       |   targetver.h
</span></span><span class=line><span class=cl>|       |   tempCodeRunnerFile.cpp
</span></span><span class=line><span class=cl>|       |
</span></span><span class=line><span class=cl>|       \---res
</span></span><span class=line><span class=cl>|               CheckKernelHook.ico
</span></span><span class=line><span class=cl>|               CheckKernelHook.rc2
</span></span><span class=line><span class=cl>|               ReadMe.txt
</span></span><span class=line><span class=cl>|
</span></span><span class=line><span class=cl>\---CheckKernelHookDrv
</span></span><span class=line><span class=cl>    |   CheckKernelHook.sln
</span></span><span class=line><span class=cl>    |
</span></span><span class=line><span class=cl>    \---CheckKernelHook
</span></span><span class=line><span class=cl>            CheckKernelHook.vcxproj
</span></span><span class=line><span class=cl>            CheckKernelHook.vcxproj.filters
</span></span><span class=line><span class=cl>            Common.c
</span></span><span class=line><span class=cl>            Common.h
</span></span><span class=line><span class=cl>            DriverEntry.c
</span></span><span class=line><span class=cl>            DriverEntry.h
</span></span><span class=line><span class=cl>            FileSystem.c
</span></span><span class=line><span class=cl>            FileSystem.h
</span></span><span class=line><span class=cl>            FixRelocation.c
</span></span><span class=line><span class=cl>            FixRelocation.h
</span></span><span class=line><span class=cl>            KernelHookCheck.c
</span></span><span class=line><span class=cl>            KernelHookCheck.h
</span></span><span class=line><span class=cl>            KernelReload.c
</span></span><span class=line><span class=cl>            KernelReload.h
</span></span><span class=line><span class=cl>            libdasm.c
</span></span><span class=line><span class=cl>            libdasm.h
</span></span><span class=line><span class=cl>            ReadMe.txt
</span></span><span class=line><span class=cl>            Reload.c
</span></span><span class=line><span class=cl>            Reload.h
</span></span><span class=line><span class=cl>            sources
</span></span><span class=line><span class=cl>            tables.h
</span></span></code></pre></div><p>该项目是一个用于检测和管理Windows内核钩子（Kernel Hooks）的应用程序，主要包括用户界面部分和内核驱动部分。</p><h3 id=用户界面部分user-interface><a class=header-anchor href=#%e7%94%a8%e6%88%b7%e7%95%8c%e9%9d%a2%e9%83%a8%e5%88%86user-interface></a>用户界面部分（User Interface）</h3><h4 id=1-checkkernelhook-应用程序><a class=header-anchor href=#1-checkkernelhook-%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f></a>1. CheckKernelHook 应用程序</h4><ul><li><strong>功能</strong>：提供一个图形用户界面，用于检测和显示内核钩子信息。</li><li><strong>组成</strong>：<ul><li><strong>CheckKernelHook.h/cpp</strong>：定义和实现应用程序的主类<code>CCheckKernelHookApp</code>，负责应用程序的初始化和消息处理。</li><li><strong>CheckKernelHookDlg.h/cpp</strong>：定义和实现主对话框类<code>CCheckKernelHookDlg</code>，用于显示检测到的内核钩子信息，并提供用户交互界面。</li><li><strong>AddService.h/cpp</strong>：提供驱动程序的加载和卸载功能，包括创建新的驱动文件、加载和卸载指定的驱动程序。</li></ul></li></ul><h4 id=2-功能实现><a class=header-anchor href=#2-%e5%8a%9f%e8%83%bd%e5%ae%9e%e7%8e%b0></a>2. 功能实现</h4><ul><li><strong>检测内核钩子</strong>：通过与内核驱动程序通信，获取系统中存在的钩子信息，并在对话框中以列表形式展示。</li><li><strong>驱动程序管理</strong>：提供驱动程序的加载和卸载功能，方便对驱动程序进行维护和更新。</li></ul><h3 id=内核驱动部分kernel-driver><a class=header-anchor href=#%e5%86%85%e6%a0%b8%e9%a9%b1%e5%8a%a8%e9%83%a8%e5%88%86kernel-driver></a>内核驱动部分（Kernel Driver）</h3><h4 id=1-checkkernelhookdrv-驱动程序><a class=header-anchor href=#1-checkkernelhookdrv-%e9%a9%b1%e5%8a%a8%e7%a8%8b%e5%ba%8f></a>1. CheckKernelHookDrv 驱动程序</h4><ul><li><strong>功能</strong>：在内核模式下检测内核钩子，并提供与用户界面通信的接口。</li><li><strong>组成</strong>：<ul><li><strong>Common.h/c</strong>：定义和实现一些通用的内核操作函数，如操作码解析、文件映射、函数长度计算等。</li><li><strong>DriverEntry.c</strong>：定义驱动程序的入口函数<code>DriverEntry</code>，负责驱动程序的初始化和卸载。</li><li><strong>FixRelocation.c</strong>：实现PE文件重定位表的修复功能，确保程序在加载到新的基地址时能够正确运行。</li><li><strong>KernelHookCheck.c</strong>：实现内核钩子检测的核心逻辑，包括获取系统内核模块信息、修复导入表、加载PE文件等。</li><li><strong>libdasm.c</strong>：实现x86反汇编功能，将机器码转换为可读的汇编语言指令。</li><li><strong>reload.c</strong>：实现内核模块的重载和SSDT表的修复功能，确保内核函数的调用是安全的、未被篡改的。</li></ul></li></ul><h4 id=2-功能实现-1><a class=header-anchor href=#2-%e5%8a%9f%e8%83%bd%e5%ae%9e%e7%8e%b0-1></a>2. 功能实现</h4><ul><li><strong>内核钩子检测</strong>：通过分析内核模块和系统服务描述符表（SSDT），检测内核中存在的钩子行为。</li><li><strong>内核模块重载</strong>：加载并重载内核模块，修复SSDT表中的函数地址，确保内核函数的调用安全性。</li><li><strong>与用户界面通信</strong>：通过设备I/O控制码与用户界面进行通信，提供检测到的内核钩子信息。</li></ul><h3 id=总结><a class=header-anchor href=#%e6%80%bb%e7%bb%93></a>总结</h3><p>该项目通过用户界面和内核驱动的协同工作，实现了对Windows内核钩子的检测和管理。用户界面部分负责提供用户交互界面和驱动程序管理功能，而内核驱动部分则负责在内核模式下进行钩子检测、模块重载和SSDT修复等核心操作。整体上，该项目能够有效地检测和管理内核钩子，有助于提高系统的安全性和稳定性。</p><h1 id=主要函数><a class=header-anchor href=#%e4%b8%bb%e8%a6%81%e5%87%bd%e6%95%b0></a>主要函数</h1><h3 id=用户界面部分><a class=header-anchor href=#%e7%94%a8%e6%88%b7%e7%95%8c%e9%9d%a2%e9%83%a8%e5%88%86></a>用户界面部分</h3><h4 id=checkkernelhookh><a class=header-anchor href=#checkkernelhookh></a>CheckKernelHook.h</h4><ul><li><strong>函数</strong>：<ul><li><code>CCheckKernelHookApp()</code>：构造函数，用于初始化应用程序实例。</li><li><code>InitInstance()</code>：重写自<code>CWinApp</code>的虚方法，负责应用程序的初始化工作，如创建主窗口。</li></ul></li><li><strong>功能</strong>：定义Windows MFC应用程序的主类<code>CCheckKernelHookApp</code>，设置应用程序的基本框架，包括必要的头文件引用、资源文件引用以及应用程序的初始化和消息处理机制.</li></ul><h4 id=checkkernelhookcpp><a class=header-anchor href=#checkkernelhookcpp></a>CheckKernelHook.cpp</h4><ul><li><strong>函数</strong>：<ul><li><code>BEGIN_MESSAGE_MAP()</code>和<code>END_MESSAGE_MAP()</code>：定义消息映射，将命令与相应的处理函数关联。</li><li><code>CCheckKernelHookApp::CCheckKernelHookApp()</code>：构造函数实现，设置应用程序支持重新启动管理器的标志。</li><li><code>InitInstance()</code>：应用程序初始化函数的实现，包括公共控件的初始化、Shell管理器的创建、注册表设置、对话框的创建与显示以及应用程序退出的处理。</li></ul></li><li><strong>功能</strong>：实现Windows应用程序的初始化、环境设置、对话框管理和用户交互处理，提供一个可以与用户进行互动的简单界面.</li></ul><h4 id=checkkernelhookdlgh><a class=header-anchor href=#checkkernelhookdlgh></a>CheckKernelHookDlg.h</h4><ul><li><strong>函数</strong>：<ul><li><code>CCheckKernelHookDlg()</code>：构造函数，用于创建对话框对象。</li><li><code>DoDataExchange()</code>：用于对话框数据交换的函数。</li><li><code>OpenDevice()</code>：用于打开设备的函数，返回设备句柄。</li><li><code>CheckKernelHook()</code>：用于检查内核钩子的函数。</li><li><code>InsertDataToList()</code>：用于将钩子信息插入到列表中的函数。</li><li><code>OnInitDialog()</code>：对话框初始化函数。</li><li><code>OnSysCommand()</code>：处理系统命令的函数。</li><li><code>OnPaint()</code>：处理绘图的函数。</li><li><code>OnQueryDragIcon()</code>：返回对话框图标的函数.</li></ul></li><li><strong>功能</strong>：定义用于检查内核钩子的对话框类<code>CCheckKernelHookDlg</code>，实现对话框的创建、初始化、数据交换、设备通信、钩子检测、信息展示以及界面绘制等功能，为用户提供一个直观的钩子检测界面.</li></ul><h4 id=checkkernelhookdlgcpp><a class=header-anchor href=#checkkernelhookdlgcpp></a>CheckKernelHookDlg.cpp</h4><ul><li><strong>函数</strong>：<ul><li><code>CAboutDlg</code>类的相关函数：用于处理“关于”对话框的显示。</li><li><code>CCheckKernelHookDlg</code>类的构造函数、数据交换函数、初始化函数、系统命令处理函数、绘图函数和图标查询函数的实现。</li><li><code>CheckKernelHook()</code>：检查内核钩子状态的实现，向驱动程序发送IO控制请求，获取钩子信息。</li><li><code>InsertDataToList()</code>：将钩子信息插入到列表控件的实现，提取数据并填充到对话框的列表中.</li></ul></li><li><strong>功能</strong>：实现对话框类的具体功能，包括对话框的创建和显示、与驱动程序的通信、钩子信息的获取和展示，以及用户界面的交互和绘制.</li></ul><h4 id=addserviceh><a class=header-anchor href=#addserviceh></a>AddService.h</h4><ul><li><strong>函数</strong>：<ul><li><code>Release()</code>：释放相关资源的函数。</li><li><code>UnloadDrv()</code>：卸载指定驱动程序的函数。</li><li><code>LoadDrv()</code>：加载指定驱动程序的函数.</li></ul></li><li><strong>功能</strong>：提供驱动程序的管理接口，包括资源释放、驱动卸载和驱动加载，为驱动程序的维护和更新提供支持.</li></ul><h4 id=addservicecpp><a class=header-anchor href=#addservicecpp></a>AddService.cpp</h4><ul><li><strong>函数</strong>：<ul><li><code>Release()</code>：实现释放资源并创建新的驱动文件的功能。</li><li><code>UnloadDrv()</code>：实现卸载指定驱动程序的功能，包括打开服务控制管理器、打开服务、停止和删除服务等步骤。</li><li><code>LoadDrv()</code>：实现加载指定驱动程序的功能，包括卸载已存在的同名驱动、获取驱动程序的完整路径、打开服务控制管理器、创建和启动服务等步骤.</li></ul></li><li><strong>功能</strong>：实现对Windows驱动程序的管理，包括创建、加载和卸载驱动程序，确保驱动程序的正常运行和更新.</li></ul><h3 id=内核驱动部分><a class=header-anchor href=#%e5%86%85%e6%a0%b8%e9%a9%b1%e5%8a%a8%e9%83%a8%e5%88%86></a>内核驱动部分</h3><h4 id=commonh><a class=header-anchor href=#commonh></a>Common.h</h4><ul><li><strong>函数</strong>：<ul><li><code>RtlImageNtHeader()</code>：获取可执行映像文件的NT头信息的函数。</li><li><code>MapFileInUserSpace()</code>：将指定文件映射到指定进程的用户空间中的函数。</li><li><code>GetSSDTApiFunctionIndexFromNtdll()</code>：从ntdll.dll中获取特定的SSDT API函数索引的函数。</li><li><code>IsAddressInSystem()</code>：检查给定地址是否属于系统模块的函数。</li><li><code>GetFunctionCodeSize()</code>：获取特定函数的代码大小的函数。</li><li><code>SizeOfCode()</code>：计算给定代码的大小并识别操作码的函数.</li></ul></li><li><strong>功能</strong>：为内核驱动开发提供基本的工具和接口，包括信息获取、内存映射、函数代码分析等，便于处理不同的进程、文件和系统服务.</li></ul><h4 id=commonc><a class=header-anchor href=#commonc></a>Common.c</h4><ul><li><strong>函数</strong>：<ul><li><code>MapFileInUserSpace()</code>：实现将文件映射到用户空间的功能，包括创建文件句柄、创建文件映射区域、映射到进程地址空间等步骤。</li><li><code>GetFunctionCodeSize()</code>：实现计算函数代码大小的功能，通过循环分析指令并调用<code>SizeOfCode()</code>函数获取各指令长度.</li><li><code>SizeOfCode()</code>：实现计算代码段大小的功能，通过分析操作数标志位来适应不同类型的数据操作.</li><li><code>IsAddressInSystem()</code>：实现检查地址是否在系统模块中的功能，包括查询模块信息、分配内存获取模块列表、遍历模块查找地址等步骤.</li></ul></li><li><strong>功能</strong>：实现操作码解析、文件映射、函数长度计算和地址验证等功能，为内核驱动的开发和运行提供底层支持，便于进行代码分析、文件操作和系统模块管理.</li></ul><h4 id=driverentryc><a class=header-anchor href=#driverentryc></a>DriverEntry.c</h4><ul><li><strong>函数</strong>：<ul><li><code>DriverEntry()</code>：驱动程序的入口函数，负责初始化驱动程序。</li><li><code>ControlPassThrough()</code>：处理设备控制请求的函数。</li><li><code>DefaultPassThrough()</code>：处理未明确指定的IRP请求的函数。</li><li><code>UnloadDriver()</code>：驱动程序卸载时的清理函数.</li></ul></li><li><strong>功能</strong>：实现驱动程序的初始化、设备控制请求处理、默认IRP请求处理和卸载清理等功能，为驱动程序的正常运行和管理提供基础.</li></ul><h4 id=fixrelocationc><a class=header-anchor href=#fixrelocationc></a>FixRelocation.c</h4><ul><li><strong>函数</strong>：<ul><li><code>FixBaseRelocTable()</code>：修复重定位表的函数。</li><li><code>LdrProcessRelocationBlockLongLong()</code>：处理重定位块的函数。</li><li><code>RtlImageNtHeaderEx()</code>：获取PE文件的NT头并进行有效性检查的函数。</li></ul></li><li><strong>功能</strong>：实现PE文件重定位表的修复、重定位块的处理以及NT头的获取和检查，确保程序在加载到新的基地址时能够正确运行，为动态加载和重定位提供支持.</li></ul><h4 id=kernelhookcheckc><a class=header-anchor href=#kernelhookcheckc></a>KernelHookCheck.c</h4><ul><li><strong>函数</strong>：<ul><li><code>GetSystemKernelModuleInfo()</code>：获取系统内核模块信息的函数。</li><li><code>IoGetFileSystemVpbInfo()</code>：获取文件系统的VPB信息的函数。</li><li><code>GetDeviceObjectFromFileFullName()</code>：从文件完整路径获取设备对象的函数。</li><li><code>GetWindowsRootName()</code>：获取Windows根目录名称的函数。</li><li><code>KernelOpenFile()</code>：在内核中打开文件的函数。</li><li><code>KernelGetFileSize()</code>：获取文件大小的函数。</li><li><code>KernelReadFile()</code>：从文件中读取数据的函数。</li><li><code>ImageFile()</code>：判断是否为映像文件的函数。</li><li><code>AlignSize()</code>：对齐大小的函数。</li><li><code>GetKernelModuleBase()</code>：获取内核模块基址的函数。</li><li><code>InsertOriginalFirstThunk()</code>：插入原始第一个<a href=https://www.ruanyifeng.com/blog/2015/05/thunk.html>Thunk</a>的函数。</li><li><code>MiFindExportedRoutine()</code>：查找导出例程的函数。</li><li><code>FixImportTable()</code>：修复导入表的函数。</li><li><code>PeLoad()</code>：加载PE文件的函数.</li></ul></li><li><strong>功能</strong>：实现内核钩子检测的核心逻辑，包括文件操作、内核模块信息获取、PE文件处理、内存对齐、模块基址获取、导入表修复、导出例程查找以及PE文件加载等功能，为检测和管理内核钩子提供关键支持.</li></ul><h4 id=libdasmc><a class=header-anchor href=#libdasmc></a>libdasm.c</h4><ul><li><strong>函数</strong>：<ul><li><code>FETCH8()</code>、<code>FETCH16()</code>、<code>FETCH32()</code>：字节序转换函数。</li><li><code>get_real_instruction()</code>、<code>get_real_instruction2()</code>：指令解析函数。</li><li><code>get_operand()</code>：操作数解析函数。</li><li><code>get_operand_string()</code>：打印操作数字符串的函数。</li><li><code>get_instruction()</code>：获取指令的函数。</li><li><code>get_instruction_string()</code>：打印指令字符串的函数.</li><li>一系列辅助函数：用于获取操作数的具体信息，如寄存器类型、操作数类型、立即数、位移等.</li></ul></li><li><strong>功能</strong>：实现x86反汇编功能，将机器码转换为可读的汇编语言指令，支持字节序转换、指令解析、操作数提取以及指令字符串生成等，为代码分析和调试提供工具.</li></ul><h4 id=reloadc><a class=header-anchor href=#reloadc></a>reload.c</h4><ul><li><strong>函数：</strong><ul><li><code>ReLoadNtosCALL()</code>：根据函数名、原始内核模块基址和重载后的内核模块基址，计算并返回重载后的函数地址。</li><li><code>ReLoadNtos()</code>：初始化并重载内核模块，包括获取系统内核模块信息、加载并初始化重载后的内核模块、重载关键函数等步骤.</li><li><code>InitSafeOperationModule()</code>：加载并初始化重载后的内核模块，修复SSDT表，创建并初始化安全服务描述符表.</li><li><code>FixOriginalKiServiceTable()</code>：修复SSDT表中的函数地址，使其指向重载后的内核模块.</li><li><code>GetOriginalKiServiceTable()</code>：通过重定位表获取原始的SSDT基址.</li></ul></li><li><strong>功能</strong>：实现内核模块的重载和SSDT表的修复，确保内核函数的调用是安全的、未被篡改的，为内核安全提供保障.</li></ul><h1 id=功能><a class=header-anchor href=#%e5%8a%9f%e8%83%bd></a>功能</h1><ol><li><em><strong>重新加载第一个内核模块</strong></em>：这通常指的是在操作系统的内核环境中，卸载并再次加载一个特定的驱动程序或模块。这种操作通常用于测试模块的功能、更新模块或解决由于模块问题导致的系统故障。重新加载内核模块有助于确保模块的最新状态被应用。</li><li><em><strong>检查EAT函数（<a href=https://www.cnblogs.com/liaoguifa/p/9647870.html>Zwxx</a>）</strong></em>：EAT（Export Address Table）是Windows操作系统中的一个重要数据结构，用于管理导出函数的地址。在检查EAT函数时，我们通常会关注像Zwxx这样的函数，这些函数是内核模式下的系统调用接口。检查EAT函数常常意味着要验证这些函数的行为、地址或任何可能的异常，以确保它们按预期工作。</li><li><em><strong>检查InlineHook（非Zwxx）</strong></em>：InlineHook是一种技术，用于在函数调用的开始处插入自定义代码，以改变函数的执行流（比如拦截调用或修改参数）。在检查InlineHook时，我们关注的是非Zwxx的其他系统调用或函数，目的是确保这些函数的执行未被篡改，或者检测是否有恶意代码插入。通常，这样的检查涉及分析特定内存地址的内容和状态。</li></ol><h1 id=1-checkkernelhook><a class=header-anchor href=#1-checkkernelhook></a>1. CheckKernelHook</h1><h2 id=11-checkkernelhookh><a class=header-anchor href=#11-checkkernelhookh></a>1.1 CheckKernelHook.h</h2><p>这段代码是一个C++头文件，主要用于定义一个Windows应用程序的主类。下面逐步分解并详细解释代码的每个部分：</p><ol><li><p><strong>文件描述和预处理指令</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// CheckKernelHook.h : PROJECT_NAME 应用程序的主头文件
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=cp>#pragma once
</span></span></span></code></pre></div><p>这部分是文件注释，表明该文件为某个项目的主头文件。而<code>#pragma once</code>是一种预处理指令，用于确保该头文件只会被编译一次，防止重复包含。</p></li><li><p><strong>条件编译</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#ifndef __AFXWIN_H__
</span></span></span><span class=line><span class=cl><span class=cp></span>    <span class=cp>#error &#34;在包含此文件之前包含“stdafx.h”以生成 PCH 文件&#34;
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><p>这段代码是一个条件编译检查，确保在包含<code>CheckKernelHook.h</code>文件之前，已经包含了<code>stdafx.h</code>，这是一个预编译头文件。若没有包含，编译器将会生成错误消息。</p></li><li><p><strong>资源文件的包含</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;resource.h&#34;</span><span class=cp>    </span><span class=c1>// 主符号
</span></span></span></code></pre></div><p>这行代码包含了一个资源文件头（<code>resource.h</code>），这个文件通常定义了应用程序中使用的资源符号，例如图标、菜单和对话框等。</p><p>resource.h内容如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>//{{NO_DEPENDENCIES}}
</span></span></span><span class=line><span class=cl><span class=c1>// Microsoft Visual C++ generated include file.
</span></span></span><span class=line><span class=cl><span class=c1>// Used by CheckKernelHook.rc
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 该代码的主要功能是为一个 Windows 应用程序（CheckKernelHook）定义和管理资源标识符
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=cp>#define IDM_ABOUTBOX                    0x0010
</span></span></span><span class=line><span class=cl><span class=cp>#define IDD_ABOUTBOX                    100
</span></span></span><span class=line><span class=cl><span class=cp>#define IDS_ABOUTBOX                    101
</span></span></span><span class=line><span class=cl><span class=cp>#define IDD_CHECKKERNELHOOK_DIALOG      102
</span></span></span><span class=line><span class=cl><span class=cp>#define IDR_MAINFRAME                   128
</span></span></span><span class=line><span class=cl><span class=cp>#define IDC_LIST1                       1000
</span></span></span><span class=line><span class=cl><span class=cp>#define IDC_LIST                        1000
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* 这些 #define 语句定义了一系列的标识符（ID），用于在资源文件和程序代码中引用不同的窗口、对话框、菜单和控件等。具体说明：
</span></span></span><span class=line><span class=cl><span class=cm>IDM_ABOUTBOX：标识菜单项的ID。
</span></span></span><span class=line><span class=cl><span class=cm>IDD_ABOUTBOX：标识关于对话框的ID。
</span></span></span><span class=line><span class=cl><span class=cm>IDS_ABOUTBOX：标识关于对话框所使用的字符串ID。
</span></span></span><span class=line><span class=cl><span class=cm>IDD_CHECKKERNELHOOK_DIALOG：标识主对话框的ID。
</span></span></span><span class=line><span class=cl><span class=cm>IDR_MAINFRAME：标识主窗口框架的ID。
</span></span></span><span class=line><span class=cl><span class=cm>IDC_LIST1 和 IDC_LIST：标识列表控件的ID（在此处是相同的）。
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// Next default values for new objects
</span></span></span><span class=line><span class=cl><span class=c1>// 
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=cp>#ifdef APSTUDIO_INVOKED
</span></span></span><span class=line><span class=cl><span class=cp>#ifndef APSTUDIO_READONLY_SYMBOLS
</span></span></span><span class=line><span class=cl><span class=cp>#define _APS_NEXT_RESOURCE_VALUE        129
</span></span></span><span class=line><span class=cl><span class=cp>#define _APS_NEXT_COMMAND_VALUE         32771
</span></span></span><span class=line><span class=cl><span class=cp>#define _APS_NEXT_CONTROL_VALUE         1001
</span></span></span><span class=line><span class=cl><span class=cp>#define _APS_NEXT_SYMED_VALUE           101
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=cm>/* 这一部分为新的资源对象定义了默认值，仅在使用 Microsoft Visual Studio 的资源编辑器时有效，以便快速创建新的资源。这种用法有助于避免 ID 冲突。*/</span>
</span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div></li><li><p><strong>CCheckKernelHookApp类的定义</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>CCheckKernelHookApp</span> <span class=o>:</span> <span class=k>public</span> <span class=n>CWinApp</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>CCheckKernelHookApp</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 重写
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=k>virtual</span> <span class=n>BOOL</span> <span class=n>InitInstance</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 实现
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>DECLARE_MESSAGE_MAP</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>这里定义了<code>CCheckKernelHookApp</code>类，它继承自<code>CWinApp</code>，这是MFC（Microsoft Foundation Class）库中定义的一个类，代表Windows应用程序的基础结构。</p><ul><li><strong>构造函数</strong> <code>CCheckKernelHookApp()</code>：用于初始化类的实例。</li><li><strong>InitInstance()</strong>：这是一个虚方法，重写了<code>CWinApp</code>中的同名方法。这个方法通常负责应用程序的初始化工作，例如创建主窗口。</li><li><strong>DECLARE_MESSAGE_MAP()</strong>：这是一个宏，用于声明消息映射，这样类可以接收Windows消息并且执行相应的处理。</li></ul></li><li><p><strong>全局变量的声明</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>extern</span> <span class=n>CCheckKernelHookApp</span> <span class=n>theApp</span><span class=p>;</span>
</span></span></code></pre></div><p>这行代码声明了一个全局变量<code>theApp</code>，这个变量的类型是<code>CCheckKernelHookApp</code>，用于在整个程序中访问该应用程序实例。</p></li></ol><h3 id=总结-1><a class=header-anchor href=#%e6%80%bb%e7%bb%93-1></a>总结</h3><p>这段代码的主要功能是定义一个Windows MFC应用程序的主类<code>CCheckKernelHookApp</code>，并设置其基本框架。它包括了必要的头文件、资源文件的引用，并声明了应用程序的初始化函数以及消息处理机制。整体上，它为后续实现应用程序的功能提供了基础结构。</p><h2 id=12-checkkernelhookcpp><a class=header-anchor href=#12-checkkernelhookcpp></a>1.2 CheckKernelHook.cpp</h2><p>这段代码是一个使用 MFC（Microsoft Foundation Class）库开发的 Windows 应用程序。其主要目的是初始化应用程序、创建主对话框并处理用户的交互。以下是对代码的逐步分解与详细解释：</p><ol><li><p><strong>头文件包含</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;stdafx.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;CheckKernelHook.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;CheckKernelHookDlg.h&#34;</span><span class=cp>
</span></span></span></code></pre></div><p>这部分代码引入了程序功能所需的头文件。<code>stdafx.h</code> 是预编译头文件，用于加速编译过程。<code>CheckKernelHook.h</code> 和 <code>CheckKernelHookDlg.h</code> 分别是主应用程序类和对话框类所需的头文件。</p></li><li><p><strong>DEBUG宏定义</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#ifdef _DEBUG
</span></span></span><span class=line><span class=cl><span class=cp>#define new DEBUG_NEW
</span></span></span><span class=line><span class=cl><span class=cp>#endif
</span></span></span></code></pre></div><p>这段代码用于调试模式，重定义 <code>new</code> 操作符，以便在 DEBUG 模式下跟踪内存分配问题。</p></li><li><p><strong>CCheckKernelHookApp 类</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>BEGIN_MESSAGE_MAP</span><span class=p>(</span><span class=n>CCheckKernelHookApp</span><span class=p>,</span> <span class=n>CWinApp</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>ON_COMMAND</span><span class=p>(</span><span class=n>ID_HELP</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>CWinApp</span><span class=o>::</span><span class=n>OnHelp</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>END_MESSAGE_MAP</span><span class=p>()</span>
</span></span></code></pre></div><p>这里定义了一个消息映射，将 <code>ID_HELP</code> 命令与 <code>CWinApp</code> 类的 <code>OnHelp</code> 函数关联。消息映射是 MFC 处理用户输入以及窗口消息的机制。</p></li><li><p><strong>构造函数</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>CCheckKernelHookApp</span><span class=o>::</span><span class=n>CCheckKernelHookApp</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>m_dwRestartManagerSupportFlags</span> <span class=o>=</span> <span class=n>AFX_RESTART_MANAGER_SUPPORT_RESTART</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>在构造函数中，设置应用程序支持重新启动管理器的标志。</p></li><li><p><strong>应用程序初始化</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>BOOL</span> <span class=n>CCheckKernelHookApp</span><span class=o>::</span><span class=n>InitInstance</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>INITCOMMONCONTROLSEX</span> <span class=n>InitCtrls</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>InitCtrls</span><span class=p>.</span><span class=n>dwSize</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>InitCtrls</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>InitCtrls</span><span class=p>.</span><span class=n>dwICC</span> <span class=o>=</span> <span class=n>ICC_WIN95_CLASSES</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>InitCommonControlsEx</span><span class=p>(</span><span class=o>&amp;</span><span class=n>InitCtrls</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>CWinApp</span><span class=o>::</span><span class=n>InitInstance</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>AfxEnableControlContainer</span><span class=p>();</span>
</span></span></code></pre></div><ul><li>首先，初始化公共控件以确保创建设备窗口的必要控件（如按钮、滚动条等）。</li><li>然后调用基类 <code>CWinApp::InitInstance()</code> 进行进一步的初始化。</li><li>启用控制容器，以支持特定的控件类型。</li></ul></li><li><p><strong>Shell 管理器创建</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>CShellManager</span> <span class=o>*</span><span class=n>pShellManager</span> <span class=o>=</span> <span class=k>new</span> <span class=n>CShellManager</span><span class=p>;</span>
</span></span></code></pre></div><p>创建一个 Shell 管理器实例，以支持应用程序中可能包含的 Shell 树视图或列表视图控件。</p></li><li><p><strong>注册表设置</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>SetRegistryKey</span><span class=p>(</span><span class=n>_T</span><span class=p>(</span><span class=s>&#34;应用程序向导生成的本地应用程序&#34;</span><span class=p>));</span>
</span></span></code></pre></div><p>这行代码用于设置存储应用程序设置的注册表位置。</p></li><li><p><strong>对话框创建与显示</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>CCheckKernelHookDlg</span> <span class=n>dlg</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>m_pMainWnd</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>dlg</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>INT_PTR</span> <span class=n>nResponse</span> <span class=o>=</span> <span class=n>dlg</span><span class=p>.</span><span class=n>DoModal</span><span class=p>();</span>
</span></span></code></pre></div><p>创建一个对话框实例并将其设置为主窗口，随后调用 <code>DoModal</code> 函数显示对话框，等待用户响应。</p></li><li><p><strong>处理对话框响应</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>nResponse</span> <span class=o>==</span> <span class=n>IDOK</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 处理用户按下“确定”的情况
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>nResponse</span> <span class=o>==</span> <span class=n>IDCANCEL</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 处理用户按下“取消”的情况
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div></li><li><p><strong>Shell 管理器删除</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>pShellManager</span> <span class=o>!=</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>pShellManager</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div></li><li><p><strong>应用程序退出</strong>：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span></code></pre></div><p>由于对话框已关闭，返回 <code>FALSE</code> 使程序退出而不启动消息循环。</p></li></ol><h3 id=总结-2><a class=header-anchor href=#%e6%80%bb%e7%bb%93-2></a>总结</h3><p>这段代码的主要功能是创建一个 Windows 应用程序，初始化必要的环境，打开一个对话框并处理用户的交互。它使用 MFC 框架提供了一些基本功能，如消息映射、公共控件初始化以及对话框管理，目的是提供一个可以与用户进行互动的简单界面。同时，它依赖于 Shell 管理器来处理复杂的控件类型。</p><h2 id=13-checkkernelhookdlgh><a class=header-anchor href=#13-checkkernelhookdlgh></a>1.3 CheckKernelHookDlg.h</h2><p>这段代码是一个C++头文件，定义了一个用于检查内核钩子的对话框类 <code>CCheckKernelHookDlg</code>。以下是代码的详细解释：</p><ol><li><p><strong>头文件包含</strong>：</p><ul><li><code>#pragma once</code>：确保头文件只被包含一次，防止重复定义。</li><li><code>#include "afxcmn.h"</code>：包含MFC（Microsoft Foundation Classes）的常用头文件，提供了一些常用的MFC类和宏。</li><li><code>#include "resource.h"</code>：包含资源文件，通常用于定义对话框、菜单、图标等资源的ID。</li><li><code>#include &lt;WinIoCtl.h></code>：包含Windows I/O控制相关的头文件，用于设备I/O控制操作。</li></ul></li><li><p><strong>结构体定义</strong>：</p><ul><li><code>_INLINEHOOKINFO_INFORMATION</code>：定义了一个结构体，用于存储内联钩子的信息。包含以下字段：<ul><li><code>ulHookType</code>：钩子类型。</li><li><code>ulMemoryFunctionBase</code>：原始函数的基地址。</li><li><code>ulMemoryHookBase</code>：钩子函数的基地址。</li><li><code>lpszFunction</code>：函数名称。</li><li><code>lpszHookModuleImage</code>：钩子模块的映像名称。</li><li><code>ulHookModuleBase</code>：钩子模块的基地址。</li><li><code>ulHookModuleSize</code>：钩子模块的大小。</li></ul></li><li><code>_INLINEHOOKINFO</code>：定义了一个结构体，用于存储多个内联钩子的信息。包含以下字段：<ul><li><code>ulCount</code>：钩子的数量。</li><li><code>InlineHook[1]</code>：一个内联钩子信息的数组，数组大小为1，但通常用于动态分配内存以存储多个钩子信息。</li></ul></li></ul></li><li><p><strong>宏定义</strong>：</p><ul><li><code>CTL_CHECKKERNELMODULE</code>：定义了一个设备I/O控制码，用于与内核模块进行通信。<code>CTL_CODE</code>宏用于生成设备控制码，参数包括设备类型、功能码、访问方式和访问权限。</li></ul></li><li><p><strong>类定义</strong>：</p><ul><li><code>CCheckKernelHookDlg</code>：继承自<code>CDialogEx</code>，表示一个对话框类。包含以下成员：<ul><li>构造函数：<code>CCheckKernelHookDlg(CWnd* pParent = NULL)</code>，用于创建对话框对象。</li><li><code>IDD</code>：对话框的资源ID。</li><li><code>CheckKernelHook()</code>：用于检查内核钩子的函数。</li><li><code>InsertDataToList(PINLINEHOOKINFO PInlineHookInfo)</code>：用于将钩子信息插入到列表中的函数。</li><li><code>DoDataExchange(CDataExchange* pDX)</code>：用于对话框数据交换的函数。</li><li><code>OpenDevice(LPCTSTR wzLinkPath)</code>：用于打开设备的函数，返回设备句柄。</li></ul></li></ul></li><li><p><strong>其他成员</strong>：</p><ul><li><code>m_hIcon</code>：对话框的图标句柄。</li><li><code>OnInitDialog()</code>：对话框初始化函数。</li><li><code>OnSysCommand(UINT nID, LPARAM lParam)</code>：处理系统命令的函数。</li><li><code>OnPaint()</code>：处理绘图的函数。</li><li><code>OnQueryDragIcon()</code>：返回对话框图标的函数。</li><li><code>DECLARE_MESSAGE_MAP()</code>：声明消息映射宏，用于处理Windows消息。</li><li><code>m_List</code>：一个<code>CListCtrl</code>对象，用于在对话框中显示列表控件。</li></ul></li></ol><p>这段代码主要用于定义一个对话框类，用于检查和显示内核钩子的信息。通过设备I/O控制码与内核模块进行通信，获取钩子信息并显示在对话框中。</p><h2 id=14-checkkernelhookdlgcpp><a class=header-anchor href=#14-checkkernelhookdlgcpp></a>1.4 CheckKernelHookDlg.cpp</h2><p>这段代码是一个 Windows 应用程序的实现文件，主要关注于检查内核钩子（Kernel Hook）的功能。代码的主要功能是与驱动程序进行通信，获取系统中存在的钩子信息，并将这些信息以列表形式显示在对话框中。以下是逐步分解和详细解释：</p><h3 id=包含的头文件><a class=header-anchor href=#%e5%8c%85%e5%90%ab%e7%9a%84%e5%a4%b4%e6%96%87%e4%bb%b6></a>包含的头文件</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;stdafx.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;CheckKernelHook.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;CheckKernelHookDlg.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;afxdialogex.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;AddService.h&#34;</span><span class=cp>
</span></span></span></code></pre></div><ul><li>这些头文件包括了应用程序所需的基本库、对话框类的定义以及其他功能的实现。</li></ul><h3 id=全局变量><a class=header-anchor href=#%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f></a>全局变量</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>HANDLE</span> <span class=n>g_hDevice</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span> <span class=c1>// 全局设备句柄，用于与驱动程序进行通信
</span></span></span></code></pre></div><ul><li><code>g_hDevice</code> 是用于与底层驱动程序通信的句柄。</li></ul><h3 id=列表结构体定义><a class=header-anchor href=#%e5%88%97%e8%a1%a8%e7%bb%93%e6%9e%84%e4%bd%93%e5%ae%9a%e4%b9%89></a>列表结构体定义</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>typedef</span> <span class=k>struct</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>WCHAR</span><span class=o>*</span>     <span class=n>szTitle</span><span class=p>;</span>           <span class=c1>// 列表的名称
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=kt>int</span>        <span class=n>nWidth</span><span class=p>;</span>            <span class=c1>// 列表的宽度
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span> <span class=n>COLUMNSTRUCT</span><span class=p>;</span>
</span></span></code></pre></div><ul><li>定义一个结构体 <code>COLUMNSTRUCT</code>，用于存储列表的列名称和宽度。</li></ul><h3 id=列表列信息初始化><a class=header-anchor href=#%e5%88%97%e8%a1%a8%e5%88%97%e4%bf%a1%e6%81%af%e5%88%9d%e5%a7%8b%e5%8c%96></a>列表列信息初始化</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>COLUMNSTRUCT</span> <span class=n>g_Column_Data_Online</span><span class=p>[]</span> <span class=o>=</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=sa>L</span><span class=s>&#34;原始地址&#34;</span><span class=p>,</span>          <span class=mi>148</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=sa>L</span><span class=s>&#34;函数名称&#34;</span><span class=p>,</span>          <span class=mi>150</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=sa>L</span><span class=s>&#34;Hook地址&#34;</span><span class=p>,</span>          <span class=mi>160</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=sa>L</span><span class=s>&#34;模块名称&#34;</span><span class=p>,</span>          <span class=mi>300</span> <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=sa>L</span><span class=s>&#34;模块基址&#34;</span><span class=p>,</span>          <span class=mi>80</span>  <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=sa>L</span><span class=s>&#34;模块大小&#34;</span><span class=p>,</span>          <span class=mi>81</span>  <span class=p>},</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span><span class=sa>L</span><span class=s>&#34;类型&#34;</span><span class=p>,</span>              <span class=mi>81</span>  <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span></code></pre></div><ul><li>初始化了一个包含7列的列表结构，定义了每一列的名称和宽度，这些列用于展示钩子信息。</li></ul><h3 id=对话框类的实现><a class=header-anchor href=#%e5%af%b9%e8%af%9d%e6%a1%86%e7%b1%bb%e7%9a%84%e5%ae%9e%e7%8e%b0></a>对话框类的实现</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>CAboutDlg</span> <span class=o>:</span> <span class=k>public</span> <span class=n>CDialogEx</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ... 省略内容
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>};</span>
</span></span></code></pre></div><ul><li><code>CAboutDlg</code> 类用于处理“关于”对话框的显示。</li></ul><h3 id=ccheckkernelhookdlg对话框类><a class=header-anchor href=#ccheckkernelhookdlg%e5%af%b9%e8%af%9d%e6%a1%86%e7%b1%bb></a><code>CCheckKernelHookDlg</code>对话框类</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>CCheckKernelHookDlg</span><span class=o>::</span><span class=n>CCheckKernelHookDlg</span><span class=p>(</span><span class=n>CWnd</span><span class=o>*</span> <span class=n>pParent</span> <span class=cm>/*=NULL*/</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>:</span> <span class=n>CDialogEx</span><span class=p>(</span><span class=n>CCheckKernelHookDlg</span><span class=o>::</span><span class=n>IDD</span><span class=p>,</span> <span class=n>pParent</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>m_hIcon</span> <span class=o>=</span> <span class=n>AfxGetApp</span><span class=p>()</span><span class=o>-&gt;</span><span class=n>LoadIcon</span><span class=p>(</span><span class=n>IDR_MAINFRAME</span><span class=p>);</span> <span class=c1>// 加载对话框图标
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>CCheckKernelHookDlg</span><span class=o>::</span><span class=n>DoDataExchange</span><span class=p>(</span><span class=n>CDataExchange</span><span class=o>*</span> <span class=n>pDX</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>CDialogEx</span><span class=o>::</span><span class=n>DoDataExchange</span><span class=p>(</span><span class=n>pDX</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>DDX_Control</span><span class=p>(</span><span class=n>pDX</span><span class=p>,</span> <span class=n>IDC_LIST</span><span class=p>,</span> <span class=n>m_List</span><span class=p>);</span> <span class=c1>// 绑定列表控件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><ul><li>类 <code>CCheckKernelHookDlg</code> 继承自 <code>CDialogEx</code>，实现主对话框的功能，包括控件的绑定和初始化。</li></ul><h3 id=oninitdialog-方法><a class=header-anchor href=#oninitdialog-%e6%96%b9%e6%b3%95></a><code>OnInitDialog</code> 方法</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>BOOL</span> <span class=n>CCheckKernelHookDlg</span><span class=o>::</span><span class=n>OnInitDialog</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ... 省略部分内容
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>g_hDevice</span> <span class=o>=</span> <span class=n>OpenDevice</span><span class=p>(</span><span class=sa>L</span><span class=s>&#34;</span><span class=se>\\\\</span><span class=s>.</span><span class=se>\\</span><span class=s>CheckKernelHookLinkName&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>g_hDevice</span> <span class=o>==</span> <span class=p>(</span><span class=n>HANDLE</span><span class=p>)</span><span class=o>-</span><span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>MessageBox</span><span class=p>(</span><span class=sa>L</span><span class=s>&#34;打开设备失败&#34;</span><span class=p>);</span> <span class=c1>// 打开设备失败提示
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>return</span> <span class=n>TRUE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>CheckKernelHook</span><span class=p>();</span> <span class=c1>// 检查内核 Hook 状态
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>return</span> <span class=n>TRUE</span><span class=p>;</span>  <span class=c1>// 除非将焦点设置到控件，否则返回 TRUE
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><ul><li>初始化对话框，设置图标，绑定控件并尝试打开与驱动程序的通信通道。如果打开失败，则显示消息框并返回。</li></ul><h3 id=检查内核-hook-状态><a class=header-anchor href=#%e6%a3%80%e6%9f%a5%e5%86%85%e6%a0%b8-hook-%e7%8a%b6%e6%80%81></a>检查内核 Hook 状态</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>VOID</span> <span class=n>CCheckKernelHookDlg</span><span class=o>::</span><span class=n>CheckKernelHook</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ... 省略内容
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>bRet</span> <span class=o>=</span> <span class=n>DeviceIoControl</span><span class=p>(</span><span class=n>g_hDevice</span><span class=p>,</span> <span class=n>CTL_CHECKKERNELMODULE</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>        <span class=mi>0</span><span class=p>,</span> <span class=n>PInlineHookInfo</span><span class=p>,</span> <span class=n>ulSize</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ulReturnSize</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span> <span class=c1>// 向驱动发送 IO 控制请求
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// ... 省略部分内容
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><ul><li>该方法向驱动程序发送 IO 控制请求，获取内核钩子信息，并通过内存分配和操作来处理响应。</li></ul><h3 id=插入数据到列表><a class=header-anchor href=#%e6%8f%92%e5%85%a5%e6%95%b0%e6%8d%ae%e5%88%b0%e5%88%97%e8%a1%a8></a>插入数据到列表</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>VOID</span> <span class=n>CCheckKernelHookDlg</span><span class=o>::</span><span class=n>InsertDataToList</span><span class=p>(</span><span class=n>PINLINEHOOKINFO</span> <span class=n>PInlineHookInfo</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>// ... 省略部分内容
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>m_List</span><span class=p>.</span><span class=n>SetItemText</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=n>Type</span><span class=p>);</span> <span class=c1>// 设置类型
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><ul><li>从获取的钩子信息中提取数据并填充到对话框的列表控件中，使用户能够查看内核钩子的详细信息。</li></ul><h3 id=消息处理程序和绘画><a class=header-anchor href=#%e6%b6%88%e6%81%af%e5%a4%84%e7%90%86%e7%a8%8b%e5%ba%8f%e5%92%8c%e7%bb%98%e7%94%bb></a>消息处理程序和绘画</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=n>CCheckKernelHookDlg</span><span class=o>::</span><span class=n>OnSysCommand</span><span class=p>(</span><span class=n>UINT</span> <span class=n>nID</span><span class=p>,</span> <span class=n>LPARAM</span> <span class=n>lParam</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/*...*/</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=n>CCheckKernelHookDlg</span><span class=o>::</span><span class=n>OnPaint</span><span class=p>()</span> <span class=p>{</span> <span class=cm>/*...*/</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>HCURSOR</span> <span class=n>CCheckKernelHookDlg</span><span class=o>::</span><span class=n>OnQueryDragIcon</span><span class=p>()</span> <span class=p>{</span> <span class=cm>/*...*/</span> <span class=p>}</span>
</span></span></code></pre></div><ul><li>这些方法处理系统命令、绘制窗口和获取光标，提供了用户界面交互所需的功能。</li></ul><h3 id=总结-3><a class=header-anchor href=#%e6%80%bb%e7%bb%93-3></a>总结</h3><p>这个代码的主要功能是创建一个 Windows 对话框应用程序，能够与底层驱动程序通信以检测和显示当前内核钩子的信息。通过详细的信息列表，用户可以查看钩子的原始地址、函数名称、当前 Hook 地址、模块名称等信息，从而帮助分析系统的安全性。这种功能在系统安全监控和反病毒软件中是非常重要的。</p><h2 id=15-addserviceh><a class=header-anchor href=#15-addserviceh></a>1.5 AddService.h</h2><p>这段代码的主要功能是提供一个接口来管理驱动程序的加载和卸载。具体来说：</p><ul><li><code>Release</code>函数用于释放相关资源。</li><li><code>UnloadDrv</code>函数用于卸载指定的驱动程序。</li><li><code>LoadDrv</code>函数用于加载指定的驱动程序。 整个代码片段为驱动程序的管理逻辑提供了基础结构，便于后续实现具体的驱动加载和卸载功能。</li></ul><h2 id=16-addservicecpp><a class=header-anchor href=#16-addservicecpp></a>1.6 AddService.cpp</h2><p>这段代码的主要功能是管理Windows系统中的驱动程序，主要包括加载和卸载指定的驱动，以及创建一个新驱动文件。以下是代码的逐步分解和详细解释：</p><h3 id=1-头文件包含><a class=header-anchor href=#1-%e5%a4%b4%e6%96%87%e4%bb%b6%e5%8c%85%e5%90%ab></a>1. 头文件包含</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;AddService.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;stdafx.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;CheckKernelHookDlg.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;Winsvc.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#pragma once
</span></span></span></code></pre></div><ul><li>这些头文件包含了相关的定义、函数原型和Windows服务管理所需的API。</li></ul><h3 id=2-release-函数><a class=header-anchor href=#2-release-%e5%87%bd%e6%95%b0></a>2. Release 函数</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>BOOL</span> <span class=nf>Release</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=n>HANDLE</span> <span class=n>hFile</span> <span class=o>=</span> <span class=n>CreateFile</span><span class=p>(</span><span class=n>TEXT</span><span class=p>(</span><span class=s>&#34;ReloadKernel.sys&#34;</span><span class=p>),</span> <span class=n>GENERIC_WRITE</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>CREATE_ALWAYS</span><span class=p>,</span> <span class=n>FILE_ATTRIBUTE_NORMAL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl> <span class=k>if</span> <span class=p>(</span><span class=n>hFile</span> <span class=o>==</span> <span class=n>INVALID_HANDLE_VALUE</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl> <span class=n>CloseHandle</span><span class=p>(</span><span class=n>hFile</span><span class=p>);</span>
</span></span><span class=line><span class=cl> <span class=k>return</span> <span class=n>TRUE</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li><strong>功能</strong>：释放资源并创建一个名为 <code>ReloadKernel.sys</code> 的新驱动文件。此处的代码注释掉的部分表明原计划是从资源中加载驱动内容，但最终实现了简单的文件创建。</li><li>如果文件创建成功，返回 <code>TRUE</code>；否则返回 <code>FALSE</code>。</li></ul><h3 id=3-unloaddrv-函数><a class=header-anchor href=#3-unloaddrv-%e5%87%bd%e6%95%b0></a>3. UnloadDrv 函数</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>BOOL</span> <span class=nf>UnloadDrv</span><span class=p>(</span><span class=n>TCHAR</span><span class=o>*</span> <span class=n>DriverName</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=n>SC_HANDLE</span> <span class=n>hSCManager</span><span class=p>;</span>
</span></span><span class=line><span class=cl> <span class=n>SC_HANDLE</span> <span class=n>hService</span><span class=p>;</span>
</span></span><span class=line><span class=cl> <span class=n>SERVICE_STATUS</span> <span class=n>ss</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=n>hSCManager</span> <span class=o>=</span> <span class=n>OpenSCManager</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>SC_MANAGER_ALL_ACCESS</span><span class=p>);</span>
</span></span><span class=line><span class=cl> <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>hSCManager</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=n>hService</span> <span class=o>=</span> <span class=n>OpenService</span><span class=p>(</span><span class=n>hSCManager</span><span class=p>,</span> <span class=n>DriverName</span><span class=p>,</span> <span class=n>SERVICE_ALL_ACCESS</span><span class=p>);</span>
</span></span><span class=line><span class=cl> <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>hService</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=n>CloseServiceHandle</span><span class=p>(</span><span class=n>hSCManager</span><span class=p>);</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=n>ControlService</span><span class=p>(</span><span class=n>hService</span><span class=p>,</span> <span class=n>SERVICE_CONTROL_STOP</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ss</span><span class=p>);</span>
</span></span><span class=line><span class=cl> <span class=n>DeleteService</span><span class=p>(</span><span class=n>hService</span><span class=p>);</span>
</span></span><span class=line><span class=cl> <span class=n>CloseServiceHandle</span><span class=p>(</span><span class=n>hService</span><span class=p>);</span>
</span></span><span class=line><span class=cl> <span class=n>CloseServiceHandle</span><span class=p>(</span><span class=n>hSCManager</span><span class=p>);</span>
</span></span><span class=line><span class=cl> <span class=k>return</span> <span class=n>TRUE</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li><strong>功能</strong>：卸载指定的驱动程序。通过 <code>OpenSCManager</code> 打开服务控制管理器，然后打开指定的服务，停止并删除该服务。</li><li>处理操作失败的情况，如果任一步骤失败会返回 <code>FALSE</code>。</li></ul><h3 id=4-loaddrv-函数><a class=header-anchor href=#4-loaddrv-%e5%87%bd%e6%95%b0></a>4. LoadDrv 函数</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=n>BOOL</span> <span class=nf>LoadDrv</span><span class=p>(</span><span class=n>TCHAR</span><span class=o>*</span> <span class=n>DriverName</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl> <span class=n>TCHAR</span> <span class=n>DrvFullPathName</span><span class=p>[</span><span class=n>MAX_PATH</span><span class=p>];</span>
</span></span><span class=line><span class=cl> <span class=n>SC_HANDLE</span> <span class=n>schSCManager</span><span class=p>;</span>
</span></span><span class=line><span class=cl> <span class=n>SC_HANDLE</span> <span class=n>schService</span><span class=p>;</span>
</span></span><span class=line><span class=cl> <span class=n>UnloadDrv</span><span class=p>(</span><span class=sa>L</span><span class=s>&#34;CheckKernelHook&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=cl> <span class=n>GetFullPathName</span><span class=p>(</span><span class=n>TEXT</span><span class=p>(</span><span class=s>&#34;CheckKernelHook.sys&#34;</span><span class=p>),</span> <span class=n>MAX_PATH</span><span class=p>,</span> <span class=n>DrvFullPathName</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl> <span class=n>schSCManager</span> <span class=o>=</span> <span class=n>OpenSCManager</span><span class=p>(</span><span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>SC_MANAGER_ALL_ACCESS</span><span class=p>);</span>
</span></span><span class=line><span class=cl> <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>schSCManager</span><span class=p>)</span>
</span></span><span class=line><span class=cl>  <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=n>schService</span> <span class=o>=</span> <span class=n>CreateService</span><span class=p>(</span>
</span></span><span class=line><span class=cl>  <span class=n>schSCManager</span><span class=p>,</span> <span class=n>DriverName</span><span class=p>,</span> <span class=n>DriverName</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>SERVICE_ALL_ACCESS</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>SERVICE_KERNEL_DRIVER</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>SERVICE_DEMAND_START</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>SERVICE_ERROR_NORMAL</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=n>DrvFullPathName</span><span class=p>,</span>
</span></span><span class=line><span class=cl>  <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=nb>NULL</span>
</span></span><span class=line><span class=cl> <span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>schService</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>GetLastError</span><span class=p>()</span> <span class=o>==</span> <span class=n>ERROR_SERVICE_EXISTS</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=n>schService</span> <span class=o>=</span> <span class=n>OpenService</span><span class=p>(</span><span class=n>schSCManager</span><span class=p>,</span> <span class=n>DriverName</span><span class=p>,</span> <span class=n>SERVICE_ALL_ACCESS</span><span class=p>);</span>
</span></span><span class=line><span class=cl>   <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>schService</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>CloseServiceHandle</span><span class=p>(</span><span class=n>schSCManager</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=p>}</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=n>CloseServiceHandle</span><span class=p>(</span><span class=n>schSCManager</span><span class=p>);</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl> <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>StartService</span><span class=p>(</span><span class=n>schService</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=p>(</span><span class=n>GetLastError</span><span class=p>()</span> <span class=o>==</span> <span class=n>ERROR_SERVICE_ALREADY_RUNNING</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=n>CloseServiceHandle</span><span class=p>(</span><span class=n>schService</span><span class=p>);</span>
</span></span><span class=line><span class=cl>   <span class=n>CloseServiceHandle</span><span class=p>(</span><span class=n>schSCManager</span><span class=p>);</span>
</span></span><span class=line><span class=cl>   <span class=k>return</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=cl> <span class=p>}</span>
</span></span><span class=line><span class=cl> 
</span></span><span class=line><span class=cl> <span class=n>CloseServiceHandle</span><span class=p>(</span><span class=n>schService</span><span class=p>);</span>
</span></span><span class=line><span class=cl> <span class=n>CloseServiceHandle</span><span class=p>(</span><span class=n>schSCManager</span><span class=p>);</span>
</span></span><span class=line><span class=cl> <span class=k>return</span> <span class=n>TRUE</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><ul><li><strong>功能</strong>：加载指定的驱动程序。首先卸载已存在的同名驱动，然后获取驱动程序的完整路径，打开服务控制管理器，创建新的服务，最后启动它。</li><li>处理可能出现的错误，如服务已存在或服务已经在运行。</li></ul><h3 id=总结-4><a class=header-anchor href=#%e6%80%bb%e7%bb%93-4></a>总结</h3><p>整体来看，这段代码的主要功能是提供对Windows驱动程序的管理，包括创建、加载和卸载驱动程序。而具体来说，<code>Release</code> 函数用于创建新的驱动文件，<code>UnloadDrv</code> 函数用于卸载指定的驱动，而 <code>LoadDrv</code> 函数则用于加载并启动驱动程序。这些功能通常用于对驱动进行维护和更新，以确保系统的稳定性和安全性。</p><h2 id=核心代码><a class=header-anchor href=#%e6%a0%b8%e5%bf%83%e4%bb%a3%e7%a0%81></a>核心代码</h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=c1>// CCheckKernelHookDlg 类的方法，用于检查内核是否存在 Hook
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>VOID</span> <span class=n>CCheckKernelHookDlg</span><span class=o>::</span><span class=n>CheckKernelHook</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>ULONG_PTR</span> <span class=n>ulCount</span> <span class=o>=</span> <span class=mh>0x1000</span><span class=p>;</span> <span class=c1>// 初始化计数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>PINLINEHOOKINFO</span> <span class=n>PInlineHookInfo</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span> <span class=c1>// 指向内联 Hook 信息的指针
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>BOOL</span> <span class=n>bRet</span> <span class=o>=</span> <span class=n>FALSE</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span> <span class=n>ulReturnSize</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>do</span> 
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ULONG_PTR</span> <span class=n>ulSize</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// 每次循环申请新的内存空间
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>PInlineHookInfo</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>free</span><span class=p>(</span><span class=n>PInlineHookInfo</span><span class=p>);</span> <span class=c1>// 释放之前申请的内存
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>PInlineHookInfo</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>ulSize</span> <span class=o>=</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>INLINEHOOKINFO</span><span class=p>)</span> <span class=o>+</span> <span class=n>ulCount</span> <span class=o>*</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>INLINEHOOKINFO_INFORMATION</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>PInlineHookInfo</span> <span class=o>=</span> <span class=p>(</span><span class=n>PINLINEHOOKINFO</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=n>ulSize</span><span class=p>);</span> <span class=c1>// 申请内存
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>PInlineHookInfo</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=k>break</span><span class=p>;</span> <span class=c1>// 内存申请失败时退出
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>memset</span><span class=p>(</span><span class=n>PInlineHookInfo</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>ulSize</span><span class=p>);</span> <span class=c1>// 清空申请的内存
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>bRet</span> <span class=o>=</span> <span class=n>DeviceIoControl</span><span class=p>(</span><span class=n>g_hDevice</span><span class=p>,</span> <span class=n>CTL_CHECKKERNELMODULE</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>            <span class=mi>0</span><span class=p>,</span> <span class=n>PInlineHookInfo</span><span class=p>,</span> <span class=n>ulSize</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>ulReturnSize</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span> <span class=c1>// 向驱动发送 IO 控制请求
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>ulCount</span> <span class=o>=</span> <span class=n>PInlineHookInfo</span><span class=o>-&gt;</span><span class=n>ulCount</span> <span class=o>+</span> <span class=mi>1000</span><span class=p>;</span> <span class=c1>// 更新计数
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span> <span class=k>while</span> <span class=p>(</span><span class=n>bRet</span> <span class=o>==</span> <span class=n>FALSE</span> <span class=o>&amp;&amp;</span> <span class=n>GetLastError</span><span class=p>()</span> <span class=o>==</span> <span class=n>ERROR_INSUFFICIENT_BUFFER</span><span class=p>);</span> <span class=c1>// 错误处理
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>PInlineHookInfo</span><span class=o>-&gt;</span><span class=n>ulCount</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>MessageBox</span><span class=p>(</span><span class=sa>L</span><span class=s>&#34;当前内核安全&#34;</span><span class=p>,</span> <span class=sa>L</span><span class=s>&#34;&#34;</span><span class=p>);</span> <span class=c1>// 提示内核安全
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>InsertDataToList</span><span class=p>(</span><span class=n>PInlineHookInfo</span><span class=p>);</span> <span class=c1>// 插入数据到列表
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>PInlineHookInfo</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>free</span><span class=p>(</span><span class=n>PInlineHookInfo</span><span class=p>);</span> <span class=c1>// 释放内存
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>PInlineHookInfo</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 将缺少的内联Hook信息插入到列表控件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>VOID</span> <span class=n>CCheckKernelHookDlg</span><span class=o>::</span><span class=n>InsertDataToList</span><span class=p>(</span><span class=n>PINLINEHOOKINFO</span> <span class=n>PInlineHookInfo</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>CString</span> <span class=n>OrgAddress</span><span class=p>,</span> <span class=n>CurAddress</span><span class=p>,</span> <span class=n>ModuleBase</span><span class=p>,</span> <span class=n>ModuleSize</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>PInlineHookInfo</span><span class=o>-&gt;</span><span class=n>ulCount</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>// 格式化地址和信息
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>OrgAddress</span><span class=p>.</span><span class=n>Format</span><span class=p>(</span><span class=sa>L</span><span class=s>&#34;0x%p&#34;</span><span class=p>,</span> <span class=n>PInlineHookInfo</span><span class=o>-&gt;</span><span class=n>InlineHook</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>ulMemoryFunctionBase</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>CurAddress</span><span class=p>.</span><span class=n>Format</span><span class=p>(</span><span class=sa>L</span><span class=s>&#34;0x%p&#34;</span><span class=p>,</span> <span class=n>PInlineHookInfo</span><span class=o>-&gt;</span><span class=n>InlineHook</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>ulMemoryHookBase</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>ModuleBase</span><span class=p>.</span><span class=n>Format</span><span class=p>(</span><span class=sa>L</span><span class=s>&#34;0x%p&#34;</span><span class=p>,</span> <span class=n>PInlineHookInfo</span><span class=o>-&gt;</span><span class=n>InlineHook</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>ulHookModuleBase</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=n>ModuleSize</span><span class=p>.</span><span class=n>Format</span><span class=p>(</span><span class=sa>L</span><span class=s>&#34;%d&#34;</span><span class=p>,</span> <span class=n>PInlineHookInfo</span><span class=o>-&gt;</span><span class=n>InlineHook</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>ulHookModuleSize</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>n</span> <span class=o>=</span> <span class=n>m_List</span><span class=p>.</span><span class=n>InsertItem</span><span class=p>(</span><span class=n>m_List</span><span class=p>.</span><span class=n>GetItemCount</span><span class=p>(),</span> <span class=n>OrgAddress</span><span class=p>,</span> <span class=mi>0</span><span class=p>);</span> <span class=c1>// 插入项到列表
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>CString</span> <span class=n>szFunc</span> <span class=o>=</span> <span class=sa>L</span><span class=s>&#34;&#34;</span><span class=p>;</span> 
</span></span><span class=line><span class=cl>        <span class=n>CString</span> <span class=n>ModuleName</span> <span class=o>=</span> <span class=sa>L</span><span class=s>&#34;&#34;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>szFunc</span> <span class=o>+=</span> <span class=n>PInlineHookInfo</span><span class=o>-&gt;</span><span class=n>InlineHook</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>lpszFunction</span><span class=p>;</span> <span class=c1>// 函数名称
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>ModuleName</span> <span class=o>+=</span> <span class=n>PInlineHookInfo</span><span class=o>-&gt;</span><span class=n>InlineHook</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>lpszHookModuleImage</span><span class=p>;</span> <span class=c1>// 模块名称
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>m_List</span><span class=p>.</span><span class=n>SetItemText</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=mi>1</span><span class=p>,</span> <span class=n>szFunc</span><span class=p>);</span> <span class=c1>// 设置函数名称
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>m_List</span><span class=p>.</span><span class=n>SetItemText</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=mi>2</span><span class=p>,</span> <span class=n>CurAddress</span><span class=p>);</span> <span class=c1>// 设置当前地址
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>m_List</span><span class=p>.</span><span class=n>SetItemText</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=mi>3</span><span class=p>,</span> <span class=n>ModuleName</span><span class=p>);</span> <span class=c1>// 设置模块名称
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>m_List</span><span class=p>.</span><span class=n>SetItemText</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=mi>4</span><span class=p>,</span> <span class=n>ModuleBase</span><span class=p>);</span> <span class=c1>// 设置模块基址
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=n>m_List</span><span class=p>.</span><span class=n>SetItemText</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=mi>5</span><span class=p>,</span> <span class=n>ModuleSize</span><span class=p>);</span> <span class=c1>// 设置模块大小
</span></span></span><span class=line><span class=cl><span class=c1></span>        
</span></span><span class=line><span class=cl>        <span class=n>CString</span> <span class=n>Type</span> <span class=o>=</span> <span class=sa>L</span><span class=s>&#34;&#34;</span><span class=p>;</span> <span class=c1>// 类型的初始化
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=p>(</span><span class=n>PInlineHookInfo</span><span class=o>-&gt;</span><span class=n>InlineHook</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>ulHookType</span> <span class=o>==</span> <span class=mi>1</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Type</span> <span class=o>+=</span> <span class=sa>L</span><span class=s>&#34;SSDT Hook&#34;</span><span class=p>;</span> <span class=c1>// SSDT Hook 类型
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>PInlineHookInfo</span><span class=o>-&gt;</span><span class=n>InlineHook</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>ulHookType</span> <span class=o>==</span> <span class=mi>2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Type</span> <span class=o>+=</span> <span class=sa>L</span><span class=s>&#34;Next Call Hook&#34;</span><span class=p>;</span> <span class=c1>// 下一次调用 Hook 类型
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span> <span class=nf>if</span> <span class=p>(</span><span class=n>PInlineHookInfo</span><span class=o>-&gt;</span><span class=n>InlineHook</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>ulHookType</span> <span class=o>==</span> <span class=mi>0</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>Type</span> <span class=o>+=</span> <span class=sa>L</span><span class=s>&#34;Inline Hook&#34;</span><span class=p>;</span> <span class=c1>// 内联 Hook 类型
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>m_List</span><span class=p>.</span><span class=n>SetItemText</span><span class=p>(</span><span class=n>n</span><span class=p>,</span> <span class=mi>6</span><span class=p>,</span> <span class=n>Type</span><span class=p>);</span> <span class=c1>// 设置类型
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>UpdateData</span><span class=p>(</span><span class=n>TRUE</span><span class=p>);</span> <span class=c1>// 更新数据
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span></code></pre></div><h1 id=2-checkkernelhookdrv><a class=header-anchor href=#2-checkkernelhookdrv></a>2. CheckKernelHookDrv</h1><h2 id=21-commonh><a class=header-anchor href=#21-commonh></a>2.1 Common.h</h2><p>该代码片段主要是一个用于内核级驱动开发的头文件，包含了一些数据类型定义和多种函数的声明，这些函数一般用于与内核内存和映像的操作。</p><p>整个代码片段的目的在于为内核驱动开发提供基本的工具和接口，主要功能包括：</p><p>- 提供信息获取和内存映射的接口，以便在驱动程序中处理不同的进程和文件。</p><p>- 提供判断和解析相关操作码的能力，便于对函数和代码特征的分析。</p><p>- 使得驱动开发者能够容易访问和处理与Windows内核相关的底层操作，特别是在与SSDT和映像文件处理相关的场景下。</p><ol><li><p><strong>头文件引入</strong></p><ul><li><code>#include "DriverEntry.h"</code>: 引入自定义的驱动程序入口头文件。</li><li><code>#include &lt;ntimage.h></code>: 引入 Windows NT 内核的映像头文件，以支持操作映像文件的结构。</li></ul></li><li><p><strong>类型定义</strong></p><ul><li><code>typedef unsigned long DWORD;</code>: 定义 <code>DWORD</code> 为一个无符号长整型（32位）。</li><li><code>typedef void *HANDLE;</code>: 定义 <code>HANDLE</code> 为一个指向任意类型的指针。</li><li><code>typedef unsigned char BOOL, *PBOOL;</code>: 定义布尔类型 <code>BOOL</code> 及其指针类型 <code>PBOOL</code>。</li><li><code>#define SEC_IMAGE 0x01000000</code>: 定义宏 <code>SEC_IMAGE</code> 的值，用于表示映像的安全标志。</li></ul></li><li><p><strong>函数声明</strong></p><ul><li><code>RtlImageNtHeader</code>: 用于获取可执行映像文件的 NT 头信息。</li><li><code>MapFileInUserSpace</code>: 将指定文件映射到指定进程的用户空间中。</li><li><code>GetSSDTApiFunctionIndexFromNtdll</code>: 从 ntdll.dll 中获取特定的 SSDT（系统服务描述符表） API 函数索引。</li><li><code>IsAddressInSystem</code>: 检查给定地址是否属于系统模块。</li><li><code>GetFunctionCodeSize</code>: 获取特定函数的代码大小。</li><li><code>SizeOfCode</code>: 计算给定代码的大小并识别操作码。</li></ul></li><li><p><strong>操作码类型宏定义</strong></p><ul><li>定义操作码操作的类型，例如 <code>OP_MODRM</code>, <code>OP_DATA_I8</code>, <code>OP_DATA_I32</code> 等，便于在处理或分析汇编代码时使用。</li></ul></li></ol><h2 id=22-commonc><a class=header-anchor href=#22-commonc></a>2.2 Common.c</h2><p>这段代码主要用于在Windows内核驱动开发中，处理有关CPU指令操作码的标识、文件在用户空间的映射、计算函数代码的大小以及检查驱动程序基地址的功能。</p><p>这段代码实现了以下几个主要功能：</p><ul><li><strong>操作码解析</strong>: 用于识别和处理CPU指令的操作码，通过定义标志数组来支持不同的操作数类型。</li><li><strong>文件映射</strong>: 提供了将文件映射到用户空间的能力，便于后续文件的读写和分析操作。</li><li><strong>函数长度计算</strong>: 提供了获取给定函数在内存中的大小的功能，适合用于调试和性能分析。</li><li><strong>地址验证</strong>: 检查特定地址是否在当前运行的驱动程序或模块中，有助于确保驱动的正确性和安全性。</li></ul><ol><li><p><strong>操作码标志数组</strong>:</p><ul><li><code>OpcodeFlags</code> 和 <code>OpcodeFlagsExt</code> 是两个256大小的数组，用于表示不同操作码（Opcode）对应的标志位。这些标志位用于指示操作码的种类、所需的操作数类型等。主要目的是为了在解析和分析汇编代码时，快速了解每条指令的特性。</li></ul></li><li><p><strong><code>MapFileInUserSpace</code> 函数</strong>:</p><ul><li>这个函数的功能是将指定的文件映射到用户空间。</li><li>输入参数包括文件路径和可选的进程句柄，输出参数为映射的基地址和视图大小。</li><li>该函数首先初始化文件路径，然后调用 <code>IoCreateFile</code> 创建文件句柄，接着使用 <code>ZwCreateSection</code> 创建文件映射区域，再通过 <code>ZwMapViewOfSection</code> 将该区域映射到调用进程的地址空间。</li><li>这样可以在用户空间操作驱动文件，有助于调试和分析。</li></ul></li><li><p><strong><code>GetFunctionCodeSize</code> 函数</strong>:</p><ul><li>此函数用于计算给定函数代码的大小，它会通过循环逐条分析指令，直到遇到某些特定条件（如<code>INT3</code>指令或<code>NULL</code>指针）才停止。</li><li>它调用了 <code>SizeOfCode</code> 函数来实际获取各指令的长度，汇总最终的大小进行返回。</li></ul></li><li><p><strong><code>SizeOfCode</code> 函数</strong>:</p><ul><li>该函数负责计算给定代码段的大小，优先处理前缀和操作码，然后根据操作码的不同类型来决定操作数大小，最终返回代码段的长度。</li><li>通过分析操作数标志位，来适应不同类型的数据操作。</li></ul></li><li><p><strong><code>IsAddressInSystem</code> 函数</strong>:</p><ul><li>这个函数的功能是检查指定的驱动程序基地址是否存在于系统模块列表中。</li><li>首先，它会查询系统模块信息的大小，然后分配相应内存获取模块列表，遍历模块，查找给定基地址是否在任何一个模块的地址范围内。</li><li>如果找到，会填充返回参数以提供更多信息。</li></ul></li></ol><h2 id=23-driverentry><a class=header-anchor href=#23-driverentry></a>2.3 DriverEntry</h2><p>这段代码是一个Windows内核驱动程序的实现，主要用于检测内核中的钩子（Hook）行为。以下是逐步分解和详细解释：</p><hr><h3 id=1-头文件引入><a class=header-anchor href=#1-%e5%a4%b4%e6%96%87%e4%bb%b6%e5%bc%95%e5%85%a5></a><strong>1. 头文件引入</strong></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;DriverEntry.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;KernelHookCheck.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;Reload.h&#34;</span><span class=cp>
</span></span></span></code></pre></div><ul><li>引入了三个头文件：<ul><li><code>DriverEntry.h</code>：包含驱动入口函数的声明。</li><li><code>KernelHookCheck.h</code>：包含检测内核钩子的函数声明。</li><li><code>Reload.h</code>：包含重新加载内核模块的函数声明。</li></ul></li></ul><hr><h3 id=2-驱动入口函数><a class=header-anchor href=#2-%e9%a9%b1%e5%8a%a8%e5%85%a5%e5%8f%a3%e5%87%bd%e6%95%b0></a><strong>2. 驱动入口函数 <code>DriverEntry</code></strong></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>NTSTATUS</span> <span class=nf>DriverEntry</span><span class=p>(</span><span class=n>IN</span> <span class=n>PDRIVER_OBJECT</span> <span class=n>DriverObject</span><span class=p>,</span> <span class=n>IN</span> <span class=n>PUNICODE_STRING</span> <span class=n>RegisterPath</span><span class=p>)</span>
</span></span></code></pre></div><ul><li><strong>功能</strong>：驱动程序的入口点，负责初始化驱动程序。</li><li><strong>参数</strong>：<ul><li><code>DriverObject</code>：指向驱动对象的指针。</li><li><code>RegisterPath</code>：注册表路径，通常用于存储驱动配置。</li></ul></li><li><strong>主要逻辑</strong>：<ol><li>初始化设备名称和符号链接名称。</li><li>设置驱动的主要功能函数（<code>MajorFunction</code>）为默认的透传函数 <code>DefaultPassThrough</code>。</li><li>设置驱动的卸载函数为 <code>UnloadDriver</code>。</li><li>创建设备对象（<code>IoCreateDevice</code>）和符号链接（<code>IoCreateSymbolicLink</code>）。</li><li>调用 <code>ReLoadNtos</code> 函数重新加载内核模块。</li><li>返回成功状态 <code>STATUS_SUCCESS</code>。</li></ol></li></ul><hr><h3 id=3-设备控制函数><a class=header-anchor href=#3-%e8%ae%be%e5%a4%87%e6%8e%a7%e5%88%b6%e5%87%bd%e6%95%b0></a><strong>3. 设备控制函数 <code>ControlPassThrough</code></strong></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>NTSTATUS</span> <span class=nf>ControlPassThrough</span><span class=p>(</span><span class=n>PDEVICE_OBJECT</span> <span class=n>DeviceObject</span><span class=p>,</span> <span class=n>PIRP</span> <span class=n>Irp</span><span class=p>)</span>
</span></span></code></pre></div><ul><li><strong>功能</strong>：处理设备控制请求（<code>IRP_MJ_DEVICE_CONTROL</code>）。</li><li><strong>参数</strong>：<ul><li><code>DeviceObject</code>：指向设备对象的指针。</li><li><code>Irp</code>：指向I/O请求包（IRP）的指针。</li></ul></li><li><strong>主要逻辑</strong>：<ol><li>获取IRP的输入缓冲区、输出缓冲区和控制代码。</li><li>根据控制代码 <code>IoControlCode</code> 执行不同的操作：<ul><li>如果控制代码是 <code>CTL_CHECKKERNELMODULE</code>，则调用 <code>KernelHookCheck</code> 函数检测内核钩子。</li><li>如果输出缓冲区无效，则返回失败状态。</li><li>使用 <code>__try</code> 和 <code>__except</code> 处理异常。</li></ul></li><li>完成IRP请求并返回状态。</li></ol></li></ul><hr><h3 id=4-默认透传函数><a class=header-anchor href=#4-%e9%bb%98%e8%ae%a4%e9%80%8f%e4%bc%a0%e5%87%bd%e6%95%b0></a><strong>4. 默认透传函数 <code>DefaultPassThrough</code></strong></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>NTSTATUS</span> <span class=nf>DefaultPassThrough</span><span class=p>(</span><span class=n>PDEVICE_OBJECT</span> <span class=n>DeviceObject</span><span class=p>,</span> <span class=n>PIRP</span> <span class=n>Irp</span><span class=p>)</span>
</span></span></code></pre></div><ul><li><strong>功能</strong>：处理未明确指定的IRP请求。</li><li><strong>参数</strong>：<ul><li><code>DeviceObject</code>：指向设备对象的指针。</li><li><code>Irp</code>：指向I/O请求包（IRP）的指针。</li></ul></li><li><strong>主要逻辑</strong>：<ol><li>设置IRP的状态为成功。</li><li>完成IRP请求并返回成功状态。</li></ol></li></ul><hr><h3 id=5-驱动卸载函数><a class=header-anchor href=#5-%e9%a9%b1%e5%8a%a8%e5%8d%b8%e8%bd%bd%e5%87%bd%e6%95%b0></a><strong>5. 驱动卸载函数 <code>UnloadDriver</code></strong></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>VOID</span> <span class=nf>UnloadDriver</span><span class=p>(</span><span class=n>PDRIVER_OBJECT</span> <span class=n>DriverObject</span><span class=p>)</span>
</span></span></code></pre></div><ul><li><strong>功能</strong>：在驱动程序卸载时执行清理操作。</li><li><strong>参数</strong>：<ul><li><code>DriverObject</code>：指向驱动对象的指针。</li></ul></li><li><strong>主要逻辑</strong>：<ol><li>删除符号链接（<code>IoDeleteSymbolicLink</code>）。</li><li>删除所有设备对象（<code>IoDeleteDevice</code>）。</li><li>打印卸载信息（<code>DbgPrint</code>）。</li></ol></li></ul><hr><h3 id=6-关键功能总结><a class=header-anchor href=#6-%e5%85%b3%e9%94%ae%e5%8a%9f%e8%83%bd%e6%80%bb%e7%bb%93></a><strong>6. 关键功能总结</strong></h3><ul><li><strong>主要功能</strong>：<ol><li><strong>驱动初始化</strong>：在 <code>DriverEntry</code> 中创建设备对象和符号链接，并设置驱动的主要功能函数。</li><li><strong>内核钩子检测</strong>：通过 <code>ControlPassThrough</code> 函数处理设备控制请求，调用 <code>KernelHookCheck</code> 检测内核钩子。</li><li><strong>驱动卸载</strong>：在 <code>UnloadDriver</code> 中清理资源，确保驱动程序安全卸载。</li></ol></li><li><strong>用途</strong>：<ul><li>该驱动程序主要用于检测内核中的钩子行为，通常用于安全领域，如检测恶意软件或Rootkit。</li></ul></li></ul><hr><h3 id=7-代码总结><a class=header-anchor href=#7-%e4%bb%a3%e7%a0%81%e6%80%bb%e7%bb%93></a><strong>7. 代码总结</strong></h3><ul><li><strong>目标</strong>：实现一个Windows内核驱动程序，用于检测内核中的钩子行为。</li><li><strong>核心功能</strong>：<ul><li>初始化驱动并创建设备对象。</li><li>处理设备控制请求，检测内核钩子。</li><li>安全卸载驱动并清理资源。</li></ul></li><li><strong>适用场景</strong>：<ul><li>用于安全分析、恶意软件检测或内核调试。</li></ul></li></ul><h2 id=24-fixrelocation><a class=header-anchor href=#24-fixrelocation></a>2.4 FixRelocation</h2><h3 id=代码逐步分解与详细解释><a class=header-anchor href=#%e4%bb%a3%e7%a0%81%e9%80%90%e6%ad%a5%e5%88%86%e8%a7%a3%e4%b8%8e%e8%af%a6%e7%bb%86%e8%a7%a3%e9%87%8a></a>代码逐步分解与详细解释</h3><h4 id=1-fixbasereloctable-函数><a class=header-anchor href=#1-fixbasereloctable-%e5%87%bd%e6%95%b0></a>1. <strong>FixBaseRelocTable 函数</strong></h4><ul><li><strong>功能</strong>：修复重定位表，确保程序在加载到新的基地址时能够正确运行。</li><li><strong>参数</strong>：<ul><li><code>NewImageBase</code>：新的基地址。</li><li><code>ExistImageBase</code>：现有的基地址。</li></ul></li><li><strong>流程</strong>：<ol><li>通过 <code>RtlImageNtHeader</code> 获取 PE 文件的 NT 头。</li><li>根据 NT 头的 <code>OptionalHeader.Magic</code> 判断是 32 位还是 64 位程序，并获取原始基地址。</li><li>使用 <code>RtlImageDirectoryEntryToData</code> 定位重定位表。</li><li>如果重定位表不存在且未被剥离，则直接返回成功。</li><li>计算新旧基地址的差值 <code>Diff</code>。</li><li>遍历重定位表，调用 <code>LdrProcessRelocationBlockLongLong</code> 对每个重定位块进行处理。</li></ol></li></ul><h4 id=2-ldrprocessrelocationblocklonglong-函数><a class=header-anchor href=#2-ldrprocessrelocationblocklonglong-%e5%87%bd%e6%95%b0></a>2. <strong>LdrProcessRelocationBlockLongLong 函数</strong></h4><ul><li><strong>功能</strong>：处理重定位块，根据重定位类型对地址进行修正。</li><li><strong>参数</strong>：<ul><li><code>VA</code>：虚拟地址。</li><li><code>SizeOfBlock</code>：重定位块的大小。</li><li><code>NextOffset</code>：指向重定位偏移的指针。</li><li><code>Diff</code>：新旧基地址的差值。</li></ul></li><li><strong>流程</strong>：<ol><li>遍历重定位块中的每个重定位项。</li><li>根据重定位类型（如 <code>IMAGE_REL_BASED_HIGHLOW</code>、<code>IMAGE_REL_BASED_HIGH</code> 等），对地址进行修正。</li><li>对于 <code>IMAGE_REL_BASED_IA64_IMM64</code> 类型，处理 IA64 架构的 64 位立即数重定位。</li><li>对于其他类型（如 <code>IMAGE_REL_BASED_ABSOLUTE</code>），不做处理。</li><li>返回下一个重定位块的指针。</li></ol></li></ul><h4 id=3-rtlimagentheaderex-函数><a class=header-anchor href=#3-rtlimagentheaderex-%e5%87%bd%e6%95%b0></a>3. <strong>RtlImageNtHeaderEx 函数</strong></h4><ul><li><strong>功能</strong>：获取 PE 文件的 NT 头，并进行有效性检查。</li><li><strong>参数</strong>：<ul><li><code>Flags</code>：控制标志。</li><li><code>Base</code>：PE 文件的基地址。</li><li><code>Size</code>：PE 文件的大小。</li><li><code>OutHeaders</code>：输出 NT 头指针。</li></ul></li><li><strong>流程</strong>：<ol><li>检查输入参数的有效性。</li><li>检查 PE 文件的 DOS 头签名。</li><li>获取 NT 头的偏移 <code>e_lfanew</code>。</li><li>检查 NT 头的有效性，包括地址范围和签名。</li><li>返回 NT 头指针。</li></ol></li></ul><h4 id=4-rtlimagentheader-函数注释部分><a class=header-anchor href=#4-rtlimagentheader-%e5%87%bd%e6%95%b0%e6%b3%a8%e9%87%8a%e9%83%a8%e5%88%86></a>4. <strong>RtlImageNtHeader 函数（注释部分）</strong></h4><ul><li><strong>功能</strong>：简化版的 <code>RtlImageNtHeaderEx</code>，用于获取 NT 头。</li><li><strong>参数</strong>：<ul><li><code>Base</code>：PE 文件的基地址。</li></ul></li><li><strong>流程</strong>：<ol><li>调用 <code>RtlImageNtHeaderEx</code>，忽略范围检查，获取 NT 头。</li></ol></li></ul><h3 id=代码总结><a class=header-anchor href=#%e4%bb%a3%e7%a0%81%e6%80%bb%e7%bb%93></a>代码总结</h3><h4 id=主要功能><a class=header-anchor href=#%e4%b8%bb%e8%a6%81%e5%8a%9f%e8%83%bd></a>主要功能</h4><ul><li><strong>FixBaseRelocTable</strong>：修复 PE 文件的重定位表，确保程序在加载到新的基地址时能够正确运行。</li><li><strong>LdrProcessRelocationBlockLongLong</strong>：处理重定位块，根据重定位类型对地址进行修正。</li><li><strong>RtlImageNtHeaderEx</strong>：获取 PE 文件的 NT 头，并进行有效性检查。</li></ul><h4 id=关键点><a class=header-anchor href=#%e5%85%b3%e9%94%ae%e7%82%b9></a>关键点</h4><ul><li><strong>重定位表修复</strong>：通过计算新旧基地址的差值，修正重定位表中的地址，确保程序在加载到新的基地址时能够正确运行。</li><li><strong>NT 头获取与检查</strong>：通过 <code>RtlImageNtHeaderEx</code> 获取 PE 文件的 NT 头，并进行有效性检查，确保 PE 文件的合法性。</li></ul><h4 id=应用场景><a class=header-anchor href=#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af></a>应用场景</h4><ul><li><strong>动态加载与重定位</strong>：在动态加载 DLL 或驱动程序时，修复重定位表，确保程序能够正确运行。</li><li><strong>PE 文件解析</strong>：在解析 PE 文件时，获取并检查 NT 头，确保 PE 文件的合法性。</li></ul><p>通过这些功能，代码能够有效地处理 PE 文件的重定位问题，并确保程序在加载到新的基地址时能够正确运行。</p><h2 id=25-kernelhookcheck><a class=header-anchor href=#25-kernelhookcheck></a>2.5 KernelHookCheck</h2><h3 id=代码逐步分解与详细解释-1><a class=header-anchor href=#%e4%bb%a3%e7%a0%81%e9%80%90%e6%ad%a5%e5%88%86%e8%a7%a3%e4%b8%8e%e8%af%a6%e7%bb%86%e8%a7%a3%e9%87%8a-1></a>代码逐步分解与详细解释</h3><ol><li><p><strong>引入头文件</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;Reload.h&#34;</span><span class=cp>
</span></span></span></code></pre></div><ul><li>引入了 <code>Reload.h</code> 头文件，该文件包含了一些与内核模块重载相关的定义和声明。</li></ul></li><li><p><strong>获取系统内核模块信息</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>BOOLEAN</span> <span class=nf>GetSystemKernelModuleInfo</span><span class=p>(</span><span class=n>WCHAR</span> <span class=o>**</span><span class=n>SystemKernelModulePath</span><span class=p>,</span> <span class=n>PDWORD</span> <span class=n>SystemKernelModuleBase</span><span class=p>,</span> <span class=n>PDWORD</span> <span class=n>SystemKernelModuleSize</span><span class=p>);</span>
</span></span></code></pre></div><ul><li>该函数用于获取系统内核模块的路径、基址和大小信息。</li><li>参数：<ul><li><code>SystemKernelModulePath</code>：指向内核模块路径的指针。</li><li><code>SystemKernelModuleBase</code>：指向内核模块基址的指针。</li><li><code>SystemKernelModuleSize</code>：指向内核模块大小的指针。</li></ul></li></ul></li><li><p><strong>获取文件系统的VPB信息</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>BOOLEAN</span> <span class=nf>IoGetFileSystemVpbInfo</span><span class=p>(</span><span class=n>IN</span> <span class=n>PFILE_OBJECT</span> <span class=n>FileObject</span><span class=p>,</span> <span class=n>PDEVICE_OBJECT</span> <span class=o>*</span><span class=n>DeviceObject</span><span class=p>,</span> <span class=n>PDEVICE_OBJECT</span> <span class=o>*</span><span class=n>RealDevice</span><span class=p>);</span>
</span></span></code></pre></div><ul><li>该函数用于获取文件系统的卷参数块（VPB）信息。</li><li>参数：<ul><li><code>FileObject</code>：文件对象指针。</li><li><code>DeviceObject</code>：指向设备对象的指针。</li><li><code>RealDevice</code>：指向实际设备对象的指针。</li></ul></li></ul></li><li><p><strong>从文件完整路径获取设备对象</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>BOOLEAN</span> <span class=nf>GetDeviceObjectFromFileFullName</span><span class=p>(</span><span class=n>WCHAR</span> <span class=o>*</span><span class=n>FileFullName</span><span class=p>,</span> <span class=n>PDEVICE_OBJECT</span> <span class=o>*</span><span class=n>RealDevice</span><span class=p>,</span> <span class=n>PDEVICE_OBJECT</span> <span class=o>*</span><span class=n>DeviceObject</span><span class=p>);</span>
</span></span></code></pre></div><ul><li>该函数通过文件的完整路径获取设备对象。</li><li>参数：<ul><li><code>FileFullName</code>：文件的完整路径。</li><li><code>RealDevice</code>：指向实际设备对象的指针。</li><li><code>DeviceObject</code>：指向设备对象的指针。</li></ul></li></ul></li><li><p><strong>获取Windows根目录名称</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>BOOLEAN</span> <span class=nf>GetWindowsRootName</span><span class=p>(</span><span class=n>WCHAR</span> <span class=o>*</span><span class=n>WindowsRootName</span><span class=p>);</span>
</span></span></code></pre></div><ul><li>该函数用于获取Windows系统的根目录名称。</li><li>参数：<ul><li><code>WindowsRootName</code>：指向存储根目录名称的缓冲区。</li></ul></li></ul></li><li><p><strong>在内核中打开文件</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>NTSTATUS</span> <span class=nf>KernelOpenFile</span><span class=p>(</span><span class=kt>wchar_t</span> <span class=o>*</span><span class=n>FileFullName</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>PHANDLE</span> <span class=n>FileHandle</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>ACCESS_MASK</span> <span class=n>DesiredAccess</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>ULONG</span> <span class=n>FileAttributes</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>ULONG</span> <span class=n>ShareAccess</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>ULONG</span> <span class=n>CreateDisposition</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>    <span class=n>ULONG</span> <span class=n>CreateOptions</span><span class=p>);</span>
</span></span></code></pre></div><ul><li>该函数用于在内核中打开文件。</li><li>参数：<ul><li><code>FileFullName</code>：文件的完整路径。</li><li><code>FileHandle</code>：指向文件句柄的指针。</li><li><code>DesiredAccess</code>：访问权限。</li><li><code>FileAttributes</code>：文件属性。</li><li><code>ShareAccess</code>：共享访问权限。</li><li><code>CreateDisposition</code>：创建选项。</li><li><code>CreateOptions</code>：创建选项。</li></ul></li></ul></li><li><p><strong>获取文件大小</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>NTSTATUS</span> <span class=nf>KernelGetFileSize</span><span class=p>(</span><span class=n>HANDLE</span> <span class=n>hFile</span><span class=p>,</span> <span class=n>PLARGE_INTEGER</span> <span class=n>FileSize</span><span class=p>);</span>
</span></span></code></pre></div><ul><li>该函数用于获取文件的大小。</li><li>参数：<ul><li><code>hFile</code>：文件句柄。</li><li><code>FileSize</code>：指向文件大小的指针。</li></ul></li></ul></li><li><p><strong>从文件中读取数据</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>NTSTATUS</span> <span class=nf>KernelReadFile</span><span class=p>(</span><span class=n>HANDLE</span> <span class=n>hFile</span><span class=p>,</span> <span class=n>PLARGE_INTEGER</span> <span class=n>ByteOffset</span><span class=p>,</span> <span class=n>ULONG</span> <span class=n>Length</span><span class=p>,</span> <span class=n>PVOID</span> <span class=n>FileBuffer</span><span class=p>,</span> <span class=n>PIO_STATUS_BLOCK</span> <span class=n>IoStatusBlock</span><span class=p>);</span>
</span></span></code></pre></div><ul><li>该函数用于从文件中读取数据。</li><li>参数：<ul><li><code>hFile</code>：文件句柄。</li><li><code>ByteOffset</code>：读取的字节偏移量。</li><li><code>Length</code>：读取的长度。</li><li><code>FileBuffer</code>：指向存储读取数据的缓冲区。</li><li><code>IoStatusBlock</code>：指向I/O状态块的指针。</li></ul></li></ul></li><li><p><strong>判断是否为映像文件</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>BOOLEAN</span> <span class=nf>ImageFile</span><span class=p>(</span><span class=n>BYTE</span> <span class=o>*</span><span class=n>FileBuffer</span><span class=p>,</span> <span class=n>BYTE</span> <span class=o>**</span><span class=n>ImageModuleBase</span><span class=p>);</span>
</span></span></code></pre></div><ul><li>该函数用于判断给定的文件缓冲区是否为映像文件（如PE文件）。</li><li>参数：<ul><li><code>FileBuffer</code>：文件缓冲区。</li><li><code>ImageModuleBase</code>：指向映像文件基址的指针。</li></ul></li></ul></li><li><p><strong>对齐大小</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>ULONG</span> <span class=nf>AlignSize</span><span class=p>(</span><span class=n>ULONG</span> <span class=n>nSize</span><span class=p>,</span> <span class=n>ULONG</span> <span class=n>nAlign</span><span class=p>);</span>
</span></span></code></pre></div><ul><li>该函数用于将大小对齐到指定的边界。</li><li>参数：<ul><li><code>nSize</code>：原始大小。</li><li><code>nAlign</code>：对齐边界。</li></ul></li></ul></li><li><p><strong>获取内核模块基址</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>PVOID</span> <span class=nf>GetKernelModuleBase</span><span class=p>(</span><span class=n>PDRIVER_OBJECT</span> <span class=n>DriverObject</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>KernelModuleName</span><span class=p>);</span>
</span></span></code></pre></div><ul><li>该函数用于获取指定内核模块的基址。</li><li>参数：<ul><li><code>DriverObject</code>：驱动对象。</li><li><code>KernelModuleName</code>：内核模块名称。</li></ul></li></ul></li><li><p><strong>插入原始第一个Thunk</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>BOOLEAN</span> <span class=nf>InsertOriginalFirstThunk</span><span class=p>(</span><span class=n>DWORD</span> <span class=n>ImageBase</span><span class=p>,</span> <span class=n>DWORD</span> <span class=n>ExistImageBase</span><span class=p>,</span> <span class=n>PIMAGE_THUNK_DATA</span> <span class=n>FirstThunk</span><span class=p>);</span>
</span></span></code></pre></div><ul><li>该函数用于在导入表中插入原始的第一个Thunk。</li><li>参数：<ul><li><code>ImageBase</code>：映像基址。</li><li><code>ExistImageBase</code>：现有映像基址。</li><li><code>FirstThunk</code>：指向第一个Thunk的指针。</li></ul></li></ul></li><li><p><strong>查找导出例程</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>PVOID</span> <span class=nf>MiFindExportedRoutine</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>IN</span> <span class=n>PVOID</span> <span class=n>DllBase</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>BOOLEAN</span> <span class=n>ByName</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>IN</span> <span class=kt>char</span> <span class=o>*</span><span class=n>RoutineName</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span> <span class=n>Ordinal</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></div><ul><li>该函数用于在DLL中查找导出的例程。</li><li>参数：<ul><li><code>DllBase</code>：DLL基址。</li><li><code>ByName</code>：是否按名称查找。</li><li><code>RoutineName</code>：例程名称。</li><li><code>Ordinal</code>：例程序号。</li></ul></li></ul></li><li><p><strong>修复导入表</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>BOOLEAN</span> <span class=nf>FixImportTable</span><span class=p>(</span><span class=n>BYTE</span> <span class=o>*</span><span class=n>ImageBase</span><span class=p>,</span> <span class=n>DWORD</span> <span class=n>ExistImageBase</span><span class=p>,</span> <span class=n>PDRIVER_OBJECT</span> <span class=n>DriverObject</span><span class=p>);</span>
</span></span></code></pre></div><ul><li>该函数用于修复PE文件的导入表。</li><li>参数：<ul><li><code>ImageBase</code>：映像基址。</li><li><code>ExistImageBase</code>：现有映像基址。</li><li><code>DriverObject</code>：驱动对象。</li></ul></li></ul></li><li><p><strong>加载PE文件</strong></p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>BOOLEAN</span> <span class=nf>PeLoad</span><span class=p>(</span>
</span></span><span class=line><span class=cl>    <span class=n>WCHAR</span> <span class=o>*</span><span class=n>FileFullPath</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>BYTE</span> <span class=o>**</span><span class=n>ImageModeleBase</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>PDRIVER_OBJECT</span> <span class=n>DeviceObject</span><span class=p>,</span>
</span></span><span class=line><span class=cl>    <span class=n>DWORD</span> <span class=n>ExistImageBase</span>
</span></span><span class=line><span class=cl><span class=p>);</span>
</span></span></code></pre></div><ul><li>该函数用于加载PE文件到内存中。</li><li>参数：<ul><li><code>FileFullPath</code>：PE文件的完整路径。</li><li><code>ImageModeleBase</code>：指向映像基址的指针。</li><li><code>DeviceObject</code>：设备对象。</li><li><code>ExistImageBase</code>：现有映像基址。</li></ul></li></ul></li></ol><h3 id=总结-5><a class=header-anchor href=#%e6%80%bb%e7%bb%93-5></a>总结</h3><p>该代码的主要功能是<strong>在内核模式下操作文件、加载和修复PE文件</strong>。具体来说，它提供了以下关键功能：</p><ol><li><strong>文件操作</strong>：包括在内核中打开文件、获取文件大小、读取文件数据等。</li><li><strong>内核模块信息获取</strong>：获取系统内核模块的路径、基址和大小信息。</li><li><strong>PE文件处理</strong>：判断文件是否为映像文件、修复导入表、加载PE文件到内存中。</li><li><strong>内存对齐与模块基址获取</strong>：提供内存对齐功能，并能够获取指定内核模块的基址。</li><li><strong>导入表修复与导出例程查找</strong>：修复PE文件的导入表，并能够在DLL中查找导出的例程。</li></ol><p>这些功能通常用于<strong>内核级Rootkit或驱动开发</strong>中，特别是在需要动态加载和修复内核模块时。</p><h2 id=26-libdasmc><a class=header-anchor href=#26-libdasmc></a>2.6 libdasm.c</h2><p>这段代码是一个简单的x86反汇编库（libdasm），其主要功能是将x86机器码转换为可读的汇编语言指令。代码实现了字节序转换、指令解析、操作数提取以及指令字符串生成等功能。</p><p>以下是代码的逐步分解和详细解释：</p><h3 id=1-文件头和相关库><a class=header-anchor href=#1-%e6%96%87%e4%bb%b6%e5%a4%b4%e5%92%8c%e7%9b%b8%e5%85%b3%e5%ba%93></a>1. 文件头和相关库</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/*
</span></span></span><span class=line><span class=cl><span class=cm> * libdasm -- simple x86 disassembly library
</span></span></span><span class=line><span class=cl><span class=cm> * (c) 2004 - 2005  jt / nologin.org
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> *
</span></span></span><span class=line><span class=cl><span class=cm> * TODO:
</span></span></span><span class=line><span class=cl><span class=cm> * - more documentation
</span></span></span><span class=line><span class=cl><span class=cm> * - do more code validation
</span></span></span><span class=line><span class=cl><span class=cm> */</span>
</span></span></code></pre></div><p>这里是文件头部分，描述了库的名称、版权信息以及TODO列表，提醒开发者后续需要添加的文档和代码验证内容。</p><h3 id=2-包含库和宏定义><a class=header-anchor href=#2-%e5%8c%85%e5%90%ab%e5%ba%93%e5%92%8c%e5%ae%8f%e5%ae%9a%e4%b9%89></a>2. 包含库和宏定义</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;string.h&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;libdasm.h&#34;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&#34;tables.h&#34;</span><span class=cp>
</span></span></span></code></pre></div><p>包含了标准输入输出库和字符串操作库，同时引入了自定义头文件“libdasm.h”和“tables.h”，这些可能包含数据结构定义、常量和其他功能定义。</p><h3 id=3-字节序转换函数><a class=header-anchor href=#3-%e5%ad%97%e8%8a%82%e5%ba%8f%e8%bd%ac%e6%8d%a2%e5%87%bd%e6%95%b0></a>3. 字节序转换函数</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>__inline__</span> <span class=n>BYTE</span> <span class=nf>FETCH8</span><span class=p>(</span><span class=n>BYTE</span> <span class=o>*</span><span class=n>addr</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/* ... */</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>__inline__</span> <span class=n>WORD</span> <span class=nf>FETCH16</span><span class=p>(</span><span class=n>BYTE</span> <span class=o>*</span><span class=n>addr</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/* ... */</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>__inline__</span> <span class=n>DWORD</span> <span class=nf>FETCH32</span><span class=p>(</span><span class=n>BYTE</span> <span class=o>*</span><span class=n>addr</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/* ... */</span> <span class=p>}</span>
</span></span></code></pre></div><p>这三个函数分别用于从内存地址中读取8位、16位和32位的数据，并考虑了不同平台的字节序处理。在x86架构上直接读取，而在其他架构上则使用内存拷贝并进行字节序转换。</p><h3 id=4-指令解析函数><a class=header-anchor href=#4-%e6%8c%87%e4%bb%a4%e8%a7%a3%e6%9e%90%e5%87%bd%e6%95%b0></a>4. 指令解析函数</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>get_real_instruction2</span><span class=p>(</span><span class=n>BYTE</span> <span class=o>*</span><span class=n>addr</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>flags</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/* ... */</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>get_real_instruction</span><span class=p>(</span><span class=n>BYTE</span> <span class=o>*</span><span class=n>addr</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>index</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>flags</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/* ... */</span> <span class=p>}</span>
</span></span></code></pre></div><p>这两个函数负责解析指令，提取操作码及其标志。<code>get_real_instruction</code>函数解析指令的前缀和操作码，并设置相应的标志。<code>get_real_instruction2</code>函数处理具体的2字节和3字节操作码扩展。</p><h3 id=5-操作数解析函数><a class=header-anchor href=#5-%e6%93%8d%e4%bd%9c%e6%95%b0%e8%a7%a3%e6%9e%90%e5%87%bd%e6%95%b0></a>5. 操作数解析函数</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>get_operand</span><span class=p>(</span><span class=n>PINST</span> <span class=n>inst</span><span class=p>,</span> <span class=kt>int</span> <span class=n>oflags</span><span class=p>,</span> <span class=n>PINSTRUCTION</span> <span class=n>instruction</span><span class=p>,</span> <span class=n>POPERAND</span> <span class=n>op</span><span class=p>,</span> <span class=n>BYTE</span> <span class=o>*</span><span class=n>data</span><span class=p>,</span> <span class=kt>int</span> <span class=n>offset</span><span class=p>,</span> <span class=k>enum</span> <span class=n>Mode</span> <span class=n>mode</span><span class=p>,</span> <span class=kt>int</span> <span class=n>iflags</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/* ... */</span> <span class=p>}</span>
</span></span></code></pre></div><p>此函数负责解析操作数并填充操作数结构体。它会根据指令的MODRM字节和其他信息，确定操作数的类型（寄存器、内存、立即数等），并获取其大小和地址。</p><h3 id=6-打印操作数字符串><a class=header-anchor href=#6-%e6%89%93%e5%8d%b0%e6%93%8d%e4%bd%9c%e6%95%b0%e5%ad%97%e7%ac%a6%e4%b8%b2></a>6. 打印操作数字符串</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>get_operand_string</span><span class=p>(</span><span class=n>INSTRUCTION</span> <span class=o>*</span><span class=n>inst</span><span class=p>,</span> <span class=n>OPERAND</span> <span class=o>*</span><span class=n>op</span><span class=p>,</span> <span class=k>enum</span> <span class=n>Format</span> <span class=n>format</span><span class=p>,</span> <span class=n>DWORD</span> <span class=n>offset</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>string</span><span class=p>,</span> <span class=kt>int</span> <span class=n>length</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/* ... */</span> <span class=p>}</span>
</span></span></code></pre></div><p>此函数用于格式化操作数的字符串表示，支持不同的格式（ATT和Intel）。它根据操作数的类型和格式，生成对应的文本字符串。</p><h3 id=7-获取指令函数><a class=header-anchor href=#7-%e8%8e%b7%e5%8f%96%e6%8c%87%e4%bb%a4%e5%87%bd%e6%95%b0></a>7. 获取指令函数</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>get_instruction</span><span class=p>(</span><span class=n>PINSTRUCTION</span> <span class=n>inst</span><span class=p>,</span> <span class=n>BYTE</span> <span class=o>*</span><span class=n>addr</span><span class=p>,</span> <span class=k>enum</span> <span class=n>Mode</span> <span class=n>mode</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/* ... */</span> <span class=p>}</span>
</span></span></code></pre></div><p>该函数从给定的地址获取指令的内容，包括解析指令的各个组成部分（操作码、操作数等），并将其返回。</p><h3 id=8-打印指令字符串><a class=header-anchor href=#8-%e6%89%93%e5%8d%b0%e6%8c%87%e4%bb%a4%e5%ad%97%e7%ac%a6%e4%b8%b2></a>8. 打印指令字符串</h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>get_instruction_string</span><span class=p>(</span><span class=n>INSTRUCTION</span> <span class=o>*</span><span class=n>inst</span><span class=p>,</span> <span class=k>enum</span> <span class=n>Format</span> <span class=n>format</span><span class=p>,</span> <span class=n>DWORD</span> <span class=n>offset</span><span class=p>,</span> <span class=kt>char</span> <span class=o>*</span><span class=n>string</span><span class=p>,</span> <span class=kt>int</span> <span class=n>length</span><span class=p>)</span> <span class=p>{</span> <span class=cm>/* ... */</span> <span class=p>}</span>
</span></span></code></pre></div><p>此函数将指令的助记符、前缀及操作数合并成一个完整的可读字符串，可用于输出。</p><h3 id=9-辅助函数><a class=header-anchor href=#9-%e8%be%85%e5%8a%a9%e5%87%bd%e6%95%b0></a>9. 辅助函数</h3><p>一系列辅助函数用于获取操作数的具体信息（如寄存器类型、操作数类型、立即数、位移等），为其他函数提供支持。</p><h3 id=总结-6><a class=header-anchor href=#%e6%80%bb%e7%bb%93-6></a>总结</h3><p>整体来看，这段代码实现了一个x86反汇编库，通过以下关键功能实现其目标：</p><ul><li><strong>字节序处理</strong>：支持不同平台的字节序读取。</li><li><strong>指令解析</strong>：从机器码中提取出指令的操作码及其相关标志位。</li><li><strong>操作数提取</strong>：根据指令的格式，正确解析操作数并将其类型信息存储。</li><li><strong>字符串生成</strong>：将解析出的指令及操作数转化为可读的汇编语言形式，支持多种格式。</li></ul><p>该库的应用场景可能包括逆向工程、调试工具、静态分析等领域。</p><h2 id=27-reloadc><a class=header-anchor href=#27-reloadc></a>2.7 reload.c</h2><p>这段代码的主要功能是<strong>重载Windows内核模块（如<code>ntoskrnl.exe</code>）并修复系统服务描述符表（SSDT）</strong>，以确保内核函数的调用是安全的、未被篡改的。以下是代码的逐步分解和详细解释：</p><hr><h3 id=1-代码结构概述><a class=header-anchor href=#1-%e4%bb%a3%e7%a0%81%e7%bb%93%e6%9e%84%e6%a6%82%e8%bf%b0></a>1. <strong>代码结构概述</strong></h3><p>代码分为以下几个主要部分：</p><ul><li><strong>全局变量声明</strong>：定义了与内核模块和SSDT相关的全局变量。</li><li><strong>函数重载逻辑</strong>：通过<code>ReLoadNtosCALL</code>函数重载内核函数。</li><li><strong>内核模块初始化</strong>：通过<code>ReLoadNtos</code>和<code>InitSafeOperationModule</code>函数初始化并加载内核模块。</li><li><strong>SSDT修复逻辑</strong>：通过<code>FixOriginalKiServiceTable</code>和<code>GetOriginalKiServiceTable</code>函数修复SSDT表。</li></ul><hr><h3 id=2-全局变量><a class=header-anchor href=#2-%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f></a>2. <strong>全局变量</strong></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>WCHAR</span><span class=o>*</span> <span class=n>SystemKernelFilePath</span> <span class=o>=</span> <span class=nb>NULL</span><span class=p>;</span> <span class=c1>// 系统内核模块文件路径
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ULONG_PTR</span> <span class=n>SystemKernelModuleBase</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// 系统内核模块基址
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ULONG_PTR</span> <span class=n>SystemKernelModuleSize</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=c1>// 系统内核模块大小
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>ULONG_PTR</span> <span class=n>ImageModuleBase</span><span class=p>;</span> <span class=c1>// 重载后的内核模块基址
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=n>PVOID</span> <span class=n>OriginalKiServiceTable</span><span class=p>;</span> <span class=c1>// 原始的SSDT表
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>extern</span> <span class=n>PSERVICE_DESCRIPTOR_TABLE</span> <span class=n>KeServiceDescriptorTable</span><span class=p>;</span> <span class=c1>// 系统服务描述符表
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>PSERVICE_DESCRIPTOR_TABLE</span> <span class=n>OriginalServiceDescriptorTable</span><span class=p>;</span> <span class=c1>// 原始服务描述符表
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>PSERVICE_DESCRIPTOR_TABLE</span> <span class=n>Safe_ServiceDescriptorTable</span><span class=p>;</span> <span class=c1>// 安全服务描述符表
</span></span></span></code></pre></div><ul><li>这些变量用于存储内核模块的信息和SSDT表的相关数据。</li></ul><hr><h3 id=3-函数重载逻辑-><a class=header-anchor href=#3-%e5%87%bd%e6%95%b0%e9%87%8d%e8%bd%bd%e9%80%bb%e8%be%91-></a>3. <strong>函数重载逻辑 (<code>ReLoadNtosCALL</code>)</strong></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>ULONG</span> <span class=nf>ReLoadNtosCALL</span><span class=p>(</span><span class=n>WCHAR</span> <span class=o>*</span><span class=n>lpwzFuncTion</span><span class=p>,</span> <span class=n>ULONG</span> <span class=n>ulOldNtosBase</span><span class=p>,</span> <span class=n>ULONG</span> <span class=n>ulReloadNtosBase</span><span class=p>)</span>
</span></span></code></pre></div><ul><li><strong>功能</strong>：根据函数名、原始内核模块基址和重载后的内核模块基址，计算并返回重载后的函数地址。</li><li><strong>实现步骤</strong>：<ol><li>通过<code>RMmGetSystemRoutineAddress</code>获取原始函数地址。</li><li>计算重载后的函数地址：<code>ulReloadFunctionAddress = (PUCHAR)(ulOldFunctionAddress - ulOldNtosBase + ulReloadNtosBase)</code>。</li><li>如果地址无效，则遍历导出表查找函数地址。</li><li>返回重载后的函数地址。</li></ol></li></ul><hr><h3 id=4-内核模块初始化-><a class=header-anchor href=#4-%e5%86%85%e6%a0%b8%e6%a8%a1%e5%9d%97%e5%88%9d%e5%a7%8b%e5%8c%96-></a>4. <strong>内核模块初始化 (<code>ReLoadNtos</code>)</strong></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>NTSTATUS</span> <span class=nf>ReLoadNtos</span><span class=p>(</span><span class=n>PDRIVER_OBJECT</span> <span class=n>DriverObject</span><span class=p>,</span> <span class=n>DWORD</span> <span class=n>RetAddress</span><span class=p>)</span>
</span></span></code></pre></div><ul><li><strong>功能</strong>：初始化并重载内核模块。</li><li><strong>实现步骤</strong>：<ol><li>调用<code>GetSystemKernelModuleInfo</code>获取系统内核模块信息。</li><li>调用<code>InitSafeOperationModule</code>加载并初始化重载后的内核模块。</li><li>通过<code>ReLoadNtosCALL</code>重载关键函数（如<code>RtlInitUnicodeString</code>、<code>MmGetSystemRoutineAddress</code>等）。</li><li>如果重载失败，返回错误状态。</li></ol></li></ul><hr><h3 id=5-安全操作模块初始化-><a class=header-anchor href=#5-%e5%ae%89%e5%85%a8%e6%93%8d%e4%bd%9c%e6%a8%a1%e5%9d%97%e5%88%9d%e5%a7%8b%e5%8c%96-></a>5. <strong>安全操作模块初始化 (<code>InitSafeOperationModule</code>)</strong></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>BOOLEAN</span> <span class=nf>InitSafeOperationModule</span><span class=p>(</span><span class=n>PDRIVER_OBJECT</span> <span class=n>pDriverObject</span><span class=p>,</span> <span class=n>WCHAR</span> <span class=o>*</span><span class=n>SystemModulePath</span><span class=p>,</span> <span class=n>ULONG</span> <span class=n>KernelModuleBase</span><span class=p>)</span>
</span></span></code></pre></div><ul><li><strong>功能</strong>：加载并初始化重载后的内核模块，修复SSDT表。</li><li><strong>实现步骤</strong>：<ol><li>调用<code>PeLoad</code>加载内核模块。</li><li>分配内存并获取原始的SSDT表。</li><li>调用<code>GetOriginalKiServiceTable</code>获取原始的SSDT基址。</li><li>调用<code>FixOriginalKiServiceTable</code>修复SSDT表中的函数地址。</li><li>创建并初始化安全服务描述符表（<code>Safe_ServiceDescriptorTable</code>）。</li></ol></li></ul><hr><h3 id=6-ssdt修复逻辑-><a class=header-anchor href=#6-ssdt%e4%bf%ae%e5%a4%8d%e9%80%bb%e8%be%91-></a>6. <strong>SSDT修复逻辑 (<code>FixOriginalKiServiceTable</code> 和 <code>GetOriginalKiServiceTable</code>)</strong></h3><h4 id=fixoriginalkiservicetable><a class=header-anchor href=#fixoriginalkiservicetable></a><code>FixOriginalKiServiceTable</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>VOID</span> <span class=nf>FixOriginalKiServiceTable</span><span class=p>(</span><span class=n>PDWORD</span> <span class=n>OriginalKiServiceTable</span><span class=p>,</span> <span class=n>DWORD</span> <span class=n>ModuleBase</span><span class=p>,</span> <span class=n>DWORD</span> <span class=n>ExistImageBase</span><span class=p>)</span>
</span></span></code></pre></div><ul><li><strong>功能</strong>：修复SSDT表中的函数地址，使其指向重载后的内核模块。</li><li><strong>实现步骤</strong>：<ol><li>遍历SSDT表中的每个函数地址。</li><li>计算并修复函数地址：<code>OriginalKiServiceTable[Index] = OriginalKiServiceTable[Index] - ExistImageBase + ModuleBase</code>。</li></ol></li></ul><h4 id=getoriginalkiservicetable><a class=header-anchor href=#getoriginalkiservicetable></a><code>GetOriginalKiServiceTable</code></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>BOOLEAN</span> <span class=nf>GetOriginalKiServiceTable</span><span class=p>(</span><span class=n>BYTE</span> <span class=o>*</span><span class=n>NewImageBase</span><span class=p>,</span> <span class=n>DWORD</span> <span class=n>ExistImageBase</span><span class=p>,</span> <span class=n>DWORD</span> <span class=o>*</span><span class=n>NewKiServiceTable</span><span class=p>)</span>
</span></span></code></pre></div><ul><li><strong>功能</strong>：通过重定位表获取原始的SSDT基址。</li><li><strong>实现步骤</strong>：<ol><li>解析PE文件头，找到重定位表。</li><li>遍历重定位表，查找与<code>KeServiceDescriptorTable</code>相关的重定位项。</li><li>获取并返回原始的SSDT基址。</li></ol></li></ul><hr><h3 id=7-代码总结-1><a class=header-anchor href=#7-%e4%bb%a3%e7%a0%81%e6%80%bb%e7%bb%93-1></a>7. <strong>代码总结</strong></h3><h4 id=主要功能-1><a class=header-anchor href=#%e4%b8%bb%e8%a6%81%e5%8a%9f%e8%83%bd-1></a><strong>主要功能</strong></h4><ul><li><strong>内核模块重载</strong>：通过加载并重载内核模块（如<code>ntoskrnl.exe</code>），确保内核函数的调用是安全的、未被篡改的。</li><li><strong>SSDT修复</strong>：修复系统服务描述符表（SSDT），使其指向重载后的内核模块中的函数地址。</li><li><strong>安全操作模块初始化</strong>：创建并初始化安全服务描述符表，确保系统调用的安全性。</li></ul><h4 id=关键点-1><a class=header-anchor href=#%e5%85%b3%e9%94%ae%e7%82%b9-1></a><strong>关键点</strong></h4><ul><li><strong>重载内核模块</strong>：通过<code>PeLoad</code>加载内核模块，并通过<code>ReLoadNtosCALL</code>重载关键函数。</li><li><strong>SSDT修复</strong>：通过<code>FixOriginalKiServiceTable</code>和<code>GetOriginalKiServiceTable</code>修复SSDT表中的函数地址。</li><li><strong>安全性</strong>：通过创建安全服务描述符表，确保系统调用的安全性，防止内核函数被篡改。</li></ul><hr><h3 id=总结-7><a class=header-anchor href=#%e6%80%bb%e7%bb%93-7></a>总结</h3><p>这段代码的核心目标是<strong>通过重载内核模块和修复SSDT表，确保系统调用的安全性</strong>。它通过加载并重载内核模块、修复SSDT表中的函数地址，以及创建安全服务描述符表，实现了对内核函数的保护和检测。</p></div><footer class=article-footer><ul class=article-tag-list itemprop=keywords><li class=article-tag-list-item data-aos=zoom-in><a class=article-tag-list-link href=/tags/security rel=tag>SECURITY</a></li></ul></footer></div><nav id=article-nav aria-label="Article navigation" data-aos=fade-up><div class="article-nav-link-wrap left"><img data-src=https://jsd.hidict.cn/gh/Satori5ama/graygoo-picture@master/webp/00018.webp data-sizes=auto alt="END - 4" class=lazyload><a href=/post/end-4/ aria-label="Prev:END - 4" title="Prev:END - 4"></a><div class=article-nav-caption>Prev</div><h3 class=article-nav-title>END - 4</h3></div><div class="article-nav-link-wrap right"><img data-src=https://jsd.hidict.cn/gh/Satori5ama/graygoo-picture@master/webp/00002.webp data-sizes=auto alt=人工智能简答题小结 class=lazyload><a href=/post/summary-of-short-answer-questions-on-artificial-intelligence/ aria-label=Next:人工智能简答题小结 title=Next:人工智能简答题小结></a><div class=article-nav-caption>Next</div><h3 class=article-nav-title>人工智能简答题小结</h3></div></nav></article><section id=comments data-aos=fade-up><div class=comment-header><h2 class=comment-title>Leave a comment</h2><div class=comment-selector><div class=comment-selector-wrap><div class=selector-item data-selector=giscus><span>giscus</span></div></div></div></div><div class=comment-content><div class="comment giscus-comment" data-aos=fade-up></div></div></section></section></div><footer id=footer aria-label="Site footer"><div style=width:100%;overflow:hidden><div class=footer-line></div></div><div id=footer-info><div><span class=icon-copyright></span>2023-2025<span class="footer-info-sep rotate"></span>
Satori5ama</div><div>Powered by&nbsp;<a href=https://gohugo.io/ target=_blank rel="noopener nofollow noreferrer">Hugo</a>&nbsp; Theme.<a href=https://github.com/D-Sketon/hugo-theme-reimu target=_blank rel="noopener nofollow noreferrer">Reimu</a></div><div><span class=icon-brush>&nbsp;135.5k</span>
&nbsp;|&nbsp;
<span class=icon-coffee>&nbsp;05:13</span></div><div class=footer-beian><img style=object-fit:contain;margin-right:2px src=https://icp.gov.moe/images/ico64.png alt width=24 height=24>
<a target=_blank rel="noopener nofollow noreferrer" href="https://icp.gov.moe/?keyword=20239514">萌ICP备20239514号</a></div><div><span class=icon-eye></span>
<span id=busuanzi_container_site_pv>Number of visits&nbsp;<span id=busuanzi_value_site_pv></span></span>
&nbsp;|&nbsp;
<span class=icon-user></span>
<span id=busuanzi_container_site_uv>Number of visitors&nbsp;<span id=busuanzi_value_site_uv></span></span></div></div></footer><div class=sidebar-top><div class="sidebar-top-taichi rotate"></div><div class=arrow-up></div></div><div id=mask class=hide></div></div><nav id=mobile-nav aria-label="Mobile navigation"><div class=sidebar-wrap><div class=sidebar-toc-sidebar><h3 class=toc-title>Contents</h3><div class="sidebar-toc-wrapper toc-div-class"><nav id=TableOfContents><ul><li><ul><li><a href=#用户界面部分user-interface>用户界面部分（User Interface）</a></li><li><a href=#内核驱动部分kernel-driver>内核驱动部分（Kernel Driver）</a></li><li><a href=#总结>总结</a></li></ul></li></ul><ul><li><ul><li><a href=#用户界面部分>用户界面部分</a></li><li><a href=#内核驱动部分>内核驱动部分</a></li></ul></li></ul><ul><li><a href=#11-checkkernelhookh>1.1 CheckKernelHook.h</a><ul><li><a href=#总结-1>总结</a></li></ul></li><li><a href=#12-checkkernelhookcpp>1.2 CheckKernelHook.cpp</a><ul><li><a href=#总结-2>总结</a></li></ul></li><li><a href=#13-checkkernelhookdlgh>1.3 CheckKernelHookDlg.h</a></li><li><a href=#14-checkkernelhookdlgcpp>1.4 CheckKernelHookDlg.cpp</a><ul><li><a href=#包含的头文件>包含的头文件</a></li><li><a href=#全局变量>全局变量</a></li><li><a href=#列表结构体定义>列表结构体定义</a></li><li><a href=#列表列信息初始化>列表列信息初始化</a></li><li><a href=#对话框类的实现>对话框类的实现</a></li><li><a href=#ccheckkernelhookdlg对话框类><code>CCheckKernelHookDlg</code>对话框类</a></li><li><a href=#oninitdialog-方法><code>OnInitDialog</code> 方法</a></li><li><a href=#检查内核-hook-状态>检查内核 Hook 状态</a></li><li><a href=#插入数据到列表>插入数据到列表</a></li><li><a href=#消息处理程序和绘画>消息处理程序和绘画</a></li><li><a href=#总结-3>总结</a></li></ul></li><li><a href=#15-addserviceh>1.5 AddService.h</a></li><li><a href=#16-addservicecpp>1.6 AddService.cpp</a><ul><li><a href=#1-头文件包含>1. 头文件包含</a></li><li><a href=#2-release-函数>2. Release 函数</a></li><li><a href=#3-unloaddrv-函数>3. UnloadDrv 函数</a></li><li><a href=#4-loaddrv-函数>4. LoadDrv 函数</a></li><li><a href=#总结-4>总结</a></li></ul></li><li><a href=#核心代码>核心代码</a></li></ul><ul><li><a href=#21-commonh>2.1 Common.h</a></li><li><a href=#22-commonc>2.2 Common.c</a></li><li><a href=#23-driverentry>2.3 DriverEntry</a><ul><li><a href=#1-头文件引入><strong>1. 头文件引入</strong></a></li><li><a href=#2-驱动入口函数><strong>2. 驱动入口函数 <code>DriverEntry</code></strong></a></li><li><a href=#3-设备控制函数><strong>3. 设备控制函数 <code>ControlPassThrough</code></strong></a></li><li><a href=#4-默认透传函数><strong>4. 默认透传函数 <code>DefaultPassThrough</code></strong></a></li><li><a href=#5-驱动卸载函数><strong>5. 驱动卸载函数 <code>UnloadDriver</code></strong></a></li><li><a href=#6-关键功能总结><strong>6. 关键功能总结</strong></a></li><li><a href=#7-代码总结><strong>7. 代码总结</strong></a></li></ul></li><li><a href=#24-fixrelocation>2.4 FixRelocation</a><ul><li><a href=#代码逐步分解与详细解释>代码逐步分解与详细解释</a></li><li><a href=#代码总结>代码总结</a></li></ul></li><li><a href=#25-kernelhookcheck>2.5 KernelHookCheck</a><ul><li><a href=#代码逐步分解与详细解释-1>代码逐步分解与详细解释</a></li><li><a href=#总结-5>总结</a></li></ul></li><li><a href=#26-libdasmc>2.6 libdasm.c</a><ul><li><a href=#1-文件头和相关库>1. 文件头和相关库</a></li><li><a href=#2-包含库和宏定义>2. 包含库和宏定义</a></li><li><a href=#3-字节序转换函数>3. 字节序转换函数</a></li><li><a href=#4-指令解析函数>4. 指令解析函数</a></li><li><a href=#5-操作数解析函数>5. 操作数解析函数</a></li><li><a href=#6-打印操作数字符串>6. 打印操作数字符串</a></li><li><a href=#7-获取指令函数>7. 获取指令函数</a></li><li><a href=#8-打印指令字符串>8. 打印指令字符串</a></li><li><a href=#9-辅助函数>9. 辅助函数</a></li><li><a href=#总结-6>总结</a></li></ul></li><li><a href=#27-reloadc>2.7 reload.c</a><ul><li><a href=#1-代码结构概述>1. <strong>代码结构概述</strong></a></li><li><a href=#2-全局变量>2. <strong>全局变量</strong></a></li><li><a href=#3-函数重载逻辑->3. <strong>函数重载逻辑 (<code>ReLoadNtosCALL</code>)</strong></a></li><li><a href=#4-内核模块初始化->4. <strong>内核模块初始化 (<code>ReLoadNtos</code>)</strong></a></li><li><a href=#5-安全操作模块初始化->5. <strong>安全操作模块初始化 (<code>InitSafeOperationModule</code>)</strong></a></li><li><a href=#6-ssdt修复逻辑->6. <strong>SSDT修复逻辑 (<code>FixOriginalKiServiceTable</code> 和 <code>GetOriginalKiServiceTable</code>)</strong></a></li><li><a href=#7-代码总结-1>7. <strong>代码总结</strong></a></li><li><a href=#总结-7>总结</a></li></ul></li></ul></nav></div></div><div class="sidebar-common-sidebar hidden"><div class=sidebar-author><img data-src=/avatar/avatar.webp data-sizes=auto alt=Satori5ama class=lazyload><div class=sidebar-author-name>Satori5ama</div><div class=sidebar-description>我们称之为路的，其实不过是彷徨。</div></div><div class=sidebar-state><div class=sidebar-state-article><div>Posts</div><div class=sidebar-state-number>79</div></div><a class=sidebar-state-category href=/categories/ aria-label=sidebar-state-category-link><div>Categories</div><div class=sidebar-state-number>7</div></a><a class=sidebar-state-tag href=/tags/ aria-label=sidebar-state-tag-link><div>Tags</div><div class=sidebar-state-number>26</div></a></div><div class=sidebar-social><div class="icon-github sidebar-social-icon"><a href=https://github.com/Satori5ama itemprop=url target=_blank aria-label=github rel="noopener nofollow noreferrer"></a></div></div><div class=sidebar-menu><div class=sidebar-menu-link-wrap><a class=sidebar-menu-link-dummy href=/ aria-label=Home></a><div class='sidebar-menu-icon icon rotate'>&#xe62b;</div><div class=sidebar-menu-link>Home</div></div><div class=sidebar-menu-link-wrap><a class=sidebar-menu-link-dummy href=/archives aria-label=Archives></a><div class='sidebar-menu-icon icon rotate'>&#xe62b;</div><div class=sidebar-menu-link>Archives</div></div><div class=sidebar-menu-link-wrap><a class=sidebar-menu-link-dummy href=/about aria-label=About></a><div class='sidebar-menu-icon icon rotate'>&#xe62b;</div><div class=sidebar-menu-link>About</div></div><div class=sidebar-menu-link-wrap><a class=sidebar-menu-link-dummy href=/friend aria-label=Friend></a><div class='sidebar-menu-icon icon rotate'>&#xe62b;</div><div class=sidebar-menu-link>Friend</div></div></div></div></div><div class=sidebar-btn-wrapper><div class="sidebar-toc-btn current"></div><div class=sidebar-common-btn></div></div></nav></div><script src=https://npm.webcache.cn/lazysizes@5.3.2/lazysizes.min.js integrity=sha384-3gT/vsepWkfz/ff7PpWNUeMzeWoH3cDhm/A8jM7ouoAK0/fP/9bcHHR5kHq2nf+e crossorigin=anonymous></script><script src=https://npm.webcache.cn/clipboard@2.0.11/dist/clipboard.min.js integrity=sha384-J08i8An/QeARD9ExYpvphB8BsyOj3Gh2TSh1aLINKO3L0cMSH2dN3E22zFoXEi0Q crossorigin=anonymous></script><script src=/js/main.js integrity crossorigin=anonymous></script><script src=/js/aos.js integrity crossorigin=anonymous></script><script>var aosInit=()=>{AOS.init({duration:1e3,easing:"ease",once:!0,offset:50})};document.readyState==="loading"?document.addEventListener("DOMContentLoaded",aosInit):aosInit()</script><script src=/js/pjax_main.js integrity crossorigin=anonymous data-pjax></script><script src=https://npm.webcache.cn/mouse-firework@0.1.1/dist/index.umd.js integrity=sha384-8LyaidD9GPxQQgLJO/WRw/O2h3BoNq/ApI/ecpvM6RsrCz2qP2ppBXUKihP4V/2d crossorigin=anonymous></script><script>if((!!1||!window.matchMedia("(max-width: 768px)").matches)&&window.firework){const e=JSON.parse('{"excludeelements":["a","button"],"particles":[{"colors":["var(--red-1)","var(--red-2)","var(--red-3)","var(--red-4)"],"duration":[1200,1800],"easing":"easeOutExpo","move":["emit"],"number":20,"shape":"circle","shapeOptions":{"alpha":[0.3,0.5],"radius":[16,32]}},{"colors":["var(--red-0)"],"duration":[1200,1800],"easing":"easeOutExpo","move":["diffuse"],"number":1,"shape":"circle","shapeOptions":{"alpha":[0.2,0.5],"lineWidth":6,"radius":20}}]}');e.excludeElements=e.excludeelements,delete e.excludeelements,window.firework(e)}</script><div id=lazy-script><div><script data-pjax>window.REIMU_POST={author:"Satori5ama",title:"源代码阅读项目——CheckKernelEATHook",url:"https://username.github.io/post/source-code-reading-project-checkkerneleathook/",description:`ciyze0101/Windows-Rootkits
项目概况 +---CheckKernelHook | | CheckKernelHook.sln | | | \\---CheckKernelHook | | AddService.cpp | | AddService.h | | CheckKernelHook.aps | | CheckKernelHook.cpp | | CheckKernelHook.h | | CheckKernelHook.rc | | CheckKernelHook.vcxproj | | CheckKernelHook.vcxproj.filters | | …`,cover:"https://username.github.io/images/ST.webp"}</script><script src=/js/insert_highlight.js integrity crossorigin=anonymous data-pjax></script><script src=/js/tabs.js integrity crossorigin=anonymous data-pjax></script><script type=module data-pjax>const PhotoSwipeLightbox = (await safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe-lightbox.esm.min.js", "sha384-DiL6M\/gG\u002bwmTxmCRZyD1zee6lIhawn5TGvED0FOh7fXcN9B0aZ9dexSF\/N6lrZi\/")).default;const initPswp = (gallery, children) => {
          if (_$$(`${gallery} ${children}`).length > 0) {
            new PhotoSwipeLightbox({
              gallery,
              children,pswpModule: () => safeImport("https:\/\/npm.webcache.cn\/photoswipe@5.4.4\/dist\/photoswipe.esm.min.js", "sha384-WkkO3GCmgkC3VQWpaV8DqhKJqpzpF9JoByxDmnV8\u002boTJ7m3DfYEWX1fu1scuS4\u002bs")}).init();
          }
        }
        const pswp = () => {
          initPswp('.article-entry', 'a.article-gallery-item');
          initPswp('.article-gallery', 'a.article-gallery-item');
          window.lightboxStatus = 'done';
          window.removeEventListener('lightbox:ready', pswp);
        }
        if(window.lightboxStatus === 'ready') {
          pswp()
        } else {
          window.addEventListener('lightbox:ready', pswp);
        }
      </script><script data-pjax>var defaultComment,savedCommentType,configDefault,loadScript=(e,t)=>{const n=document.createElement("script");return n.src=e,t&&(n.integrity=t),n.crossOrigin="anonymous",n},commentConfigKeys=["valine","waline","twikoo","gitalk","giscus","disqus"],commentConfig={giscus:{enable:!0,load:()=>{const t=document.querySelector(".giscus-comment");if(!t)return;t.style.display="block";const s=t.querySelector('script[src*="giscus.app/client.js"]');s&&s.remove();const o=document.querySelector("iframe.giscus-frame");o&&o.remove();const e=document.createElement("script"),r=document.documentElement.getAttribute("data-theme"),n=document.documentElement.lang||"en",i=n.split("-")[0],a=["ar","be","bg","ca","cs","da","de","en","eo","es","eu","fa","fr","gr","hbs","he","hu","id","it","ja","kh","ko","nl","pl","pt","ro","ru","th","tr","uk","uz","vi","zh-CN","zh-HK","zh-TW"],c=a.includes(n)?n:a.includes(i)?i:"en";e.src="https://giscus.app/client.js",e.setAttribute("data-repo","Satori5ama/Blog-Comment"),e.setAttribute("data-repo-id","R_kgDOKkUUoQ"),e.setAttribute("data-category","Announcements"),e.setAttribute("data-category-id","DIC_kwDOKkUUoc4CaZMl"),e.setAttribute("data-mapping","0"),e.setAttribute("data-strict","0"),e.setAttribute("data-reactions-enabled","1"),e.setAttribute("data-emit-metadata","0"),e.setAttribute("data-input-position","bottom"),e.setAttribute("data-theme",r==="dark"?"dark":"light"),e.setAttribute("data-lang",c),e.setAttribute("crossorigin","anonymous"),e.async=!0,t.appendChild(e),document.body.addEventListener("light-theme-set",()=>{const e=document.querySelector("iframe.giscus-frame");if(!e)return;e.contentWindow.postMessage({giscus:{setConfig:{theme:"light"}}},"https://giscus.app")}),document.body.addEventListener("dark-theme-set",()=>{const e=document.querySelector("iframe.giscus-frame");if(!e)return;e.contentWindow.postMessage({giscus:{setConfig:{theme:"dark"}}},"https://giscus.app")})}}};commentConfig.enable=commentConfigKeys.some(e=>commentConfig?.[e]?.enable),defaultComment="",commentConfig.enable&&(savedCommentType=localStorage.getItem("commentType"),savedCommentType&&commentConfig[savedCommentType]?.enable&&(defaultComment=savedCommentType),defaultComment||(configDefault="waline",commentConfig[configDefault]?.enable&&(defaultComment=configDefault)),defaultComment||(defaultComment=commentConfigKeys.find(e=>commentConfig?.[e]?.enable)||""));function loadComments(){if(!commentConfig.enable)return;const e={valine:!1,waline:!1,twikoo:!1,gitalk:!1,giscus:!1},s=()=>{const e=document.querySelectorAll(".comment");e.forEach(e=>{e.style.display="none"})},t=t=>{if(e[t]){document.querySelector(`.${t}-comment`).style.display="block";return}commentConfig[t]?.load(),e[t]=!0},o=e=>{const n=document.querySelectorAll(".selector-item");for(let e=0;e<n.length;e++)n[e].classList.remove("active");e.classList.add("active");const o=e.getAttribute("data-selector");s(),t(o)},n=()=>{const e=document.querySelectorAll(".selector-item");for(let t of e)t.addEventListener("click",()=>{const e=t.getAttribute("data-selector");window.localStorage.setItem("commentType",e),o(t)});if(defaultComment){const e=document.querySelector(`[data-selector="${defaultComment}"]`);if(!e)return;e.style.display="block",e.classList.add("active"),t(defaultComment)}};document.readyState==="loading"?document.addEventListener("DOMContentLoaded",n):n()}loadComments()</script><script data-pjax>window.MathJax=JSON.parse('[{"loader":{"load":["input/asciimath","[tex]/noerrors"]},"options":{"ignoreHtmlClass":"tex2jax_ignore","processHtmlClass":"tex2jax_process","skipHtmlTags":["script","noscript","style","textarea","pre","code"]},"tex":{"autoload":{"color":[],"colorv2":["color"]},"displayMath":[["$$","$$"],["\\\\\\\\[","\\\\\\\\]"]],"inlineMath":[["$","$"],["\\\\\\\\(","\\\\\\\\)"]],"packages":{"[+]":["noerrors"]},"processEnvironments":true,"processEscapes":true,"tags":"ams","useLabelIds":true}}]')[0]</script><script src=https://npm.webcache.cn/mathjax@3.2.2/es5/tex-mml-chtml.js deferdata-pjaxintegrity=sha384-Wuix6BuhrWbjDBs24bXrjf4ZQ5aFeFWBuKkFekO2t8xFU0iNaLQfp2K6/1Nxveei crossorigin=anonymous></script></div></div><script src=https://npm.webcache.cn/busuanzi@2.3.0/bsz.pure.mini.js asyncintegrity=sha384-0M75wtSkhjIInv4coYlaJU83+OypaRCIq2SukQVQX04eGTCBXJDuWAbJet56id+S crossorigin=anonymous></script><script>"serviceWorker"in navigator&&navigator.serviceWorker.getRegistrations().then(e=>{for(let t of e)t.unregister()})</script><script>const reimuCopyright=String.raw`
   ______     ______     __     __    __     __  __    
  /\  == \   /\  ___\   /\ \   /\ "-./  \   /\ \/\ \   
  \ \  __<   \ \  __\   \ \ \  \ \ \-./\ \  \ \ \_\ \  
   \ \_\ \_\  \ \_____\  \ \_\  \ \_\ \ \_\  \ \_____\ 
    \/_/ /_/   \/_____/   \/_/   \/_/  \/_/   \/_____/ 
                                                    
  `;console.log(String.raw`%c ${reimuCopyright}`,"color: #ff5252;"),console.log("%c Theme.Reimu %c https://github.com/D-Sketon/hugo-theme-reimu ","color: white; background: #ff5252; padding:5px 0;","padding:4px;border:1px solid #ff5252;")</script></body></html>